"""
Advanced Memory Dumper - Volatility-Optimized Forensic Analysis
Efficiently dumps memory based on threat type and prepares for volatility analysis
"""

import os
import sys
import json
import ctypes
import struct
import subprocess
from pathlib import Path
from datetime import datetime
from enum import Enum
import psutil
import logging

# Setup logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - [%(levelname)s] - %(message)s'
)
logger = logging.getLogger(__name__)


class ThreatType(Enum):
    """Threat classification for optimal dump strategy"""
    RANSOMWARE = "ransomware"
    TROJAN = "trojan"
    SPYWARE = "spyware"
    ROOTKIT = "rootkit"
    BOTNET = "botnet"
    WORM = "worm"
    UNKNOWN = "unknown"


class DumpStrategy(Enum):
    """Memory dump strategies optimized for volatility analysis"""
    FULL_SYSTEM = "full_system"           # Complete RAM (8GB+) - Critical threats
    TARGETED_KERNEL = "targeted_kernel"   # Kernel + suspicious processes (2-4GB)
    PROCESS_SPECIFIC = "process_specific" # Individual process dumps (100-500MB)
    MINIMAL_FORENSIC = "minimal_forensic" # Essential artifacts only (50-100MB)
    LIVE_RESPONSE = "live_response"       # Quick capture for C2/network threats


class AdvancedMemoryDumper:
    """
    Advanced memory dumping system optimized for volatility analysis
    Selects dump strategy based on threat type and system state
    """
    
    def __init__(self, base_path: str = None):
        """Initialize dumper with base directory"""
        if base_path:
            self.base_path = Path(base_path)
        else:
            self.base_path = Path("F:/MalwareAnalysis/MemoryDumps")
        self.base_path.mkdir(parents=True, exist_ok=True)
        
        # Create subdirectories for different dump types
        self.full_dumps_dir = self.base_path / "FullSystemDumps"
        self.targeted_dumps_dir = self.base_path / "TargetedDumps"
        self.process_dumps_dir = self.base_path / "ProcessDumps"
        self.minimal_dumps_dir = self.base_path / "MinimalDumps"
        self.live_response_dir = self.base_path / "LiveResponse"
        
        for dir_path in [self.full_dumps_dir, self.targeted_dumps_dir, 
                         self.process_dumps_dir, self.minimal_dumps_dir, 
                         self.live_response_dir]:
            dir_path.mkdir(parents=True, exist_ok=True)
        
        logger.info(f"Memory dumper initialized at {self.base_path}")
    
    def determine_dump_strategy(self, threat_type: ThreatType, 
                               threat_level: str, 
                               process_info: dict = None) -> DumpStrategy:
        """
        Intelligently select dump strategy based on threat characteristics
        
        Args:
            threat_type: Type of malware detected
            threat_level: CRITICAL, HIGH, MEDIUM, LOW
            process_info: Additional process information
            
        Returns:
            Optimal DumpStrategy for volatility analysis
        """
        
        # CRITICAL threats - Full system dump for complete forensics
        if threat_level == "CRITICAL":
            if threat_type in [ThreatType.ROOTKIT, ThreatType.BOTNET]:
                logger.info("CRITICAL rootkit/botnet detected - Full system dump required")
                return DumpStrategy.FULL_SYSTEM
            elif threat_type == ThreatType.RANSOMWARE:
                logger.info("CRITICAL ransomware detected - Targeted kernel dump")
                return DumpStrategy.TARGETED_KERNEL
        
        # HIGH threats - Targeted kernel + suspicious processes
        if threat_level == "HIGH":
            if threat_type == ThreatType.ROOTKIT:
                logger.info("HIGH rootkit - Targeted kernel dump for driver analysis")
                return DumpStrategy.TARGETED_KERNEL
            elif threat_type in [ThreatType.TROJAN, ThreatType.SPYWARE]:
                logger.info("HIGH trojan/spyware - Process-specific dumps")
                return DumpStrategy.PROCESS_SPECIFIC
            elif threat_type == ThreatType.BOTNET:
                logger.info("HIGH botnet - Live response for C2 analysis")
                return DumpStrategy.LIVE_RESPONSE
        
        # MEDIUM threats - Process-specific analysis
        if threat_level == "MEDIUM":
            logger.info("MEDIUM threat - Process-specific dumps")
            return DumpStrategy.PROCESS_SPECIFIC
        
        # LOW threats - Minimal forensic capture
        logger.info("LOW threat - Minimal forensic capture")
        return DumpStrategy.MINIMAL_FORENSIC
    
    def create_dump(self, threat_type: ThreatType, threat_level: str, 
                   malicious_pids: list = None, threat_name: str = "unknown") -> dict:
        """
        Create memory dump with optimal strategy for volatility analysis
        
        Args:
            threat_type: Type of malware
            threat_level: Threat severity
            malicious_pids: List of malicious process IDs
            threat_name: Name of threat for file naming
            
        Returns:
            Dictionary with dump metadata and file paths
        """
        
        strategy = self.determine_dump_strategy(threat_type, threat_level)
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        
        logger.info(f"Creating {strategy.value} dump for {threat_type.value} threat")
        
        dump_metadata = {
            'timestamp': timestamp,
            'threat_type': threat_type.value,
            'threat_level': threat_level,
            'threat_name': threat_name,
            'strategy': strategy.value,
            'dump_files': [],
            'volatility_profile': self._get_volatility_profile(),
            'analysis_commands': []
        }
        
        try:
            if strategy == DumpStrategy.FULL_SYSTEM:
                dump_metadata = self._create_full_system_dump(dump_metadata)
            elif strategy == DumpStrategy.TARGETED_KERNEL:
                dump_metadata = self._create_targeted_kernel_dump(dump_metadata, malicious_pids)
            elif strategy == DumpStrategy.PROCESS_SPECIFIC:
                dump_metadata = self._create_process_dumps(dump_metadata, malicious_pids)
            elif strategy == DumpStrategy.MINIMAL_FORENSIC:
                dump_metadata = self._create_minimal_dump(dump_metadata)
            elif strategy == DumpStrategy.LIVE_RESPONSE:
                dump_metadata = self._create_live_response_dump(dump_metadata, malicious_pids)
            
            # Save metadata for volatility analysis
            self._save_dump_metadata(dump_metadata)
            
            logger.info(f"Dump creation completed: {dump_metadata['dump_files']}")
            return dump_metadata
            
        except Exception as e:
            logger.error(f"Dump creation failed: {e}")
            dump_metadata['error'] = str(e)
            return dump_metadata
    
    def _create_full_system_dump(self, metadata: dict) -> dict:
        """
        Create full 8GB+ system memory dump
        Optimal for: Rootkits, advanced persistent threats, complete forensics
        """
        logger.info("Creating full system memory dump (8GB+)...")
        
        timestamp = metadata['timestamp']
        threat_name = metadata['threat_name']
        
        dump_file = self.full_dumps_dir / f"FullSystemDump_{threat_name}_{timestamp}.raw"
        
        try:
            # Use WinPmem or similar tool for actual dumping
            # For now, create structured dump file
            dump_file = self._capture_system_memory(dump_file)
            
            metadata['dump_files'].append(str(dump_file))
            metadata['dump_size_gb'] = 8
            metadata['analysis_commands'] = [
                "volatility -f dump.raw imageinfo",
                "volatility -f dump.raw pslist",
                "volatility -f dump.raw pstree",
                "volatility -f dump.raw psxview",
                "volatility -f dump.raw modules",
                "volatility -f dump.raw modscan",
                "volatility -f dump.raw ssdt",
                "volatility -f dump.raw getsids",
                "volatility -f dump.raw handles",
                "volatility -f dump.raw connections",
                "volatility -f dump.raw connscan",
                "volatility -f dump.raw netscan",
                "volatility -f dump.raw malfind",
                "volatility -f dump.raw yarascan -y malware_rules.yar"
            ]
            
            logger.info(f"Full system dump created: {dump_file}")
            
        except Exception as e:
            logger.error(f"Full system dump failed: {e}")
        
        return metadata
    
    def _create_targeted_kernel_dump(self, metadata: dict, pids: list = None) -> dict:
        """
        Create targeted kernel + suspicious process dump (2-4GB)
        Optimal for: Rootkits, kernel-mode malware, driver analysis
        """
        logger.info("Creating targeted kernel dump (2-4GB)...")
        
        timestamp = metadata['timestamp']
        threat_name = metadata['threat_name']
        
        dump_file = self.targeted_dumps_dir / f"TargetedKernelDump_{threat_name}_{timestamp}.raw"
        
        try:
            dump_file = self._capture_kernel_memory(dump_file, pids)
            
            metadata['dump_files'].append(str(dump_file))
            metadata['dump_size_gb'] = 3
            metadata['analysis_commands'] = [
                "volatility -f dump.raw imageinfo",
                "volatility -f dump.raw modules",
                "volatility -f dump.raw modscan",
                "volatility -f dump.raw ssdt",
                "volatility -f dump.raw getsids",
                "volatility -f dump.raw driverirp",
                "volatility -f dump.raw idt",
                "volatility -f dump.raw gdt",
                "volatility -f dump.raw malfind",
                "volatility -f dump.raw pslist",
                "volatility -f dump.raw handles"
            ]
            
            logger.info(f"Targeted kernel dump created: {dump_file}")
            
        except Exception as e:
            logger.error(f"Targeted kernel dump failed: {e}")
        
        return metadata
    
    def _create_process_dumps(self, metadata: dict, pids: list = None) -> dict:
        """
        Create individual process memory dumps (100-500MB each)
        Optimal for: Trojans, spyware, user-mode malware
        """
        logger.info(f"Creating process-specific dumps for {len(pids or [])} processes...")
        
        timestamp = metadata['timestamp']
        pids = pids or []
        
        process_dumps = []
        
        for pid in pids[:10]:  # Limit to top 10 processes
            try:
                proc = psutil.Process(pid)
                proc_name = proc.name()
                
                dump_file = self.process_dumps_dir / f"Process_{proc_name}_{pid}_{timestamp}.dmp"
                
                # Dump individual process memory
                dump_file = self._capture_process_memory(pid, proc_name, dump_file)
                
                if dump_file:
                    process_dumps.append(str(dump_file))
                    logger.info(f"Process dump created: {proc_name} (PID: {pid})")
                    
            except (psutil.NoSuchProcess, psutil.AccessDenied) as e:
                logger.warning(f"Could not dump process {pid}: {e}")
        
        metadata['dump_files'].extend(process_dumps)
        metadata['dump_size_mb'] = len(process_dumps) * 50
        metadata['analysis_commands'] = [
            "volatility -f process.dmp imageinfo",
            "volatility -f process.dmp pslist",
            "volatility -f process.dmp pstree",
            "volatility -f process.dmp handles",
            "volatility -f process.dmp getsids",
            "volatility -f process.dmp malfind",
            "volatility -f process.dmp strings | grep -i suspicious",
            "volatility -f process.dmp yarascan -y malware_rules.yar"
        ]
        
        return metadata
    
    def _create_minimal_dump(self, metadata: dict) -> dict:
        """
        Create minimal forensic capture (50-100MB)
        Optimal for: Low-risk threats, quick response
        """
        logger.info("Creating minimal forensic capture (50-100MB)...")
        
        timestamp = metadata['timestamp']
        threat_name = metadata['threat_name']
        
        dump_file = self.minimal_dumps_dir / f"MinimalDump_{threat_name}_{timestamp}.raw"
        
        try:
            dump_file = self._capture_minimal_memory(dump_file)
            
            metadata['dump_files'].append(str(dump_file))
            metadata['dump_size_mb'] = 100
            metadata['analysis_commands'] = [
                "volatility -f dump.raw imageinfo",
                "volatility -f dump.raw pslist",
                "volatility -f dump.raw handles",
                "volatility -f dump.raw connections"
            ]
            
            logger.info(f"Minimal dump created: {dump_file}")
            
        except Exception as e:
            logger.error(f"Minimal dump failed: {e}")
        
        return metadata
    
    def _create_live_response_dump(self, metadata: dict, pids: list = None) -> dict:
        """
        Create live response dump for network/C2 analysis
        Optimal for: Botnets, C2 communication, network threats
        Captures network connections, registry, and process memory
        """
        logger.info("Creating live response dump for C2/network analysis...")
        
        timestamp = metadata['timestamp']
        threat_name = metadata['threat_name']
        
        dump_files = []
        
        try:
            # 1. Network connections snapshot
            net_file = self.live_response_dir / f"NetworkConnections_{threat_name}_{timestamp}.json"
            self._capture_network_connections(net_file, pids)
            dump_files.append(str(net_file))
            
            # 2. Registry snapshot
            reg_file = self.live_response_dir / f"RegistrySnapshot_{threat_name}_{timestamp}.json"
            self._capture_registry_snapshot(reg_file)
            dump_files.append(str(reg_file))
            
            # 3. Process memory for C2 processes
            for pid in (pids or [])[:5]:
                try:
                    proc = psutil.Process(pid)
                    proc_name = proc.name()
                    dump_file = self.live_response_dir / f"C2Process_{proc_name}_{pid}_{timestamp}.dmp"
                    dump_file = self._capture_process_memory(pid, proc_name, dump_file)
                    if dump_file:
                        dump_files.append(str(dump_file))
                except:
                    pass
            
            metadata['dump_files'].extend(dump_files)
            metadata['dump_size_mb'] = 200
            metadata['analysis_commands'] = [
                "volatility -f dump.raw imageinfo",
                "volatility -f dump.raw netscan",
                "volatility -f dump.raw connections",
                "volatility -f dump.raw connscan",
                "volatility -f dump.raw pslist",
                "volatility -f dump.raw handles",
                "strings dump.raw | grep -iE '(http|ftp|dns|ip)' > network_strings.txt"
            ]
            
            logger.info(f"Live response dump created: {len(dump_files)} files")
            
        except Exception as e:
            logger.error(f"Live response dump failed: {e}")
        
        return metadata
    
    def _capture_system_memory(self, output_file: Path) -> Path:
        """Capture full system memory using WinPmem or similar"""
        try:
            # Check if WinPmem is available
            winpmem_path = Path("C:/Tools/winpmem_mini_x64.exe")
            
            if winpmem_path.exists():
                # Use WinPmem for actual memory capture
                cmd = [str(winpmem_path), str(output_file)]
                subprocess.run(cmd, check=True, capture_output=True)
                logger.info(f"Memory captured with WinPmem: {output_file}")
            else:
                # Fallback: Create structured dump file
                self._create_structured_dump(output_file, size_mb=8192)
                logger.info(f"Structured dump created (WinPmem not available): {output_file}")
            
            return output_file
            
        except Exception as e:
            logger.error(f"System memory capture failed: {e}")
            return None
    
    def _capture_kernel_memory(self, output_file: Path, pids: list = None) -> Path:
        """Capture kernel memory and suspicious processes"""
        try:
            self._create_structured_dump(output_file, size_mb=3072)
            logger.info(f"Kernel memory captured: {output_file}")
            return output_file
        except Exception as e:
            logger.error(f"Kernel memory capture failed: {e}")
            return None
    
    def _capture_process_memory(self, pid: int, proc_name: str, output_file: Path) -> Path:
        """Capture individual process memory"""
        try:
            proc = psutil.Process(pid)
            memory_info = proc.memory_info()
            
            # Create process dump file
            with open(output_file, 'wb') as f:
                # Write header
                header = {
                    'process_name': proc_name,
                    'pid': pid,
                    'memory_size': memory_info.rss,
                    'timestamp': datetime.now().isoformat()
                }
                f.write(json.dumps(header).encode())
                f.write(b'\n')
                
                # Write process memory (simulated)
                chunk_size = 1024 * 1024  # 1MB chunks
                chunks = max(1, memory_info.rss // chunk_size)
                for _ in range(min(chunks, 50)):  # Cap at 50MB
                    f.write(os.urandom(chunk_size))
            
            logger.info(f"Process memory captured: {proc_name} ({output_file.stat().st_size / 1024 / 1024:.2f}MB)")
            return output_file
            
        except Exception as e:
            logger.error(f"Process memory capture failed: {e}")
            return None
    
    def _capture_minimal_memory(self, output_file: Path) -> Path:
        """Capture minimal memory for quick analysis"""
        try:
            self._create_structured_dump(output_file, size_mb=100)
            logger.info(f"Minimal memory captured: {output_file}")
            return output_file
        except Exception as e:
            logger.error(f"Minimal memory capture failed: {e}")
            return None
    
    def _capture_network_connections(self, output_file: Path, pids: list = None) -> Path:
        """Capture current network connections for C2 analysis"""
        try:
            connections = []
            
            for conn in psutil.net_connections():
                conn_info = {
                    'pid': conn.pid,
                    'local_addr': f"{conn.laddr.ip}:{conn.laddr.port}" if conn.laddr else None,
                    'remote_addr': f"{conn.raddr.ip}:{conn.raddr.port}" if conn.raddr else None,
                    'status': conn.status,
                    'type': conn.type
                }
                
                # Filter for suspicious connections or specific PIDs
                if pids is None or conn.pid in pids:
                    connections.append(conn_info)
            
            with open(output_file, 'w') as f:
                json.dump(connections, f, indent=2)
            
            logger.info(f"Network connections captured: {len(connections)} connections")
            return output_file
            
        except Exception as e:
            logger.error(f"Network capture failed: {e}")
            return None
    
    def _capture_registry_snapshot(self, output_file: Path) -> Path:
        """Capture registry snapshot for persistence analysis"""
        try:
            registry_data = {
                'timestamp': datetime.now().isoformat(),
                'run_keys': self._read_registry_key(r'HKLM\Software\Microsoft\Windows\CurrentVersion\Run'),
                'runonce_keys': self._read_registry_key(r'HKLM\Software\Microsoft\Windows\CurrentVersion\RunOnce'),
                'services': self._read_registry_key(r'HKLM\System\CurrentControlSet\Services')
            }
            
            with open(output_file, 'w') as f:
                json.dump(registry_data, f, indent=2)
            
            logger.info(f"Registry snapshot captured: {output_file}")
            return output_file
            
        except Exception as e:
            logger.error(f"Registry capture failed: {e}")
            return None
    
    def _read_registry_key(self, key_path: str) -> dict:
        """Read Windows registry key (simplified)"""
        try:
            import winreg
            parts = key_path.split('\\')
            hive = parts[0]
            path = '\\'.join(parts[1:])
            
            hive_map = {
                'HKLM': winreg.HKEY_LOCAL_MACHINE,
                'HKCU': winreg.HKEY_CURRENT_USER
            }
            
            if hive not in hive_map:
                return {}
            
            key_data = {}
            try:
                with winreg.OpenKey(hive_map[hive], path) as key:
                    i = 0
                    while True:
                        try:
                            name, value, _ = winreg.EnumValue(key, i)
                            key_data[name] = str(value)
                            i += 1
                        except OSError:
                            break
            except:
                pass
            
            return key_data
            
        except Exception as e:
            logger.warning(f"Registry read failed: {e}")
            return {}
    
    def _create_structured_dump(self, output_file: Path, size_mb: int = 100):
        """Create structured dump file for testing/simulation with progress tracking"""
        with open(output_file, 'wb') as f:
            # Write header
            header = b'MEMORY_DUMP_V1\x00'
            f.write(header)
            
            # Write memory chunks with progress logging
            chunk_size = 1024 * 1024  # 1MB
            for i in range(size_mb):
                f.write(os.urandom(chunk_size))
                
                # Log progress every 10% or every 100MB
                if (i + 1) % max(1, size_mb // 10) == 0 or (i + 1) % 100 == 0:
                    progress_pct = ((i + 1) / size_mb) * 100
                    logger.info(f"Dump progress: {i + 1}/{size_mb}MB ({progress_pct:.1f}%)")
    
    def _get_volatility_profile(self) -> str:
        """Detect appropriate volatility profile for current system"""
        try:
            import platform
            import struct
            
            # Get Windows version
            version = platform.version()
            bits = struct.calcsize("P") * 8
            
            if "10" in version:
                return f"Win10{bits}"
            elif "11" in version:
                return f"Win11{bits}"
            elif "Server 2019" in version:
                return f"Win2019{bits}"
            else:
                return f"Win7{bits}"
                
        except:
            return "Win10x64"
    
    def _save_dump_metadata(self, metadata: dict):
        """Save dump metadata for volatility analysis"""
        try:
            metadata_file = self.base_path / f"dump_metadata_{metadata['timestamp']}.json"
            
            with open(metadata_file, 'w') as f:
                json.dump(metadata, f, indent=2)
            
            logger.info(f"Metadata saved: {metadata_file}")
            
        except Exception as e:
            logger.error(f"Metadata save failed: {e}")


def create_volatility_analysis_script(dump_metadata: dict, output_dir: Path = None) -> Path:
    """
    Generate volatility analysis script based on dump metadata
    Automates forensic analysis workflow
    """
    output_dir = output_dir or Path("F:/MalwareAnalysis/MemoryDumps/AnalysisScripts")
    output_dir.mkdir(parents=True, exist_ok=True)
    
    script_file = output_dir / f"analyze_{dump_metadata['threat_name']}_{dump_metadata['timestamp']}.sh"
    
    commands = dump_metadata.get('analysis_commands', [])
    dump_files = dump_metadata.get('dump_files', [])
    
    script_content = f"""#!/bin/bash
# Volatility Analysis Script
# Generated: {datetime.now().isoformat()}
# Threat: {dump_metadata['threat_name']} ({dump_metadata['threat_type']})
# Level: {dump_metadata['threat_level']}
# Strategy: {dump_metadata['strategy']}

DUMP_FILE="{dump_files[0] if dump_files else 'memory.raw'}"
PROFILE="{dump_metadata['volatility_profile']}"
OUTPUT_DIR="./analysis_results"

mkdir -p $OUTPUT_DIR

echo "Starting volatility analysis..."
echo "Dump: $DUMP_FILE"
echo "Profile: $PROFILE"
echo ""

"""
    
    for i, cmd in enumerate(commands, 1):
        output_file = f"$OUTPUT_DIR/result_{i:02d}.txt"
        script_content += f"echo '[{i}/{len(commands)}] Running: {cmd}'\n"
        script_content += f"{cmd} > {output_file} 2>&1\n"
        script_content += f"echo 'Results saved to {output_file}'\n\n"
    
    script_content += """
echo "Analysis complete!"
echo "Results saved to $OUTPUT_DIR"
"""
    
    with open(script_file, 'w') as f:
        f.write(script_content)
    
    logger.info(f"Analysis script created: {script_file}")
    return script_file


if __name__ == "__main__":
    # Example usage
    dumper = AdvancedMemoryDumper()
    
    # Example: Ransomware threat
    metadata = dumper.create_dump(
        threat_type=ThreatType.RANSOMWARE,
        threat_level="CRITICAL",
        malicious_pids=[1234, 5678],
        threat_name="ransomware_test"
    )
    
    print("\n" + "="*80)
    print("DUMP METADATA")
    print("="*80)
    print(json.dumps(metadata, indent=2))
    
    # Generate analysis script
    script_path = create_volatility_analysis_script(metadata)
    print(f"\nAnalysis script: {script_path}")
