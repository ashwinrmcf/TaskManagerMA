"""
Dump Countdown Timer
Provides visual countdown before memory dump execution
Integrates with quarantine workflow: Detect → Quarantine → Countdown → Dump
"""

import time
import sys
from datetime import datetime
from pathlib import Path
import logging

logger = logging.getLogger(__name__)


class DumpCountdown:
    """
    Visual countdown timer before memory dump
    Shows progress and threat information during countdown
    """
    
    def __init__(self, countdown_seconds: int = 5):
        """
        Initialize countdown timer
        
        Args:
            countdown_seconds: Number of seconds to countdown (default: 5)
        """
        self.countdown_seconds = countdown_seconds
        self.start_time = None
        self.is_running = False
    
    def start_countdown(self, threat_info: dict = None) -> bool:
        """
        Start countdown timer with threat information display
        
        Args:
            threat_info: Dictionary with threat details:
                - threat_name: str
                - threat_type: str
                - threat_level: str
                - risk_score: int
                - quarantine_path: str
        
        Returns:
            True if countdown completed successfully
        """
        
        self.is_running = True
        self.start_time = datetime.now()
        
        threat_name = threat_info.get('threat_name', 'Unknown') if threat_info else 'Unknown'
        threat_type = threat_info.get('threat_type', 'Unknown') if threat_info else 'Unknown'
        threat_level = threat_info.get('threat_level', 'UNKNOWN') if threat_info else 'UNKNOWN'
        risk_score = threat_info.get('risk_score', 0) if threat_info else 0
        
        # Display header
        self._display_countdown_header(threat_name, threat_type, threat_level, risk_score)
        
        # Run countdown
        try:
            for remaining in range(self.countdown_seconds, 0, -1):
                self._display_countdown_tick(remaining, threat_name)
                time.sleep(1)
            
            # Countdown complete
            self._display_countdown_complete(threat_name)
            self.is_running = False
            
            logger.info(f"Countdown completed for {threat_name}")
            return True
            
        except KeyboardInterrupt:
            self._display_countdown_interrupted(threat_name)
            self.is_running = False
            logger.warning(f"Countdown interrupted for {threat_name}")
            return False
        except Exception as e:
            logger.error(f"Countdown error: {e}")
            self.is_running = False
            return False
    
    def _display_countdown_header(self, threat_name: str, threat_type: str, 
                                  threat_level: str, risk_score: int):
        """Display countdown header with threat information"""
        
        # Color codes for threat levels
        level_colors = {
            'CRITICAL': '\033[91m',  # Red
            'HIGH': '\033[93m',      # Yellow
            'MEDIUM': '\033[94m',    # Blue
            'LOW': '\033[92m'        # Green
        }
        
        reset = '\033[0m'
        bold = '\033[1m'
        color = level_colors.get(threat_level, '\033[0m')
        
        print("\n" + "="*80)
        print(f"{bold}{color}⚠️  DUMP COUNTDOWN INITIATED{reset}")
        print("="*80)
        print(f"\n{bold}Threat Information:{reset}")
        print(f"  Name:  {threat_name}")
        print(f"  Type:  {threat_type}")
        print(f"  Level: {color}{threat_level}{reset}")
        print(f"  Score: {risk_score}/100")
        print(f"\n{bold}Status:{reset}")
        print(f"  ✓ File quarantined")
        print(f"  ⏳ Initiating memory dump in {self.countdown_seconds} seconds...")
        print(f"\n{bold}Countdown:{reset}")
    
    def _display_countdown_tick(self, remaining: int, threat_name: str):
        """Display countdown tick"""
        
        # Progress bar
        progress = (self.countdown_seconds - remaining) / self.countdown_seconds
        bar_length = 30
        filled = int(bar_length * progress)
        bar = '█' * filled + '░' * (bar_length - filled)
        
        # Color based on remaining time
        if remaining > 3:
            color = '\033[92m'  # Green
        elif remaining > 1:
            color = '\033[93m'  # Yellow
        else:
            color = '\033[91m'  # Red
        
        reset = '\033[0m'
        
        # Display tick
        sys.stdout.write(f"\r  {color}[{bar}]{reset} {remaining}s remaining... ")
        sys.stdout.flush()
    
    def _display_countdown_complete(self, threat_name: str):
        """Display countdown completion message"""
        
        reset = '\033[0m'
        bold = '\033[1m'
        green = '\033[92m'
        
        print(f"\n\n{bold}{green}✓ Countdown Complete!{reset}")
        print(f"{bold}Initiating memory dump for: {threat_name}{reset}\n")
    
    def _display_countdown_interrupted(self, threat_name: str):
        """Display countdown interruption message"""
        
        reset = '\033[0m'
        bold = '\033[1m'
        yellow = '\033[93m'
        
        print(f"\n\n{bold}{yellow}⚠ Countdown Interrupted!{reset}")
        print(f"{bold}Memory dump cancelled for: {threat_name}{reset}\n")
    
    def get_elapsed_time(self) -> float:
        """Get elapsed time since countdown started"""
        if not self.start_time:
            return 0
        return (datetime.now() - self.start_time).total_seconds()
    
    def is_active(self) -> bool:
        """Check if countdown is currently running"""
        return self.is_running


class CountdownManager:
    """
    Manages countdown workflow: Quarantine → Countdown → Dump
    Coordinates with quarantine and dump systems
    """
    
    def __init__(self, countdown_seconds: int = 5):
        """Initialize countdown manager"""
        self.countdown = DumpCountdown(countdown_seconds)
        self.countdown_seconds = countdown_seconds
    
    def execute_quarantine_dump_workflow(self, threat_info: dict, 
                                        quarantine_callback=None,
                                        dump_callback=None) -> dict:
        """
        Execute complete workflow: Quarantine → Countdown → Dump
        
        Args:
            threat_info: Dictionary with threat details
            quarantine_callback: Function to call for quarantine (already done)
            dump_callback: Function to call for memory dump
        
        Returns:
            Dictionary with workflow results
        """
        
        workflow_result = {
            'timestamp': datetime.now().isoformat(),
            'threat_name': threat_info.get('threat_name', 'Unknown'),
            'threat_type': threat_info.get('threat_type', 'Unknown'),
            'threat_level': threat_info.get('threat_level', 'UNKNOWN'),
            'workflow_status': 'INITIATED',
            'quarantine_status': 'COMPLETED',
            'countdown_status': 'PENDING',
            'dump_status': 'PENDING',
            'errors': []
        }
        
        try:
            # Step 1: Quarantine (already done by PreAnalyzer)
            logger.info(f"[WORKFLOW] Quarantine status: COMPLETED")
            workflow_result['quarantine_status'] = 'COMPLETED'
            
            # Step 2: Countdown
            logger.info(f"[WORKFLOW] Starting countdown: {self.countdown_seconds}s")
            countdown_success = self.countdown.start_countdown(threat_info)
            
            if countdown_success:
                workflow_result['countdown_status'] = 'COMPLETED'
                logger.info(f"[WORKFLOW] Countdown status: COMPLETED")
                
                # Step 3: Memory Dump
                logger.info(f"[WORKFLOW] Initiating memory dump")
                
                if dump_callback and callable(dump_callback):
                    dump_result = dump_callback(threat_info)
                    workflow_result['dump_status'] = 'COMPLETED'
                    workflow_result['dump_result'] = dump_result
                    logger.info(f"[WORKFLOW] Memory dump status: COMPLETED")
                else:
                    workflow_result['dump_status'] = 'SKIPPED'
                    logger.warning(f"[WORKFLOW] No dump callback provided")
            else:
                workflow_result['countdown_status'] = 'INTERRUPTED'
                workflow_result['dump_status'] = 'SKIPPED'
                logger.warning(f"[WORKFLOW] Countdown interrupted, dump skipped")
            
            workflow_result['workflow_status'] = 'COMPLETED'
            
        except Exception as e:
            workflow_result['workflow_status'] = 'FAILED'
            workflow_result['errors'].append(str(e))
            logger.error(f"[WORKFLOW] Error: {e}")
        
        return workflow_result


def display_workflow_summary(workflow_result: dict):
    """Display workflow execution summary"""
    
    reset = '\033[0m'
    bold = '\033[1m'
    green = '\033[92m'
    red = '\033[91m'
    
    print("\n" + "="*80)
    print(f"{bold}WORKFLOW EXECUTION SUMMARY{reset}")
    print("="*80)
    
    print(f"\n{bold}Threat:{reset}")
    print(f"  Name:  {workflow_result['threat_name']}")
    print(f"  Type:  {workflow_result['threat_type']}")
    print(f"  Level: {workflow_result['threat_level']}")
    
    print(f"\n{bold}Workflow Status:{reset}")
    
    # Quarantine status
    status_color = green if workflow_result['quarantine_status'] == 'COMPLETED' else red
    print(f"  {status_color}✓{reset} Quarantine: {workflow_result['quarantine_status']}")
    
    # Countdown status
    status_color = green if workflow_result['countdown_status'] == 'COMPLETED' else red
    print(f"  {status_color}✓{reset} Countdown: {workflow_result['countdown_status']}")
    
    # Dump status
    status_color = green if workflow_result['dump_status'] == 'COMPLETED' else red
    print(f"  {status_color}✓{reset} Memory Dump: {workflow_result['dump_status']}")
    
    # Overall status
    overall_color = green if workflow_result['workflow_status'] == 'COMPLETED' else red
    print(f"\n{bold}{overall_color}Overall Status: {workflow_result['workflow_status']}{reset}")
    
    if workflow_result['errors']:
        print(f"\n{bold}Errors:{reset}")
        for error in workflow_result['errors']:
            print(f"  {red}✗{reset} {error}")
    
    print("\n" + "="*80 + "\n")


if __name__ == "__main__":
    # Example usage
    threat_info = {
        'threat_name': 'ransomware_test.py',
        'threat_type': 'RANSOMWARE',
        'threat_level': 'CRITICAL',
        'risk_score': 85,
        'quarantine_path': 'F:/MalwareAnalysis/Daemon/Quarantine/quarantine_20251117_195324_ransomware_test'
    }
    
    # Create countdown manager
    manager = CountdownManager(countdown_seconds=5)
    
    # Execute workflow
    print("\n[TEST] Executing Quarantine → Countdown → Dump workflow\n")
    
    result = manager.execute_quarantine_dump_workflow(
        threat_info=threat_info,
        dump_callback=lambda info: {'status': 'SIMULATED', 'files': []}
    )
    
    # Display summary
    display_workflow_summary(result)
