"""
Memory Dump Integration Module
Bridges PreAnalyzer threat detection with Advanced Memory Dumper
"""

import json
import logging
from pathlib import Path
from datetime import datetime
from advanced_memory_dumper import (
    AdvancedMemoryDumper, ThreatType, DumpStrategy, 
    create_volatility_analysis_script
)

logger = logging.getLogger(__name__)


class MemoryDumpIntegration:
    """
    Integrates threat detection with memory dumping
    Automatically triggers appropriate dumps based on PreAnalyzer results
    """
    
    def __init__(self, base_path: str = None):
        """Initialize integration"""
        self.dumper = AdvancedMemoryDumper(base_path)
        self.threat_mapping = self._create_threat_mapping()
        self.dump_history = []
    
    def _create_threat_mapping(self) -> dict:
        """Map PreAnalyzer threat types to ThreatType enum"""
        return {
            'RANSOMWARE': ThreatType.RANSOMWARE,
            'TROJAN': ThreatType.TROJAN,
            'BACKDOOR': ThreatType.TROJAN,
            'SPYWARE': ThreatType.SPYWARE,
            'KEYLOGGER': ThreatType.SPYWARE,
            'ROOTKIT': ThreatType.ROOTKIT,
            'BOTNET': ThreatType.BOTNET,
            'WORM': ThreatType.WORM,
            'UNKNOWN': ThreatType.UNKNOWN
        }
    
    def process_threat_detection(self, threat_info: dict) -> dict:
        """
        Process threat detection from PreAnalyzer and trigger memory dump
        
        Args:
            threat_info: Dictionary from PreAnalyzer with:
                - threat_type: str (RANSOMWARE, TROJAN, etc.)
                - threat_level: str (CRITICAL, HIGH, MEDIUM, LOW)
                - risk_score: int (0-100)
                - indicators: list
                - pid: int
                - name: str
                - path: str
                - cmdline: str
        
        Returns:
            Dictionary with dump results and metadata
        """
        
        logger.info(f"Processing threat detection: {threat_info.get('threat_type')}")
        
        # Map threat type
        threat_type_str = threat_info.get('threat_type', 'UNKNOWN').upper()
        threat_type = self.threat_mapping.get(threat_type_str, ThreatType.UNKNOWN)
        
        # Get threat level
        threat_level = threat_info.get('threat_level', 'LOW').upper()
        
        # Extract PIDs
        malicious_pids = [threat_info.get('pid')] if threat_info.get('pid') else []
        
        # Get threat name
        threat_name = threat_info.get('name', 'unknown_threat')
        
        # Create memory dump
        dump_metadata = self.dumper.create_dump(
            threat_type=threat_type,
            threat_level=threat_level,
            malicious_pids=malicious_pids,
            threat_name=threat_name
        )
        
        # Enhance metadata with PreAnalyzer info
        dump_metadata['preanalyzer_info'] = {
            'risk_score': threat_info.get('risk_score'),
            'indicators': threat_info.get('indicators', []),
            'path': threat_info.get('path'),
            'cmdline': threat_info.get('cmdline'),
            'confidence': threat_info.get('confidence', 0)
        }
        
        # Generate volatility analysis script
        analysis_script = create_volatility_analysis_script(dump_metadata)
        dump_metadata['analysis_script'] = str(analysis_script)
        
        # Save integration report
        self._save_integration_report(dump_metadata)
        
        # Track dump
        self.dump_history.append({
            'timestamp': datetime.now().isoformat(),
            'threat_name': threat_name,
            'threat_type': threat_type.value,
            'threat_level': threat_level,
            'strategy': dump_metadata.get('strategy'),
            'dump_files': dump_metadata.get('dump_files', [])
        })
        
        logger.info(f"Memory dump completed for {threat_name}")
        
        return dump_metadata
    
    def process_quarantine_event(self, quarantine_info: dict) -> dict:
        """
        Process quarantine event and create forensic dump
        
        Args:
            quarantine_info: Dictionary with:
                - original_path: str
                - quarantine_path: str
                - threat_level: str
                - threat_type: str
        
        Returns:
            Dictionary with dump results
        """
        
        logger.info(f"Processing quarantine event: {quarantine_info.get('original_path')}")
        
        threat_type_str = quarantine_info.get('threat_type', 'UNKNOWN').upper()
        threat_type = self.threat_mapping.get(threat_type_str, ThreatType.UNKNOWN)
        threat_level = quarantine_info.get('threat_level', 'HIGH').upper()
        
        # Create forensic dump for quarantined file
        dump_metadata = self.dumper.create_dump(
            threat_type=threat_type,
            threat_level=threat_level,
            threat_name=Path(quarantine_info.get('original_path', 'unknown')).stem
        )
        
        dump_metadata['quarantine_info'] = quarantine_info
        
        self._save_integration_report(dump_metadata)
        
        return dump_metadata
    
    def _save_integration_report(self, dump_metadata: dict):
        """Save integration report for analysis"""
        try:
            report_dir = Path("F:/MalwareAnalysis/MemoryDumps/IntegrationReports")
            report_dir.mkdir(parents=True, exist_ok=True)
            
            report_file = report_dir / f"integration_{dump_metadata['timestamp']}.json"
            
            with open(report_file, 'w') as f:
                json.dump(dump_metadata, f, indent=2)
            
            logger.info(f"Integration report saved: {report_file}")
            
        except Exception as e:
            logger.error(f"Failed to save integration report: {e}")
    
    def get_dump_history(self) -> list:
        """Get history of all dumps"""
        return self.dump_history
    
    def generate_forensic_report(self, output_file: str = None) -> Path:
        """Generate comprehensive forensic report"""
        output_file = output_file or "F:/MalwareAnalysis/MemoryDumps/ForensicReport.json"
        output_path = Path(output_file)
        output_path.parent.mkdir(parents=True, exist_ok=True)
        
        report = {
            'generated': datetime.now().isoformat(),
            'total_dumps': len(self.dump_history),
            'dump_history': self.dump_history,
            'recommendations': self._generate_recommendations()
        }
        
        with open(output_path, 'w') as f:
            json.dump(report, f, indent=2)
        
        logger.info(f"Forensic report generated: {output_path}")
        return output_path
    
    def _generate_recommendations(self) -> list:
        """Generate forensic analysis recommendations"""
        recommendations = []
        
        if not self.dump_history:
            return recommendations
        
        # Analyze threat patterns
        threat_types = [d['threat_type'] for d in self.dump_history]
        threat_levels = [d['threat_level'] for d in self.dump_history]
        
        # Recommendations based on threats
        if 'rootkit' in threat_types:
            recommendations.append({
                'priority': 'CRITICAL',
                'category': 'Kernel Analysis',
                'action': 'Run volatility malfind, ssdt, gdt, idt modules for rootkit detection',
                'tools': ['volatility', 'IDA Pro', 'Ghidra']
            })
        
        if 'botnet' in threat_types:
            recommendations.append({
                'priority': 'CRITICAL',
                'category': 'Network Analysis',
                'action': 'Analyze network connections, DNS queries, and C2 communication',
                'tools': ['volatility netscan', 'Wireshark', 'IDA Pro']
            })
        
        if 'ransomware' in threat_types:
            recommendations.append({
                'priority': 'HIGH',
                'category': 'Behavior Analysis',
                'action': 'Analyze file operations, registry modifications, and encryption routines',
                'tools': ['volatility', 'Procmon', 'Regshot']
            })
        
        if 'spyware' in threat_types or 'keylogger' in threat_types:
            recommendations.append({
                'priority': 'HIGH',
                'category': 'Data Exfiltration',
                'action': 'Analyze network connections, file access, and clipboard operations',
                'tools': ['volatility', 'Wireshark', 'Procmon']
            })
        
        if 'CRITICAL' in threat_levels:
            recommendations.append({
                'priority': 'CRITICAL',
                'category': 'Incident Response',
                'action': 'Isolate system, preserve evidence, and escalate to security team',
                'tools': ['Forensic imaging', 'Chain of custody']
            })
        
        return recommendations


class DumpStrategyAnalyzer:
    """Analyzes dump strategies and provides optimization recommendations"""
    
    @staticmethod
    def analyze_dump_efficiency(dump_metadata: dict) -> dict:
        """Analyze dump efficiency and provide recommendations"""
        
        analysis = {
            'strategy': dump_metadata.get('strategy'),
            'threat_type': dump_metadata.get('threat_type'),
            'threat_level': dump_metadata.get('threat_level'),
            'efficiency_score': 0,
            'recommendations': []
        }
        
        # Calculate efficiency score (0-100)
        strategy = dump_metadata.get('strategy', '')
        threat_level = dump_metadata.get('threat_level', '')
        
        # Base score
        score = 50
        
        # Adjust based on strategy appropriateness
        if strategy == 'full_system' and threat_level == 'CRITICAL':
            score = 95
        elif strategy == 'targeted_kernel' and threat_level in ['CRITICAL', 'HIGH']:
            score = 90
        elif strategy == 'process_specific' and threat_level in ['MEDIUM', 'HIGH']:
            score = 85
        elif strategy == 'minimal_forensic' and threat_level == 'LOW':
            score = 80
        elif strategy == 'live_response' and 'botnet' in dump_metadata.get('threat_type', ''):
            score = 90
        else:
            score = 60
        
        analysis['efficiency_score'] = score
        
        # Generate recommendations
        if score < 80:
            analysis['recommendations'].append(
                f"Consider using a different strategy for {dump_metadata.get('threat_type')} threats"
            )
        
        if dump_metadata.get('dump_size_gb', 0) > 8:
            analysis['recommendations'].append(
                "Dump size exceeds 8GB - consider targeted approach for faster analysis"
            )
        
        if not dump_metadata.get('analysis_commands'):
            analysis['recommendations'].append(
                "No volatility analysis commands configured - add analysis workflow"
            )
        
        return analysis


if __name__ == "__main__":
    # Example usage
    integration = MemoryDumpIntegration()
    
    # Simulate threat detection from PreAnalyzer
    threat_info = {
        'threat_type': 'RANSOMWARE',
        'threat_level': 'CRITICAL',
        'risk_score': 85,
        'indicators': ['Ransomware keyword: ransomware', 'Shadow copy deletion'],
        'pid': 1234,
        'name': 'ransomware_test.py',
        'path': 'f:/MalwareAnalysis/ProcessManager/ransomware_test.py',
        'cmdline': 'python ransomware_test.py',
        'confidence': 0.95
    }
    
    # Process threat and create dump
    result = integration.process_threat_detection(threat_info)
    
    print("\n" + "="*80)
    print("MEMORY DUMP INTEGRATION RESULT")
    print("="*80)
    print(json.dumps(result, indent=2))
    
    # Analyze efficiency
    analyzer = DumpStrategyAnalyzer()
    efficiency = analyzer.analyze_dump_efficiency(result)
    
    print("\n" + "="*80)
    print("DUMP STRATEGY ANALYSIS")
    print("="*80)
    print(json.dumps(efficiency, indent=2))
    
    # Generate forensic report
    report_path = integration.generate_forensic_report()
    print(f"\nForensic report: {report_path}")
