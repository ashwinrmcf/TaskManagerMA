"""
Enhanced Memory Analysis - Beyond Volatility
Comprehensive malicious activity tracing from memory dumps
Includes: Behavioral analysis, pattern detection, threat correlation, and deep forensics
"""

import os
import json
import re
import hashlib
from pathlib import Path
from datetime import datetime
from collections import defaultdict
import logging

logging.basicConfig(level=logging.INFO, format='%(asctime)s - [%(levelname)s] - %(message)s')
logger = logging.getLogger(__name__)


class EnhancedMemoryAnalyzer:
    """
    Enhanced memory analysis beyond Volatility
    Traces complete malicious activity chain
    """
    
    def __init__(self, volatility_results_dir: str):
        """Initialize with volatility analysis results"""
        self.results_dir = Path(volatility_results_dir)
        self.analysis = {
            'timestamp': datetime.now().isoformat(),
            'behavioral_patterns': [],
            'threat_chain': [],
            'persistence_mechanisms': [],
            'network_indicators': [],
            'file_indicators': [],
            'registry_indicators': [],
            'process_tree': {},
            'injection_chains': [],
            'lateral_movement': [],
            'data_exfiltration': [],
            'privilege_escalation': [],
            'evasion_techniques': [],
            'c2_communication': [],
            'overall_threat_score': 0,
            'recommendations': []
        }
    
    def analyze_all(self) -> dict:
        """Run complete enhanced analysis"""
        logger.info("Starting enhanced memory analysis...")
        
        # Read all volatility outputs
        volatility_data = self._read_volatility_outputs()
        
        # Perform comprehensive analysis
        self._analyze_process_behavior(volatility_data)
        self._analyze_persistence(volatility_data)
        self._analyze_network_activity(volatility_data)
        self._analyze_file_activity(volatility_data)
        self._analyze_registry_activity(volatility_data)
        self._analyze_injection_techniques(volatility_data)
        self._analyze_privilege_escalation(volatility_data)
        self._analyze_evasion_techniques(volatility_data)
        self._analyze_c2_communication(volatility_data)
        self._build_threat_chain()
        self._calculate_threat_score()
        self._generate_recommendations()
        
        logger.info("Enhanced analysis complete")
        return self.analysis
    
    def _read_volatility_outputs(self) -> dict:
        """Read all volatility command outputs"""
        data = {}
        
        for txt_file in self.results_dir.glob("*.txt"):
            if txt_file.name == "ANALYSIS_REPORT.txt":
                continue
            
            try:
                with open(txt_file, 'r', encoding='utf-8', errors='ignore') as f:
                    content = f.read()
                    command_name = txt_file.stem
                    data[command_name] = content
                    logger.info(f"Read: {command_name}")
            except Exception as e:
                logger.warning(f"Failed to read {txt_file.name}: {e}")
        
        return data
    
    def _analyze_process_behavior(self, data: dict):
        """Analyze process behavior and relationships"""
        logger.info("Analyzing process behavior...")
        
        # Extract process information
        pslist_data = data.get('Process_List', '')
        pstree_data = data.get('Process_Tree', '')
        cmdline_data = data.get('Command_Line', '')
        
        # Detect suspicious processes
        suspicious_patterns = [
            r'cmd\.exe',
            r'powershell',
            r'wscript',
            r'cscript',
            r'rundll32',
            r'regsvcs',
            r'regasm',
            r'InstallUtil',
            r'mshta',
            r'certutil',
            r'bitsadmin',
            r'schtasks',
            r'tasklist',
            r'taskkill',
        ]
        
        for pattern in suspicious_patterns:
            if re.search(pattern, pslist_data, re.IGNORECASE):
                self.analysis['behavioral_patterns'].append({
                    'type': 'Suspicious Process Execution',
                    'pattern': pattern,
                    'severity': 'HIGH',
                    'description': f'Process matching pattern: {pattern}'
                })
        
        # Detect process injection
        if 'injected' in pslist_data.lower() or 'hollowprocesses' in pslist_data.lower():
            self.analysis['behavioral_patterns'].append({
                'type': 'Process Injection Detected',
                'severity': 'CRITICAL',
                'description': 'Evidence of process hollowing or code injection'
            })
        
        # Detect parent-child process anomalies
        if 'explorer.exe' in pslist_data and 'cmd.exe' in pslist_data:
            self.analysis['behavioral_patterns'].append({
                'type': 'Suspicious Parent-Child Relationship',
                'severity': 'HIGH',
                'description': 'explorer.exe spawning cmd.exe (unusual)'
            })
    
    def _analyze_persistence(self, data: dict):
        """Analyze persistence mechanisms"""
        logger.info("Analyzing persistence mechanisms...")
        
        registry_data = data.get('Registry_Keys', '')
        services_data = data.get('Services', '')
        scheduled_tasks_data = data.get('Scheduled_Tasks', '')
        
        # Check for autorun entries
        autorun_patterns = [
            r'Software\\Microsoft\\Windows\\CurrentVersion\\Run',
            r'Software\\Microsoft\\Windows\\CurrentVersion\\RunOnce',
            r'Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon',
        ]
        
        for pattern in autorun_patterns:
            if pattern in registry_data:
                self.analysis['persistence_mechanisms'].append({
                    'type': 'Registry Autorun',
                    'location': pattern,
                    'severity': 'HIGH',
                    'description': 'Persistence via registry autorun'
                })
        
        # Check for suspicious services
        if 'suspicious' in services_data.lower() or 'unknown' in services_data.lower():
            self.analysis['persistence_mechanisms'].append({
                'type': 'Suspicious Service',
                'severity': 'HIGH',
                'description': 'Suspicious or unknown service detected'
            })
        
        # Check for scheduled tasks
        if 'task' in scheduled_tasks_data.lower():
            self.analysis['persistence_mechanisms'].append({
                'type': 'Scheduled Task',
                'severity': 'MEDIUM',
                'description': 'Persistence via scheduled task'
            })
    
    def _analyze_network_activity(self, data: dict):
        """Analyze network communication patterns"""
        logger.info("Analyzing network activity...")
        
        netscan_data = data.get('Network_Connections', '')
        netstat_data = data.get('Network_Statistics', '')
        
        # Extract IP addresses
        ip_pattern = r'\b(?:\d{1,3}\.){3}\d{1,3}\b'
        ips = set(re.findall(ip_pattern, netscan_data))
        
        # Detect suspicious IPs
        suspicious_ip_ranges = [
            r'^10\.',
            r'^172\.(1[6-9]|2[0-9]|3[01])\.',
            r'^192\.168\.',
        ]
        
        for ip in ips:
            # Check if external IP
            is_internal = any(re.match(pattern, ip) for pattern in suspicious_ip_ranges)
            
            if not is_internal and ip not in ['127.0.0.1', '0.0.0.0']:
                self.analysis['network_indicators'].append({
                    'type': 'External Network Connection',
                    'ip': ip,
                    'severity': 'HIGH',
                    'description': f'Connection to external IP: {ip}'
                })
        
        # Detect suspicious ports
        suspicious_ports = [4444, 5555, 8888, 9999, 31337, 666, 1337]
        for port in suspicious_ports:
            if str(port) in netscan_data:
                self.analysis['network_indicators'].append({
                    'type': 'Suspicious Port',
                    'port': port,
                    'severity': 'HIGH',
                    'description': f'Connection on suspicious port: {port}'
                })
    
    def _analyze_file_activity(self, data: dict):
        """Analyze file system activity"""
        logger.info("Analyzing file activity...")
        
        filescan_data = data.get('File_Scanning', '')
        
        # Detect suspicious file patterns
        suspicious_file_patterns = [
            (r'\\Temp\\', 'Temporary directory execution'),
            (r'\\AppData\\Local\\Temp\\', 'Temp folder execution'),
            (r'\\Windows\\System32\\drivers\\etc\\', 'Hosts file modification'),
            (r'\.exe$', 'Executable file'),
            (r'\.dll$', 'Dynamic library'),
            (r'\.scr$', 'Screen saver (often malicious)'),
            (r'\.vbs$', 'VBScript'),
            (r'\.bat$', 'Batch script'),
            (r'\.ps1$', 'PowerShell script'),
        ]
        
        for pattern, description in suspicious_file_patterns:
            if re.search(pattern, filescan_data, re.IGNORECASE):
                self.analysis['file_indicators'].append({
                    'type': 'Suspicious File Pattern',
                    'pattern': pattern,
                    'severity': 'MEDIUM',
                    'description': description
                })
    
    def _analyze_registry_activity(self, data: dict):
        """Analyze registry modifications"""
        logger.info("Analyzing registry activity...")
        
        registry_data = data.get('Registry_Keys', '')
        
        # Detect registry modifications
        suspicious_registry_paths = [
            (r'Software\\Microsoft\\Windows\\CurrentVersion\\Policies', 'Policy modification'),
            (r'Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Shell Folders', 'Shell folder modification'),
            (r'Software\\Microsoft\\Windows NT\\CurrentVersion\\Image File Execution Options', 'IFEO modification'),
            (r'Software\\Classes\\', 'File association modification'),
        ]
        
        for path, description in suspicious_registry_paths:
            if path in registry_data:
                self.analysis['registry_indicators'].append({
                    'type': 'Registry Modification',
                    'path': path,
                    'severity': 'MEDIUM',
                    'description': description
                })
    
    def _analyze_injection_techniques(self, data: dict):
        """Analyze code injection techniques"""
        logger.info("Analyzing injection techniques...")
        
        ldrmodules_data = data.get('Injected_Code', '')
        malfind_data = data.get('Malware_Patterns', '')
        
        # Detect injection indicators
        if 'injected' in ldrmodules_data.lower():
            self.analysis['injection_chains'].append({
                'type': 'DLL Injection',
                'severity': 'CRITICAL',
                'description': 'Evidence of DLL injection detected'
            })
        
        if 'hollowprocesses' in malfind_data.lower():
            self.analysis['injection_chains'].append({
                'type': 'Process Hollowing',
                'severity': 'CRITICAL',
                'description': 'Process hollowing detected'
            })
        
        if 'VAD' in malfind_data:
            self.analysis['injection_chains'].append({
                'type': 'Suspicious VAD Entry',
                'severity': 'HIGH',
                'description': 'Suspicious Virtual Address Descriptor detected'
            })
    
    def _analyze_privilege_escalation(self, data: dict):
        """Analyze privilege escalation attempts"""
        logger.info("Analyzing privilege escalation...")
        
        privileges_data = data.get('Privileges', '')
        services_data = data.get('Services', '')
        
        # Detect privilege escalation indicators
        if 'SeDebugPrivilege' in privileges_data:
            self.analysis['privilege_escalation'].append({
                'type': 'SeDebugPrivilege Enabled',
                'severity': 'HIGH',
                'description': 'Process has SeDebugPrivilege (can debug other processes)'
            })
        
        if 'SeImpersonatePrivilege' in privileges_data:
            self.analysis['privilege_escalation'].append({
                'type': 'SeImpersonatePrivilege Enabled',
                'severity': 'HIGH',
                'description': 'Process has SeImpersonatePrivilege (can impersonate tokens)'
            })
        
        if 'SYSTEM' in services_data:
            self.analysis['privilege_escalation'].append({
                'type': 'SYSTEM Privilege Process',
                'severity': 'CRITICAL',
                'description': 'Process running with SYSTEM privileges'
            })
    
    def _analyze_evasion_techniques(self, data: dict):
        """Analyze evasion and anti-forensics techniques"""
        logger.info("Analyzing evasion techniques...")
        
        all_data = ' '.join(data.values())
        
        # Detect evasion techniques
        evasion_patterns = [
            (r'process hollowing', 'Process Hollowing'),
            (r'code injection', 'Code Injection'),
            (r'hook', 'API Hooking'),
            (r'rootkit', 'Rootkit'),
            (r'anti-debug', 'Anti-Debugging'),
            (r'anti-vm', 'Anti-VM Detection'),
            (r'anti-analysis', 'Anti-Analysis'),
        ]
        
        for pattern, technique in evasion_patterns:
            if re.search(pattern, all_data, re.IGNORECASE):
                self.analysis['evasion_techniques'].append({
                    'type': technique,
                    'severity': 'HIGH',
                    'description': f'Evasion technique detected: {technique}'
                })
    
    def _analyze_c2_communication(self, data: dict):
        """Analyze C2 communication patterns"""
        logger.info("Analyzing C2 communication...")
        
        netscan_data = data.get('Network_Connections', '')
        
        # Detect C2 patterns
        c2_patterns = [
            (r':(4444|5555|8888|9999|31337|666|1337)', 'Suspicious port'),
            (r'\.onion', 'Tor network'),
            (r'\.i2p', 'I2P network'),
            (r'dga', 'Domain Generation Algorithm'),
        ]
        
        for pattern, description in c2_patterns:
            if re.search(pattern, netscan_data, re.IGNORECASE):
                self.analysis['c2_communication'].append({
                    'type': 'C2 Indicator',
                    'pattern': pattern,
                    'severity': 'CRITICAL',
                    'description': description
                })
    
    def _build_threat_chain(self):
        """Build complete threat activity chain"""
        logger.info("Building threat chain...")
        
        # Correlate all indicators to build attack chain
        chain = []
        
        # Initial access
        if self.analysis['behavioral_patterns']:
            chain.append({
                'stage': 'Initial Access',
                'indicators': len(self.analysis['behavioral_patterns']),
                'severity': 'HIGH'
            })
        
        # Persistence
        if self.analysis['persistence_mechanisms']:
            chain.append({
                'stage': 'Persistence',
                'indicators': len(self.analysis['persistence_mechanisms']),
                'severity': 'HIGH'
            })
        
        # Privilege Escalation
        if self.analysis['privilege_escalation']:
            chain.append({
                'stage': 'Privilege Escalation',
                'indicators': len(self.analysis['privilege_escalation']),
                'severity': 'CRITICAL'
            })
        
        # Defense Evasion
        if self.analysis['evasion_techniques']:
            chain.append({
                'stage': 'Defense Evasion',
                'indicators': len(self.analysis['evasion_techniques']),
                'severity': 'HIGH'
            })
        
        # Command & Control
        if self.analysis['c2_communication']:
            chain.append({
                'stage': 'Command & Control',
                'indicators': len(self.analysis['c2_communication']),
                'severity': 'CRITICAL'
            })
        
        # Exfiltration
        if self.analysis['network_indicators']:
            chain.append({
                'stage': 'Exfiltration',
                'indicators': len(self.analysis['network_indicators']),
                'severity': 'CRITICAL'
            })
        
        self.analysis['threat_chain'] = chain
    
    def _calculate_threat_score(self):
        """Calculate overall threat score"""
        score = 0
        
        # Count indicators by severity
        critical_count = 0
        high_count = 0
        medium_count = 0
        
        for category in ['behavioral_patterns', 'persistence_mechanisms', 'privilege_escalation', 
                        'evasion_techniques', 'c2_communication', 'injection_chains']:
            for item in self.analysis[category]:
                if item.get('severity') == 'CRITICAL':
                    critical_count += 1
                elif item.get('severity') == 'HIGH':
                    high_count += 1
                elif item.get('severity') == 'MEDIUM':
                    medium_count += 1
        
        # Calculate score (0-100)
        score = min(100, (critical_count * 30) + (high_count * 15) + (medium_count * 5))
        self.analysis['overall_threat_score'] = score
    
    def _generate_recommendations(self):
        """Generate remediation recommendations"""
        logger.info("Generating recommendations...")
        
        recommendations = []
        
        if self.analysis['overall_threat_score'] >= 80:
            recommendations.append('CRITICAL: Immediate system isolation required')
            recommendations.append('Disconnect from network immediately')
            recommendations.append('Preserve evidence for forensic analysis')
        
        if self.analysis['persistence_mechanisms']:
            recommendations.append('Remove all persistence mechanisms')
            recommendations.append('Clean registry autorun entries')
            recommendations.append('Disable suspicious services')
        
        if self.analysis['privilege_escalation']:
            recommendations.append('Audit and restrict privilege escalation vectors')
            recommendations.append('Review user account privileges')
            recommendations.append('Implement privilege access management')
        
        if self.analysis['c2_communication']:
            recommendations.append('Block identified C2 IPs at firewall')
            recommendations.append('Implement DNS filtering')
            recommendations.append('Monitor for data exfiltration')
        
        if self.analysis['injection_chains']:
            recommendations.append('Scan for injected processes')
            recommendations.append('Terminate malicious processes')
            recommendations.append('Restore from clean backup')
        
        self.analysis['recommendations'] = recommendations
    
    def save_report(self, output_file: str = None) -> str:
        """Save enhanced analysis report"""
        if output_file is None:
            output_file = self.results_dir / 'ENHANCED_ANALYSIS.json'
        
        with open(output_file, 'w', encoding='utf-8') as f:
            json.dump(self.analysis, f, indent=2)
        
        logger.info(f"Report saved to: {output_file}")
        return str(output_file)
    
    def generate_text_report(self) -> str:
        """Generate human-readable report"""
        report = f"""
================================================================================
                    ENHANCED MEMORY ANALYSIS REPORT
================================================================================

THREAT ASSESSMENT
-----------------
Overall Threat Score: {self.analysis['overall_threat_score']}/100

THREAT CHAIN (MITRE ATT&CK Framework)
-------------------------------------
"""
        
        for stage in self.analysis['threat_chain']:
            report += f"\n{stage['stage']}: {stage['indicators']} indicators [{stage['severity']}]"
        
        report += f"""

BEHAVIORAL PATTERNS ({len(self.analysis['behavioral_patterns'])} detected)
------------------------"""
        for pattern in self.analysis['behavioral_patterns'][:10]:
            report += f"\n  [{pattern['severity']}] {pattern['type']}: {pattern.get('description', '')}"
        
        report += f"""

PERSISTENCE MECHANISMS ({len(self.analysis['persistence_mechanisms'])} detected)
----------------------------"""
        for mechanism in self.analysis['persistence_mechanisms'][:10]:
            report += f"\n  [{mechanism['severity']}] {mechanism['type']}: {mechanism.get('description', '')}"
        
        report += f"""

PRIVILEGE ESCALATION ({len(self.analysis['privilege_escalation'])} detected)
-------------------------------"""
        for esc in self.analysis['privilege_escalation'][:10]:
            report += f"\n  [{esc['severity']}] {esc['type']}: {esc.get('description', '')}"
        
        report += f"""

CODE INJECTION ({len(self.analysis['injection_chains'])} detected)
-------------------"""
        for injection in self.analysis['injection_chains'][:10]:
            report += f"\n  [{injection['severity']}] {injection['type']}: {injection.get('description', '')}"
        
        report += f"""

C2 COMMUNICATION ({len(self.analysis['c2_communication'])} detected)
---------------------"""
        for c2 in self.analysis['c2_communication'][:10]:
            report += f"\n  [{c2['severity']}] {c2['type']}: {c2.get('description', '')}"
        
        report += f"""

EVASION TECHNIQUES ({len(self.analysis['evasion_techniques'])} detected)
--------------------------"""
        for evasion in self.analysis['evasion_techniques'][:10]:
            report += f"\n  [{evasion['severity']}] {evasion['type']}: {evasion.get('description', '')}"
        
        report += """

RECOMMENDATIONS
---------------"""
        for rec in self.analysis['recommendations']:
            report += f"\n  â€¢ {rec}"
        
        report += """

================================================================================
                            END OF REPORT
================================================================================
"""
        
        return report


if __name__ == "__main__":
    # Example usage
    import sys
    
    if len(sys.argv) < 2:
        print("Usage: python enhanced_memory_analysis.py <volatility_results_dir>")
        sys.exit(1)
    
    results_dir = sys.argv[1]
    analyzer = EnhancedMemoryAnalyzer(results_dir)
    analysis = analyzer.analyze_all()
    
    # Save reports
    analyzer.save_report()
    
    # Print text report
    text_report = analyzer.generate_text_report()
    print(text_report)
    
    # Save text report
    with open(Path(results_dir) / 'ENHANCED_ANALYSIS.txt', 'w') as f:
        f.write(text_report)
