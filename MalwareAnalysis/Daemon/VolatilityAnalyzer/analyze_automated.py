"""
Automated Volatility Analyzer - Non-Interactive Mode
Automatically analyzes all available dumps without user prompts
"""

import sys
import os
from pathlib import Path
from datetime import datetime
import json

# Add parent directory to path
sys.path.insert(0, str(Path(__file__).parent))

from volatility_analyzer import VolatilityAnalyzer

def find_available_dumps():
    """Find all available memory dumps"""
    dumps_dir = Path("F:/MalwareAnalysis/MemoryDumps")
    
    if not dumps_dir.exists():
        print(f"[ERROR] Dumps directory not found: {dumps_dir}")
        return []
    
    dumps = []
    
    # Search for all .raw and .dmp files
    for dump_file in dumps_dir.rglob("*.raw"):
        dumps.append(dump_file)
    
    for dump_file in dumps_dir.rglob("*.dmp"):
        dumps.append(dump_file)
    
    return sorted(dumps, key=lambda x: x.stat().st_mtime, reverse=True)

def analyze_dump_automated(dump_file, threat_type="RANSOMWARE", threat_level="CRITICAL"):
    """Analyze a dump without user interaction"""
    
    threat_name = dump_file.stem
    
    print(f"\n{'='*80}")
    print(f"Analyzing: {dump_file.name}")
    print(f"Threat Type: {threat_type}")
    print(f"Threat Level: {threat_level}")
    print(f"{'='*80}\n")
    
    try:
        analyzer = VolatilityAnalyzer()
        
        results = analyzer.analyze_dump(
            dump_file=str(dump_file),
            threat_type=threat_type,
            threat_level=threat_level,
            threat_name=threat_name,
            profile=None
        )
        
        # Display results
        print(f"Status:                 {'SUCCESS' if results.get('commands_executed', 0) > 0 else 'FAILED'}")
        print(f"Commands Executed:      {results.get('commands_executed', 0)}")
        print(f"Commands Failed:        {results.get('commands_failed', 0)}")
        
        success_rate = (results.get('commands_executed', 0) / max(1, results.get('commands_executed', 0) + results.get('commands_failed', 0))) * 100
        print(f"Success Rate:           {success_rate:.1f}%")
        
        print(f"IOCs Found:             {len(results.get('iocs', []))}")
        print(f"Risk Indicators:        {len(results.get('risk_indicators', []))}")
        print(f"Analysis Files:         {len(results.get('analysis_files', []))}")
        print(f"Output Directory:       {results.get('analysis_dir')}")
        
        # Display top IOCs
        if results.get('iocs'):
            print(f"\nTop IOCs:")
            for ioc in results['iocs'][:5]:
                print(f"  • {ioc}")
            if len(results['iocs']) > 5:
                print(f"  ... and {len(results['iocs']) - 5} more")
        
        # Display risk indicators
        if results.get('risk_indicators'):
            print(f"\nRisk Indicators:")
            for risk in list(set(results['risk_indicators']))[:5]:
                print(f"  ⚠️  {risk}")
        
        return results
        
    except Exception as e:
        print(f"[ERROR] Analysis failed: {e}")
        import traceback
        traceback.print_exc()
        return None

def main():
    """Main entry point - automated analysis"""
    
    print(f"\n{'='*80}")
    print("AUTOMATED VOLATILITY ANALYZER - MILITARY-GRADE FORENSICS")
    print(f"{'='*80}\n")
    
    # Find available dumps
    dumps = find_available_dumps()
    
    if not dumps:
        print("[ERROR] No memory dumps found!")
        print(f"Expected location: F:/MalwareAnalysis/MemoryDumps/")
        return
    
    print(f"[INFO] Found {len(dumps)} memory dump(s)")
    
    # Summary tracking
    all_results = []
    total_iocs = 0
    total_risks = 0
    
    # Analyze each dump
    for i, dump_file in enumerate(dumps, 1):
        print(f"\n[{i}/{len(dumps)}] Processing dump...")
        
        results = analyze_dump_automated(
            dump_file=dump_file,
            threat_type="RANSOMWARE",
            threat_level="CRITICAL"
        )
        
        if results:
            all_results.append(results)
            total_iocs += len(results.get('iocs', []))
            total_risks += len(results.get('risk_indicators', []))
    
    # Print summary
    print(f"\n{'='*80}")
    print("AUTOMATED ANALYSIS SUMMARY")
    print(f"{'='*80}\n")
    
    print(f"Total Dumps Analyzed:   {len(all_results)}")
    print(f"Total IOCs Found:       {total_iocs}")
    print(f"Total Risk Indicators:  {total_risks}")
    print(f"Total Analysis Files:   {sum(len(r.get('analysis_files', [])) for r in all_results)}")
    
    # Save summary report
    summary = {
        'timestamp': datetime.now().isoformat(),
        'total_dumps': len(all_results),
        'total_iocs': total_iocs,
        'total_risks': total_risks,
        'analyses': [
            {
                'threat_name': r.get('threat_name'),
                'threat_type': r.get('threat_type'),
                'threat_level': r.get('threat_level'),
                'commands_executed': r.get('commands_executed'),
                'commands_failed': r.get('commands_failed'),
                'iocs_found': len(r.get('iocs', [])),
                'risks_found': len(r.get('risk_indicators', [])),
                'analysis_dir': r.get('analysis_dir')
            }
            for r in all_results
        ]
    }
    
    summary_file = Path("F:/MalwareAnalysis/MemoryDumps/AnalysisResults") / f"automated_summary_{datetime.now().strftime('%Y%m%d_%H%M%S')}.json"
    summary_file.parent.mkdir(parents=True, exist_ok=True)
    
    with open(summary_file, 'w', encoding='utf-8') as f:
        json.dump(summary, f, indent=2)
    
    print(f"\nSummary saved to: {summary_file}")
    print(f"\n{'='*80}")
    print("AUTOMATED ANALYSIS COMPLETE")
    print(f"{'='*80}\n")

if __name__ == "__main__":
    try:
        main()
    except KeyboardInterrupt:
        print("\n\n[CANCELLED] Analysis cancelled by user")
    except Exception as e:
        print(f"\n[ERROR] Unexpected error: {e}")
        import traceback
        traceback.print_exc()
