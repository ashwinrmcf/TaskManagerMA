"""
Military-Grade Volatility Analysis Engine
Comprehensive memory forensics with threat-specific command execution
Extracts maximum intelligence from memory dumps
"""

import os
import sys
import json
import subprocess
import logging
from pathlib import Path
from datetime import datetime
from enum import Enum
import re
import time

# Setup logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - [%(levelname)s] - %(message)s'
)
logger = logging.getLogger(__name__)


class ThreatCategory(Enum):
    """Threat categories for targeted analysis"""
    RANSOMWARE = "ransomware"
    TROJAN = "trojan"
    SPYWARE = "spyware"
    ROOTKIT = "rootkit"
    BOTNET = "botnet"
    WORM = "worm"
    UNKNOWN = "unknown"


class VolatilityAnalyzer:
    """
    Military-grade volatility analysis engine
    Executes comprehensive forensic analysis based on threat type
    """
    
    def __init__(self, volatility_path: str = None, output_dir: str = None):
        """Initialize volatility analyzer"""
        self.volatility_path = volatility_path or self._find_volatility()
        self.output_dir = Path(output_dir or "F:/MalwareAnalysis/MemoryDumps/AnalysisResults")
        self.output_dir.mkdir(parents=True, exist_ok=True)
        
        logger.info(f"Volatility Analyzer initialized")
        logger.info(f"Volatility path: {self.volatility_path}")
        logger.info(f"Output directory: {self.output_dir}")
    
    def _find_volatility(self) -> str:
        """Find volatility installation"""
        # Try python -m volatility3 first (most reliable)
        try:
            result = subprocess.run(
                "python -m volatility3 --help",
                shell=True,
                capture_output=True,
                timeout=5
            )
            if result.returncode == 0:
                logger.info("Found volatility: python -m volatility3")
                return "python -m volatility3"
        except:
            pass
        
        # Try direct volatility3 command
        possible_paths = [
            "volatility3",
            "vol",
            "C:\\Tools\\volatility3\\vol.py",
            "C:\\Program Files\\volatility3\\vol.py"
        ]
        
        for path in possible_paths:
            try:
                result = subprocess.run(
                    f"{path} --version",
                    shell=True,
                    capture_output=True,
                    timeout=5
                )
                if result.returncode == 0:
                    logger.info(f"Found volatility at: {path}")
                    return path
            except:
                pass
        
        logger.warning("Volatility not found, using default: python -m volatility3")
        return "python -m volatility3"
    
    def analyze_dump(self, dump_file: str, threat_type: str, threat_level: str, 
                     threat_name: str = "unknown", profile: str = None) -> dict:
        """
        Execute comprehensive volatility analysis on memory dump
        
        Args:
            dump_file: Path to memory dump file
            threat_type: Type of threat (RANSOMWARE, TROJAN, etc.)
            threat_level: Threat severity (CRITICAL, HIGH, MEDIUM, LOW)
            threat_name: Name of threat for reporting
            profile: Volatility profile (auto-detected if None)
        
        Returns:
            Dictionary with analysis results
        """
        
        logger.info(f"Starting military-grade analysis for {threat_name} ({threat_type})")
        
        dump_path = Path(dump_file)
        if not dump_path.exists():
            logger.error(f"Dump file not found: {dump_file}")
            return {'error': 'Dump file not found', 'status': 'FAILED'}
        
        # Create analysis directory for this threat
        analysis_dir = self.output_dir / f"{threat_name}_{datetime.now().strftime('%Y%m%d_%H%M%S')}"
        analysis_dir.mkdir(parents=True, exist_ok=True)
        
        # Get threat-specific commands
        threat_cat = self._map_threat_category(threat_type)
        commands = self._get_threat_specific_commands(threat_cat, threat_level)
        
        logger.info(f"Executing {len(commands)} volatility commands for {threat_name}")
        
        analysis_results = {
            'threat_name': threat_name,
            'threat_type': threat_type,
            'threat_level': threat_level,
            'dump_file': str(dump_path),
            'analysis_dir': str(analysis_dir),
            'timestamp': datetime.now().isoformat(),
            'commands_executed': 0,
            'commands_failed': 0,
            'analysis_files': [],
            'findings': {},
            'iocs': [],
            'risk_indicators': []
        }
        
        # Execute each command and capture results
        for i, cmd_info in enumerate(commands, 1):
            cmd_name = cmd_info['name']
            cmd = cmd_info['command']
            
            logger.info(f"[{i}/{len(commands)}] Executing: {cmd_name}")
            print(f"[{i}/{len(commands)}] {cmd_name}...", end=" ", flush=True)
            
            try:
                result = self._execute_volatility_command(
                    cmd, dump_path, analysis_dir, cmd_name, profile
                )
                
                if result['success']:
                    analysis_results['commands_executed'] += 1
                    analysis_results['analysis_files'].append(result['output_file'])
                    
                    # Parse findings from output
                    findings = self._parse_command_output(cmd_name, result['output_file'])
                    if findings:
                        analysis_results['findings'][cmd_name] = findings
                        analysis_results['iocs'].extend(findings.get('iocs', []))
                        analysis_results['risk_indicators'].extend(findings.get('risks', []))
                    
                    print(f"{Fore.GREEN}✓{Style.RESET_ALL}")
                else:
                    analysis_results['commands_failed'] += 1
                    print(f"{Fore.RED}✗{Style.RESET_ALL}")
                    
            except Exception as e:
                analysis_results['commands_failed'] += 1
                logger.error(f"Command failed: {cmd_name} - {e}")
                print(f"{Fore.RED}✗{Style.RESET_ALL}")
        
        # Generate comprehensive report
        report = self._generate_analysis_report(analysis_results)
        analysis_results['report'] = report
        
        # Save analysis results
        self._save_analysis_results(analysis_results)
        
        logger.info(f"Analysis complete: {analysis_results['commands_executed']} succeeded, {analysis_results['commands_failed']} failed")
        
        return analysis_results
    
    def _map_threat_category(self, threat_type: str) -> ThreatCategory:
        """Map threat type string to category"""
        threat_type_upper = threat_type.upper()
        
        mapping = {
            'RANSOMWARE': ThreatCategory.RANSOMWARE,
            'TROJAN': ThreatCategory.TROJAN,
            'SPYWARE': ThreatCategory.SPYWARE,
            'ROOTKIT': ThreatCategory.ROOTKIT,
            'BOTNET': ThreatCategory.BOTNET,
            'WORM': ThreatCategory.WORM,
        }
        
        return mapping.get(threat_type_upper, ThreatCategory.UNKNOWN)
    
    def _get_threat_specific_commands(self, threat_cat: ThreatCategory, threat_level: str) -> list:
        """
        Get threat-specific volatility commands
        Military-grade: Execute maximum commands based on threat type and level
        """
        
        # CORE COMMANDS - Always execute (System baseline)
        core_commands = [
            {'name': 'System Info', 'command': 'windows.info.Info'},
            {'name': 'Process List', 'command': 'windows.pslist.PsList'},
            {'name': 'Process Tree', 'command': 'windows.pstree.PsTree'},
            {'name': 'Process Scanning', 'command': 'windows.psxview.PsXView'},
            {'name': 'DLL Listing', 'command': 'windows.dlllist.DllList'},
            {'name': 'Loaded Modules', 'command': 'windows.modules.Modules'},
            {'name': 'Module Scanning', 'command': 'windows.modscan.ModScan'},
            {'name': 'Handles', 'command': 'windows.handles.Handles'},
            {'name': 'Privileges', 'command': 'windows.getsids.GetSIDs'},
        ]
        
        # RANSOMWARE-SPECIFIC COMMANDS
        ransomware_commands = [
            {'name': 'File Scanning', 'command': 'windows.filescan.FileScan'},
            {'name': 'Registry Hives', 'command': 'windows.registry.hivelist.HiveList'},
            {'name': 'Registry Keys', 'command': 'windows.registry.printkey.PrintKey'},
            {'name': 'MFT Analysis', 'command': 'windows.mftscan.MFTScan'},
            {'name': 'Master Boot Record', 'command': 'windows.mbrscan.MBRScan'},
            {'name': 'Malware Patterns', 'command': 'windows.malfind.Malfind'},
            {'name': 'Injected Code', 'command': 'windows.ldrmodules.LdrModules'},
            {'name': 'Unloaded Modules', 'command': 'windows.unloadedmodules.UnloadedModules'},
            {'name': 'Memory Map', 'command': 'windows.memmap.Memmap'},
            {'name': 'Yara Scanning', 'command': 'yarascan.YaraScan'},
        ]
        
        # ROOTKIT-SPECIFIC COMMANDS
        rootkit_commands = [
            {'name': 'Kernel Modules', 'command': 'windows.modules.Modules'},
            {'name': 'SSDT Hooks', 'command': 'windows.ssdt.SSDT'},
            {'name': 'Driver Analysis', 'command': 'windows.driverirp.DriverIrp'},
            {'name': 'Kernel Callbacks', 'command': 'windows.callbacks.Callbacks'},
            {'name': 'Loaded Modules', 'command': 'windows.ldrmodules.LdrModules'},
            {'name': 'Unloaded Modules', 'command': 'windows.unloadedmodules.UnloadedModules'},
            {'name': 'Driver Scan', 'command': 'windows.driverscan.DriverScan'},
            {'name': 'Module Scan', 'command': 'windows.modscan.ModScan'},
            {'name': 'Process Scan', 'command': 'windows.psscan.PsScan'},
            {'name': 'Thread Scan', 'command': 'windows.thrdscan.ThrdScan'},
        ]
        
        # BOTNET/C2-SPECIFIC COMMANDS
        botnet_commands = [
            {'name': 'Network Connections', 'command': 'windows.netscan.NetScan'},
            {'name': 'Network Statistics', 'command': 'windows.netstat.NetStat'},
            {'name': 'Process List', 'command': 'windows.pslist.PsList'},
            {'name': 'Handles', 'command': 'windows.handles.Handles'},
            {'name': 'DLL List', 'command': 'windows.dlllist.DllList'},
            {'name': 'Modules', 'command': 'windows.modules.Modules'},
            {'name': 'Environment Variables', 'command': 'windows.envars.Envars'},
            {'name': 'Command Line', 'command': 'windows.cmdline.CmdLine'},
            {'name': 'Threads', 'command': 'windows.threads.Threads'},
            {'name': 'Memory Map', 'command': 'windows.memmap.Memmap'},
        ]
        
        # TROJAN/SPYWARE-SPECIFIC COMMANDS
        trojan_commands = [
            {'name': 'Process Injection', 'command': 'windows.ldrmodules.LdrModules'},
            {'name': 'Loaded Modules', 'command': 'windows.modules.Modules'},
            {'name': 'Malware Patterns', 'command': 'windows.malfind.Malfind'},
            {'name': 'Threads', 'command': 'windows.threads.Threads'},
            {'name': 'Mutants', 'command': 'windows.mutantscan.MutantScan'},
            {'name': 'Handles', 'command': 'windows.handles.Handles'},
            {'name': 'Environment Variables', 'command': 'windows.envars.Envars'},
            {'name': 'Command Line', 'command': 'windows.cmdline.CmdLine'},
            {'name': 'Timers', 'command': 'windows.timers.Timers'},
            {'name': 'Privileges', 'command': 'windows.getsids.GetSIDs'},
        ]
        
        # PERSISTENCE-SPECIFIC COMMANDS (All threats)
        persistence_commands = [
            {'name': 'Registry Hives', 'command': 'windows.registry.hivelist.HiveList'},
            {'name': 'Registry Keys', 'command': 'windows.registry.printkey.PrintKey'},
            {'name': 'Scheduled Tasks', 'command': 'windows.registry.scheduled_tasks.ScheduledTasks'},
            {'name': 'Services', 'command': 'windows.svclist.SvcList'},
            {'name': 'Service Scan', 'command': 'windows.svcscan.SvcScan'},
            {'name': 'Drivers', 'command': 'windows.driverscan.DriverScan'},
            {'name': 'Amcache', 'command': 'windows.registry.amcache.Amcache'},
            {'name': 'Shimcache Memory', 'command': 'windows.shimcachemem.ShimcacheMem'},
        ]
        
        # FORENSIC ARTIFACTS (All threats)
        forensic_commands = [
            {'name': 'Shimcache', 'command': 'windows.shimcachemem.ShimcacheMem'},
            {'name': 'User Assist', 'command': 'windows.registry.userassist.UserAssist'},
            {'name': 'MRU Lists', 'command': 'windows.registry.printkey.PrintKey'},
            {'name': 'Environment Variables', 'command': 'windows.envars.Envars'},
            {'name': 'Command Line', 'command': 'windows.cmdline.CmdLine'},
            {'name': 'Amcache', 'command': 'windows.registry.amcache.Amcache'},
            {'name': 'Certificates', 'command': 'windows.registry.certificates.Certificates'},
        ]
        
        # MEMORY ANALYSIS (All threats)
        memory_commands = [
            {'name': 'Memory Map', 'command': 'windows.memmap.Memmap'},
            {'name': 'Virtual Address Descriptor', 'command': 'windows.vadinfo.VadInfo'},
            {'name': 'VAD Walk', 'command': 'windows.vadwalk.VadWalk'},
            {'name': 'Pool Scanner', 'command': 'windows.poolscanner.PoolScanner'},
            {'name': 'Statistics', 'command': 'windows.statistics.Statistics'},
        ]
        
        # Build command list based on threat type and level
        commands = core_commands.copy()
        
        # Add threat-specific commands
        if threat_cat == ThreatCategory.RANSOMWARE:
            commands.extend(ransomware_commands)
        elif threat_cat == ThreatCategory.ROOTKIT:
            commands.extend(rootkit_commands)
        elif threat_cat == ThreatCategory.BOTNET:
            commands.extend(botnet_commands)
        elif threat_cat in [ThreatCategory.TROJAN, ThreatCategory.SPYWARE]:
            commands.extend(trojan_commands)
        
        # Add persistence and forensic commands for HIGH and CRITICAL threats
        if threat_level in ['CRITICAL', 'HIGH']:
            commands.extend(persistence_commands)
            commands.extend(forensic_commands)
            commands.extend(memory_commands)
        
        # Add memory analysis for MEDIUM threats
        if threat_level in ['CRITICAL', 'HIGH', 'MEDIUM']:
            if memory_commands not in commands:
                commands.extend(memory_commands)
        
        return commands
    
    def _execute_volatility_command(self, command: str, dump_path: Path, 
                                   analysis_dir: Path, cmd_name: str, 
                                   profile: str = None) -> dict:
        """Execute a single volatility command"""
        
        try:
            # Build command
            output_file = analysis_dir / f"{cmd_name.replace(' ', '_')}.txt"
            
            # Use vol.exe directly (most reliable)
            vol_exe = "C:\\Users\\windows\\AppData\\Local\\Programs\\Python\\Python313\\Scripts\\vol.exe"
            
            # Construct volatility command - vol.exe syntax: vol.exe -f <dump> <command>
            vol_cmd = f"\"{vol_exe}\" -f \"{dump_path}\" {command}"
            
            # Execute command with proper error handling
            try:
                result = subprocess.run(
                    vol_cmd,
                    shell=True,
                    capture_output=True,
                    timeout=300,  # 5 minute timeout
                    text=True
                )
                
                # Save output even if command failed
                with open(output_file, 'w', encoding='utf-8') as f:
                    f.write(f"Command: {command}\n")
                    f.write(f"Executed: {datetime.now().isoformat()}\n")
                    f.write("=" * 80 + "\n\n")
                    f.write(result.stdout if result.stdout else "(No output)")
                    if result.stderr:
                        f.write("\n\nSTDERR:\n")
                        f.write(result.stderr)
                
                # Check if output contains actual results (not just errors)
                has_output = bool(result.stdout and len(result.stdout.strip()) > 100)
                
                return {
                    'success': result.returncode == 0 or has_output,
                    'output_file': str(output_file),
                    'stdout': result.stdout,
                    'stderr': result.stderr,
                    'returncode': result.returncode
                }
            
            except subprocess.TimeoutExpired:
                logger.error(f"Command timeout: {cmd_name}")
                return {'success': False, 'error': 'Command timeout'}
            
        except Exception as e:
            logger.error(f"Command execution failed: {cmd_name} - {e}")
            return {'success': False, 'error': str(e)}
    
    def _parse_command_output(self, cmd_name: str, output_file: str) -> dict:
        """Parse command output for IOCs and risk indicators"""
        
        findings = {
            'iocs': [],
            'risks': [],
            'summary': ''
        }
        
        try:
            with open(output_file, 'r', encoding='utf-8', errors='ignore') as f:
                content = f.read()
            
            # Extract IOCs based on command type
            if 'netscan' in cmd_name.lower() or 'connection' in cmd_name.lower():
                # Extract IPs and ports
                ips = re.findall(r'\b(?:\d{1,3}\.){3}\d{1,3}\b', content)
                ports = re.findall(r':(\d{4,5})\s', content)
                findings['iocs'].extend([f"IP: {ip}" for ip in set(ips)])
                findings['iocs'].extend([f"Port: {port}" for port in set(ports)])
                findings['risks'].append("Network activity detected")
            
            elif 'malfind' in cmd_name.lower():
                if 'VAD' in content or 'Protect' in content:
                    findings['risks'].append("Suspicious memory protection detected")
                    findings['iocs'].append("Potential code injection")
            
            elif 'injected' in cmd_name.lower():
                if content.strip() and len(content) > 100:
                    findings['risks'].append("Process injection detected")
                    findings['iocs'].append("Injected code found")
            
            elif 'ssdt' in cmd_name.lower() or 'hook' in cmd_name.lower():
                if 'hooked' in content.lower() or 'modified' in content.lower():
                    findings['risks'].append("Kernel hook detected - Possible rootkit")
                    findings['iocs'].append("SSDT/IDT modification")
            
            elif 'registry' in cmd_name.lower() or 'printkey' in cmd_name.lower():
                if 'Run' in content or 'Startup' in content:
                    findings['risks'].append("Persistence mechanism detected")
                    findings['iocs'].append("Registry persistence")
            
            elif 'services' in cmd_name.lower():
                if 'suspicious' in content.lower() or 'unknown' in content.lower():
                    findings['risks'].append("Suspicious service detected")
                    findings['iocs'].append("Service persistence")
            
            elif 'strings' in cmd_name.lower():
                # Look for suspicious strings
                suspicious_patterns = [
                    r'http[s]?://[^\s]+',  # URLs
                    r'cmd\.exe|powershell',  # Command execution
                    r'WinExec|CreateProcess',  # API calls
                ]
                for pattern in suspicious_patterns:
                    matches = re.findall(pattern, content, re.IGNORECASE)
                    findings['iocs'].extend(matches)
            
            findings['summary'] = f"Analyzed {len(content)} bytes of output"
            
        except Exception as e:
            logger.warning(f"Failed to parse output: {cmd_name} - {e}")
        
        return findings
    
    def _generate_analysis_report(self, analysis_results: dict) -> str:
        """Generate comprehensive analysis report"""
        
        report = f"""
================================================================================
                    MILITARY-GRADE VOLATILITY ANALYSIS REPORT
================================================================================

THREAT INFORMATION
------------------
Threat Name:        {analysis_results['threat_name']}
Threat Type:        {analysis_results['threat_type']}
Threat Level:       {analysis_results['threat_level']}
Analysis Time:      {analysis_results['timestamp']}

ANALYSIS EXECUTION
------------------
Commands Executed:  {analysis_results['commands_executed']}
Commands Failed:    {analysis_results['commands_failed']}
Total Commands:     {analysis_results['commands_executed'] + analysis_results['commands_failed']}
Success Rate:       {(analysis_results['commands_executed'] / max(1, analysis_results['commands_executed'] + analysis_results['commands_failed'])) * 100:.1f}%

FINDINGS SUMMARY
----------------
Total IOCs Found:   {len(analysis_results['iocs'])}
Risk Indicators:    {len(analysis_results['risk_indicators'])}
Analysis Files:     {len(analysis_results['analysis_files'])}

"""
        
        if analysis_results['iocs']:
            report += "INDICATORS OF COMPROMISE (IOCs)\n"
            report += "-" * 80 + "\n"
            for ioc in analysis_results['iocs'][:20]:  # Top 20
                report += f"  • {ioc}\n"
            if len(analysis_results['iocs']) > 20:
                report += f"  ... and {len(analysis_results['iocs']) - 20} more\n"
            report += "\n"
        
        if analysis_results['risk_indicators']:
            report += "RISK INDICATORS\n"
            report += "-" * 80 + "\n"
            for risk in set(analysis_results['risk_indicators']):
                report += f"  ⚠️  {risk}\n"
            report += "\n"
        
        report += f"""
ANALYSIS FILES GENERATED
------------------------
{chr(10).join([f"  • {Path(f).name}" for f in analysis_results['analysis_files'][:10]])}
{f"  ... and {len(analysis_results['analysis_files']) - 10} more files" if len(analysis_results['analysis_files']) > 10 else ""}

OUTPUT DIRECTORY
----------------
{analysis_results['analysis_dir']}

================================================================================
                            END OF REPORT
================================================================================
"""
        
        return report
    
    def _save_analysis_results(self, analysis_results: dict):
        """Save analysis results to files"""
        
        analysis_dir = Path(analysis_results['analysis_dir'])
        
        # Save JSON results
        json_file = analysis_dir / "analysis_results.json"
        with open(json_file, 'w', encoding='utf-8') as f:
            # Remove file paths for cleaner JSON
            results_copy = analysis_results.copy()
            results_copy['analysis_files'] = [Path(f).name for f in results_copy['analysis_files']]
            json.dump(results_copy, f, indent=2)
        
        # Save text report
        report_file = analysis_dir / "ANALYSIS_REPORT.txt"
        with open(report_file, 'w', encoding='utf-8') as f:
            f.write(analysis_results['report'])
        
        logger.info(f"Analysis results saved to {analysis_dir}")


# Import colorama for output
from colorama import Fore, Style


if __name__ == "__main__":
    # Example usage
    analyzer = VolatilityAnalyzer()
    
    # Example dump file (would be real in production)
    dump_file = "F:/MalwareAnalysis/MemoryDumps/TargetedDumps/example_dump.raw"
    
    if Path(dump_file).exists():
        results = analyzer.analyze_dump(
            dump_file=dump_file,
            threat_type="RANSOMWARE",
            threat_level="CRITICAL",
            threat_name="ransomware_test"
        )
        
        print("\n" + "="*80)
        print("ANALYSIS COMPLETE")
        print("="*80)
        print(f"Commands executed: {results['commands_executed']}")
        print(f"IOCs found: {len(results['iocs'])}")
        print(f"Risk indicators: {len(results['risk_indicators'])}")
    else:
        print(f"Dump file not found: {dump_file}")
