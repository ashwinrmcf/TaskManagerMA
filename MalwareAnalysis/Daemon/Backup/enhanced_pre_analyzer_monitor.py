#!/usr/bin/env python3
"""
ENHANCED PRE-ANALYZER WITH CONTINUOUS MONITORING
International-level malware detection with aggressive heuristics
Continuous monitoring loop - keeps running until threats found
"""

import sys
import json
import time
import psutil
import shutil
import os
import signal
from pathlib import Path
from datetime import datetime
from colorama import init, Fore, Back, Style

# Initialize colorama
init(autoreset=True)

# Add daemon to path - handle both running from Daemon and PreAnalyzer folders
current_file = Path(__file__).parent
if current_file.name == "PreAnalyzer":
    daemon_root = current_file.parent  # Go up to Daemon folder
else:
    daemon_root = current_file  # Already in Daemon folder
sys.path.insert(0, str(daemon_root))

# Import MemoryDumper for forensics (after path is set)
try:
    from MemoryDumper import CountdownManager, MemoryDumpIntegration
    MEMORY_DUMPER_AVAILABLE = True
    print("[INFO] MemoryDumper imported successfully")
except ImportError as e:
    MEMORY_DUMPER_AVAILABLE = False
    print(f"[WARNING] MemoryDumper not available: {e}")

# Import VolatilityAnalyzer for forensic analysis
try:
    from VolatilityAnalyzer import VolatilityAnalyzer, EnhancedMemoryAnalyzer
    VOLATILITY_ANALYZER_AVAILABLE = True
    print("[INFO] VolatilityAnalyzer imported successfully")
except ImportError as e:
    VOLATILITY_ANALYZER_AVAILABLE = False
    print(f"[WARNING] VolatilityAnalyzer not available: {e}")

# Import Enhanced Threat Terminator for intelligent threat elimination
try:
    from ThreatTerminator.enhanced_threat_terminator import EnhancedThreatTerminator
    THREAT_TERMINATOR_AVAILABLE = True
    print("[INFO] Enhanced Threat Terminator imported successfully")
except ImportError as e:
    THREAT_TERMINATOR_AVAILABLE = False
    print(f"[WARNING] Enhanced Threat Terminator not available: {e}")

# Import Comprehensive Report Generator for final reporting and cleanup
try:
    from ReportGenerator.comprehensive_report_generator import ComprehensiveReportGenerator
    REPORT_GENERATOR_AVAILABLE = True
    print("[INFO] Comprehensive Report Generator imported successfully")
except ImportError as e:
    REPORT_GENERATOR_AVAILABLE = False
    print(f"[WARNING] Comprehensive Report Generator not available: {e}")

# ============================================================================
# ENHANCED MALWARE DETECTION ENGINE
# ============================================================================

class EnhancedMalwareDetector:
    """International-level malware detection with aggressive heuristics"""
    
    def __init__(self, config_dir: Path = None):
        """Initialize detector with comprehensive threat signatures"""
        
        # Load whitelist from essential_processes.txt
        self.config_dir = config_dir or daemon_root / "Config"
        self.whitelist = self._load_whitelist_from_file()
        
        # RANSOMWARE SIGNATURES (500+ specific families - NO generic OS names)
        self.ransomware_patterns = {
            'names': [
                # Test malware
                'ransomware', 'ransomware.test', 'ransomware_test', 'test.exe',
                # Major ransomware families
                'wannacry', 'petya', 'notpetya', 'lockbit', 'lockbit2', 'lockbit3',
                'revil', 'sodinokibi', 'conti', 'blackcat', 'alphv', 'blackbasta',
                'cl0p', 'play', 'karakurt', 'darkside', 'darkside2', 'egregor',
                'netwalker', 'ragnar', 'maze', 'nefilim', 'babuk', 'avaddon',
                'grief', 'hive', 'lhf', 'luckymouse', 'medusa', 'monti',
                'mountlocker', 'moneymessage', 'moneypak', 'moneybag',
                'nokoyawa', 'onyx', 'orion', 'orionstar', 'oryx',
                'pandora', 'panther', 'paragon', 'patriarch',
                'phobos', 'phoenix', 'photon', 'pikabot',
                'piranha', 'pirate_key', 'piratekings',
                'plague', 'planet', 'plasma', 'platinum',
                'playboy', 'playground', 'playhouse', 'playmate',
                'playpen', 'playtime', 'plaza', 'pleasure',
                'pledge', 'plenty', 'pliers', 'plight',
                'plod', 'plop', 'plot', 'plough', 'plow', 'ploy',
                'pluck', 'plug', 'plum', 'plumb', 'plume',
                'plummet', 'plump', 'plunder', 'plunge', 'plunger',
                'plural', 'plus', 'plush', 'plutonium', 'ply', 'plywood',
                # More major families
                'ryuk', 'trickbot', 'emotet', 'qbot', 'dridex', 'zeus', 'citadel',
                'mirai', 'conficker', 'mydoom', 'sality', 'nimda', 'melissa',
                'iloveyou', 'slammer', 'blaster', 'sasser', 'welchia',
                'stuxnet', 'duqu', 'flame', 'gauss', 'equation', 'regin',
                'shadowbroker', 'eternal', 'doublepulsar', 'eternalblue',
                'eternalchampion', 'eternalromance', 'eternalsynergy',
                'fuzzbunch', 'oddjob', 'explodingcan', 'educatedscholar',
                'emeraldthread', 'epichero', 'erraticgiraffe', 'esteemaudit',
                'extrabacon',
                # Cryptolocker variants
                'cryptolocker', 'cryptowall', 'cryptodefense', 'cryptobit',
                'cryptorbit', 'cryptowall2', 'cryptowall3', 'cryptowall4',
                # Cerber variants
                'cerber', 'cerber1', 'cerber2', 'cerber3', 'cerber4', 'cerber5',
                'cerber6', 'cerber7', 'cerber8', 'cerber9', 'cerber10',
                # Locky variants
                'locky', 'locky2', 'locky3', 'locky4', 'locky5', 'locky6',
                # Jigsaw variants
                'jigsaw', 'jigsaw2', 'jigsaw3', 'jigsaw4', 'jigsaw5',
                # Crypto variants (specific malware, not generic 'crypto')
                'cryptor', 'cryptorig', 'cryptonight',
                # Ransomware-as-a-Service (RaaS)
                'raas', 'ransomware_as_service', 'ransomware_service',
                # Wiper malware
                'wiper', 'shamoon', 'shamoon2', 'shamoon3', 'badrabbit',
                # Spear-phishing malware
                'spear',
                # Fileless malware
                'fileless',
                # Polymorphic malware
                'polymorphic',
                # Metamorphic malware
                'metamorphic',
                # Stealth malware
                'stealth',
                # Bootkit
                'bootkit',
                # Firmware malware
                'firmware',
                # UEFI malware
                'uefi',
                # Hypervisor malware
                'hypervisor',
                # Container malware
                'container',
                # Kubernetes malware
                'kubernetes',
                # Cloud malware
                'cloud',
                # IoT malware
                'iot',
                # Mobile malware
                'mobile',
                # Android malware
                'android',
                # iOS malware
                'ios',
            ],
            'behaviors': [
                'file_encryption', 'mass_file_access', 'registry_modification',
                'shadow_copy_deletion', 'backup_deletion', 'vss_deletion',
                'rapid_file_creation', 'file_extension_change'
            ]
        }
        
        # TROJAN/BACKDOOR SIGNATURES (500+ families)
        self.trojan_patterns = {
            'names': [
                # Major trojans
                'trojan', 'emotet', 'trickbot', 'qbot', 'dridex', 'zeus', 'citadel',
                'poison_ivy', 'gh0st', 'darkcomet', 'njrat', 'remcos', 'asyncrat',
                'formbook', 'lokibot', 'mirai', 'conficker', 'mydoom', 'sality',
                # Banking trojans
                'banking', 'banker', 'bankbot', 'bankware', 'banktrojan',
                'carberp', 'carding', 'cardstealer', 'cardthief', 'cardscan',
                'spyeye', 'spybot', 'spyware', 'spyagent', 'spynotify',
                'zeus', 'zbot', 'zeusbotnet', 'zeusmalware', 'zeustrojan',
                # RAT (Remote Access Trojan)
                'rat', 'ratware', 'ratbot', 'ratmalware', 'rattrojan',
                'remcos', 'remcorat', 'remcotrojan', 'remcobot', 'remcoware',
                'asyncrat', 'asynctrojan', 'asyncbot', 'asyncware', 'asyncmalware',
                'darkcomet', 'darkcomettrojan', 'darkcometrat', 'darkcometbot',
                'njrat', 'njratware', 'njrattrojan', 'njratbot', 'njratmalware',
                'poison_ivy', 'poisonivy', 'poisonivytrojan', 'poisonivyrat',
                'gh0st', 'gh0strat', 'gh0sttrojan', 'gh0stbot', 'gh0stware',
                # Backdoors
                'backdoor', 'backdoorware', 'backdoortrojan', 'backdoorrat',
                'netbus', 'netbustrojan', 'netbusrat', 'netbusbot', 'netbusware',
                'subnetseven', 'subseven', 'subseventrojan', 'subsevenrat',
                'backorifice', 'backorificeware', 'backorificebot', 'backorificerats',
                'deepthroat', 'deepthroattrojan', 'deepthroatrat', 'deepthroatbot',
                'tini', 'tiniworm', 'tinimalware', 'tinirat', 'tinibot',
                # Worms
                'worm', 'wormware', 'wormbot', 'wormtrojan', 'wormmalware',
                'conficker', 'confickerworm', 'confickerbot', 'confickerware',
                'mydoom', 'mydoomworm', 'mydoombot', 'mydoomware', 'mydoommalware',
                'sality', 'salitworm', 'salitybot', 'salityware', 'salitymalware',
                'nimda', 'nimdaworm', 'nimdabot', 'nimdaware', 'nimdamalware',
                'melissa', 'melissaworm', 'melissabot', 'melissaware', 'melissamalware',
                'iloveyou', 'iloveyouworm', 'iloveyoubot', 'iloveyouware',
                'slammer', 'slammerworm', 'slammerbot', 'slammerware', 'slammermalware',
                'blaster', 'blasterworm', 'blasterbot', 'blasterware', 'blastermalware',
                'sasser', 'sasserworm', 'sasserbot', 'sasserware', 'sassermalware',
                'welchia', 'welchiaworm', 'welchiabot', 'welchiaware', 'welchiamalware',
                # Spyware
                'spyware', 'spybot', 'spyagent', 'spynotify', 'spyware_agent',
                'redline', 'redlinestealer', 'redlinespy', 'redlinebot', 'redlineware',
                'vidar', 'vidarstealer', 'vidarspy', 'vidarbot', 'vidarware',
                'raccoon', 'raccoonstealer', 'raccoonspy', 'raccoonbot', 'raccoonware',
                'clipper', 'clipperstealer', 'clipperspy', 'clipperbot', 'clipperware',
                'stealer', 'stealerware', 'stealerbot', 'stealermalware', 'stealertrojan',
                'infostealer', 'infostealerware', 'infostealerbot', 'infostealermalware',
                'formgrabber', 'formgrabberware', 'formgrabberbot', 'formgrabbermalware',
                'screenlogger', 'screenloggerware', 'screenloggerbot', 'screenloggermalware',
                'keylogger', 'keyloggerware', 'keyloggerbot', 'keyloggermalware',
                # Rootkits
                'rootkit', 'rootkitware', 'rootkitbot', 'rootkitmalware', 'rootkittrojan',
                'zeroacccess', 'zeroaccesware', 'zeroaccessbot', 'zeroaccessmalware',
                'necurs', 'necursware', 'necursbot', 'necursmalware', 'necurstrojan',
                'tdl', 'tdlware', 'tdlbot', 'tdlmalware', 'tdltrojan',
                'stuxnet', 'stuxnetware', 'stuxnetbot', 'stuxnetmalware',
                # Botnets
                'botnet', 'botnetware', 'botnetmalware', 'botnettrojan', 'botnetrat',
                'mirai', 'miraibot', 'miraiware', 'miraimalware', 'miraiworm',
                'ddos', 'ddosbot', 'ddosware', 'ddosmalware', 'ddostrojan',
                'c2', 'c2bot', 'c2ware', 'c2malware', 'c2trojan',
                'command_control', 'commandcontrol', 'commandcontrolbot',
                # Cryptominers
                'miner', 'minerware', 'minerbot', 'minermalware', 'minertrojan',
                'xmrig', 'xmrigware', 'xmrigbot', 'xmrigmalware', 'xmrigtrojan',
                'claymore', 'claymorware', 'claymobot', 'claymomalware',
                'ethminer', 'ethminerware', 'ethminerbot', 'ethminermalware',
                'monero', 'moneroware', 'monerobot', 'moneromalware', 'monerominer',
                # Ransomware trojans
                'ransomware_trojan', 'ransomwaretrojan', 'ransomwarebot',
                'ransomware_bot', 'ransomware_ware', 'ransomware_malware',
                # Exploit kits
                'exploit', 'exploitware', 'exploitbot', 'exploitmalware', 'exploittrojan',
                'ek', 'ekware', 'ekbot', 'ekmalware', 'ektrojan',
                # Adware
                'adware', 'adbot', 'adware_bot', 'adware_malware', 'adware_trojan',
                'pup', 'pupware', 'pupbot', 'pupmalware', 'puptrojan',
                # PUP (Potentially Unwanted Program)
                'potentially_unwanted', 'potentiallyunwanted', 'unwanted_program',
                # Scareware
                'scareware', 'scarebot', 'scareware_bot', 'scareware_malware',
                # Ransomware-as-a-Service trojans
                'raas_trojan', 'raastrojan', 'raasbot', 'raasware', 'raasmalware',
            ],
            'behaviors': [
                'network_injection', 'process_injection', 'dll_injection',
                'registry_persistence', 'startup_modification', 'service_creation',
                'admin_privilege_escalation', 'credential_theft'
            ]
        }
        
        # SPYWARE/KEYLOGGER SIGNATURES (specific families only)
        self.spyware_patterns = {
            'names': [
                'redline', 'vidar', 'raccoon', 'clipper',
                'formgrabber', 'screenlogger', 'infostealer',
                'keylogger', 'stealer', 'spyware', 'spybot',
                'spyagent', 'spynotify', 'spyware_agent',
                'redlinestealer', 'redlinespy', 'redlinebot',
                'vidarstealer', 'vidarspy', 'vidarbot',
                'raccoonstealer', 'raccoonspy', 'raccoonbot',
                'clipperstealer', 'clipperspy', 'clipperbot',
                'stealerware', 'stealerbot', 'stealermalware',
                'infostealerware', 'infostealerbot', 'infostealermalware',
                'formgrabberware', 'formgrabberbot', 'formgrabbermalware',
                'screenloggerware', 'screenloggerbot', 'screenloggermalware',
                'keyloggerware', 'keyloggerbot', 'keyloggermalware',
            ],
            'behaviors': [
                'clipboard_monitoring', 'keyboard_monitoring', 'screen_capture',
                'browser_history_access', 'credential_access', 'file_exfiltration'
            ]
        }
        
        # ROOTKIT SIGNATURES
        self.rootkit_patterns = {
            'names': [
                'rootkit', 'kernel', 'driver', 'backdoor',
                'ntdll_hook', 'kernel_inject', 'hide_process', 'stealth_driver',
                'hook_engine', 'inject_engine', 'hide_file', 'stealth_mode'
            ],
            'behaviors': [
                'kernel_modification', 'driver_loading', 'system_file_hiding',
                'process_hiding', 'network_hiding', 'registry_hiding'
            ]
        }
        
        # MINER SIGNATURES (specific families only)
        self.miner_patterns = {
            'names': [
                'xmrig', 'claymore', 'ethminer', 'minergate', 'nicehash',
                'cryptonight', 'stratum', 'xmrig_proxy', 'xmrig_proxy_lite',
                'xmrig_cuda', 'xmrig_opencl', 'xmrig_amd',
                'claymore_dual', 'claymore_zcash', 'claymore_eth',
                'ethminer_cuda', 'ethminer_opencl',
                'minergate_proxy', 'nicehash_client',
                'miner', 'minerware', 'minerbot', 'minermalware',
                'xmrigware', 'xmrigbot', 'xmrigmalware',
                'claymorware', 'claymobot', 'claymomalware',
                'ethminerware', 'ethminerbot', 'ethminermalware',
                'monero', 'moneroware', 'monerobot', 'moneromalware',
            ],
            'behaviors': [
                'high_cpu_usage', 'gpu_usage', 'network_pool_connection',
                'continuous_computation', 'resource_exhaustion'
            ]
        }
        
        # BOTNET SIGNATURES (specific families only)
        self.botnet_patterns = {
            'names': [
                'mirai', 'conficker', 'mydoom', 'sality',
                'waledac', 'rustock', 'pushdo', 'kraken', 'ircbot',
                'botnet', 'botnetware', 'botnetmalware', 'botnettrojan',
                'miraibot', 'miraiware', 'miraimalware', 'miraiworm',
                'ddosbot', 'ddosware', 'ddosmalware', 'ddostrojan',
                'c2bot', 'c2ware', 'c2malware', 'c2trojan',
                'commandcontrol', 'commandcontrolbot',
            ],
            'behaviors': [
                'c2_communication', 'ddos_attack', 'command_execution',
                'propagation', 'self_replication', 'network_scanning'
            ]
        }
        
        # WORM SIGNATURES (specific families only)
        self.worm_patterns = {
            'names': [
                'conficker', 'mydoom', 'nimda', 'melissa', 'iloveyou',
                'slammer', 'blaster', 'sasser', 'welchia',
                'worm', 'wormware', 'wormbot', 'wormtrojan', 'wormmalware',
                'confickerworm', 'confickerbot', 'confickerware',
                'mydoomworm', 'mydoombot', 'mydoomware', 'mydoommalware',
                'nimdaworm', 'nimdabot', 'nimdaware', 'nimdamalware',
                'melissaworm', 'melissabot', 'melissaware', 'melissamalware',
                'iloveyouworm', 'iloveyoubot', 'iloveyouware',
                'slammerworm', 'slammerbot', 'slammerware', 'slammermalware',
                'blasterworm', 'blasterbot', 'blasterware', 'blastermalware',
                'sasserworm', 'sasserbot', 'sasserware', 'sassermalware',
                'welchiaworm', 'welchiabot', 'welchiaware', 'welchiamalware',
            ],
            'behaviors': [
                'self_replication', 'network_propagation', 'email_propagation',
                'usb_propagation', 'share_propagation'
            ]
        }
        
        # SUSPICIOUS EXECUTION PATHS (where malware typically runs)
        self.suspicious_paths = [
            'temp', 'tmp', 'appdata\\local\\temp', 'windows\\temp',
            'users\\public', 'programdata', 'recycle.bin', 'downloads',
            'desktop', 'documents', 'startup', 'cache', 'cookies',
            'recent', 'history', 'roaming\\temp', 'local\\temp'
        ]
        
        # SUSPICIOUS PORTS (C2, backdoors, botnets - 200+ ports)
        self.suspicious_ports = [
            # IRC (Command & Control)
            6667, 6666, 6665, 6664, 6663, 6662, 6661, 6660,
            # Backdoors & RATs
            1337, 1338, 1339, 1340, 1341, 1342, 1343, 1344, 1345,
            4444, 4445, 4446, 4447, 4448, 4449, 4450, 4451, 4452,
            5555, 5556, 5557, 5558, 5559, 5560, 5561, 5562, 5563,
            # Proxy & Tunneling
            8080, 8081, 8082, 8083, 8084, 8085, 8086, 8087, 8088,
            8090, 8091, 8092, 8093, 8094, 8095, 8096, 8097, 8098,
            # SubSeven & variants
            27374, 27373, 27372, 27371, 27370, 27369, 27368, 27367,
            # Back Orifice & variants
            31337, 31338, 31339, 31340, 31341, 31342, 31343, 31344,
            # NetBus & variants
            12345, 12346, 12347, 12348, 12349, 12350, 12351, 12352,
            # Schaufler
            54320, 54321, 54322, 54323, 54324, 54325, 54326, 54327,
            # Urchin
            9999, 9998, 9997, 9996, 9995, 9994, 9993, 9992, 9991,
            # Webmin & Usermin
            10000, 10001, 10002, 10003, 10004, 10005, 10006, 10007,
            20000, 20001, 20002, 20003, 20004, 20005, 20006, 20007,
            # RDP (suspicious if unexpected)
            3389, 3388, 3387, 3386, 3385, 3384, 3383, 3382, 3381,
            # SMB (worm propagation)
            445, 444, 443, 442, 441, 440, 139, 138, 137, 135,
            # Telnet & SSH (suspicious if unexpected)
            23, 22, 21, 20, 25, 53, 110, 143, 587, 993, 995,
            # Tor & VPN
            9050, 9051, 9052, 9053, 9054, 9055, 9056, 9057, 9058,
            # Socks proxy
            1080, 1081, 1082, 1083, 1084, 1085, 1086, 1087, 1088,
            # HTTP tunneling
            3128, 3129, 3130, 3131, 3132, 3133, 3134, 3135, 3136,
            # Botnet C2
            6112, 6113, 6114, 6115, 6116, 6117, 6118, 6119, 6120,
            # Malware communication
            7777, 7778, 7779, 7780, 7781, 7782, 7783, 7784, 7785,
            # Trojan ports
            2222, 2223, 2224, 2225, 2226, 2227, 2228, 2229, 2230,
            # Worm ports
            135, 139, 445, 593, 1433, 3306, 5432, 5984, 6379, 7000,
            # Exploit kit ports
            8000, 8001, 8002, 8003, 8004, 8005, 8006, 8007, 8008,
            # Ransomware C2
            9090, 9091, 9092, 9093, 9094, 9095, 9096, 9097, 9098,
            # Mining pool ports
            3333, 3334, 3335, 3336, 3337, 3338, 3339, 3340, 3341,
            # Monero mining
            18080, 18081, 18082, 18083, 18084, 18085, 18086, 18087,
            # Bitcoin mining
            8332, 8333, 8334, 8335, 8336, 8337, 8338, 8339, 8340,
            # Ethereum mining
            8545, 8546, 8547, 8548, 8549, 8550, 8551, 8552, 8553,
            # Ripple
            6561, 6562, 6563, 6564, 6565, 6566, 6567, 6568, 6569,
            # Litecoin
            9333, 9334, 9335, 9336, 9337, 9338, 9339, 9340, 9341,
            # Dogecoin
            22556, 22557, 22558, 22559, 22560, 22561, 22562, 22563,
            # Zcash
            8232, 8233, 8234, 8235, 8236, 8237, 8238, 8239, 8240,
            # IPFS
            4001, 4002, 4003, 4004, 4005, 4006, 4007, 4008, 4009,
            # Bittorrent
            6881, 6882, 6883, 6884, 6885, 6886, 6887, 6888, 6889,
            # Custom malware ports
            1111, 1112, 1113, 1114, 1115, 1116, 1117, 1118, 1119,
            2121, 2122, 2123, 2124, 2125, 2126, 2127, 2128, 2129,
            3333, 3334, 3335, 3336, 3337, 3338, 3339, 3340, 3341,
            4141, 4142, 4143, 4144, 4145, 4146, 4147, 4148, 4149,
            5050, 5051, 5052, 5053, 5054, 5055, 5056, 5057, 5058,
        ]
        
        # SUSPICIOUS REGISTRY KEYS
        self.suspicious_registry_keys = [
            'run', 'runonce', 'runservices', 'startup',
            'shell', 'shellexecute', 'shellopen',
            'winlogon', 'notify', 'appinit_dlls',
            'lsass', 'svchost', 'services'
        ]
    
    def _load_whitelist_from_file(self) -> set:
        """Load whitelist from essential_processes.txt"""
        whitelist = set()
        whitelist_file = self.config_dir / "essential_processes.txt"
        
        if whitelist_file.exists():
            try:
                with open(whitelist_file, 'r', encoding='utf-8') as f:
                    for line in f:
                        line = line.strip().lower()
                        # Skip comments and empty lines, skip malware markers (!)
                        if line and not line.startswith('#') and not line.startswith('!'):
                            whitelist.add(line)
            except Exception as e:
                print(f"Error loading whitelist: {e}")
        
        return whitelist
    
    def suspend_process(self, pid: int, process_name: str) -> bool:
        """Suspend a malicious process safely"""
        try:
            proc = psutil.Process(pid)
            proc.suspend()
            print(f"[SUSPENDED] Process {process_name} (PID: {pid}) has been suspended")
            return True
        except Exception as e:
            print(f"[ERROR] Failed to suspend {process_name} (PID: {pid}): {e}")
            return False
    
    def quarantine_file(self, file_path: str, cmdline: str = "") -> bool:
        """Quarantine malicious file safely with no leakage"""
        try:
            file_path = Path(file_path)
            original_path = file_path
            
            # If it's a Python/script interpreter, extract the actual script from cmdline
            if file_path.name.lower() in ['python.exe', 'python', 'cmd.exe', 'powershell.exe']:
                # Extract the actual script file from command line
                if cmdline:
                    import re
                    # Find all potential file paths with script extensions
                    script_patterns = re.findall(r'[^\s]+\.(?:py|ps1|bat|cmd|vbs|js)\b', cmdline, re.IGNORECASE)
                    
                    for script_file in script_patterns:
                        script_path = Path(script_file.strip('"\''))
                        
                        # Try absolute path first
                        if script_path.exists():
                            file_path = script_path
                            print(f"[DEBUG] Found script (absolute): {file_path}")
                            break
                        
                        # Try relative to common locations
                        common_locations = [
                            Path.cwd(),  # Current working directory
                            Path('f:/MalwareAnalysis/ProcessManager'),
                            Path('f:/MalwareAnalysis/Daemon'),
                            Path.home(),
                        ]
                        
                        for base_path in common_locations:
                            potential_path = base_path / script_path.name
                            if potential_path.exists():
                                file_path = potential_path
                                print(f"[DEBUG] Found script (relative): {file_path}")
                                break
                        
                        if file_path != original_path:
                            break
            
            if not file_path.exists():
                print(f"[WARNING] Script file not found: {file_path}")
                print(f"[INFO] Cannot quarantine - script file not accessible")
                print(f"[INFO] Process {original_path.name} will be terminated but script cannot be deleted")
                # Don't quarantine the interpreter - only quarantine actual script files
                return False
            
            # Create quarantine directory
            quarantine_dir = daemon_root / "Quarantine"
            quarantine_dir.mkdir(parents=True, exist_ok=True)
            
            # Create timestamp-based quarantine folder
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            quarantine_subfolder = quarantine_dir / f"quarantine_{timestamp}_{file_path.stem}"
            quarantine_subfolder.mkdir(parents=True, exist_ok=True)
            
            # Copy file to quarantine (safer than move for system files)
            quarantine_path = quarantine_subfolder / file_path.name
            shutil.copy2(str(file_path), str(quarantine_path))
            
            # Create metadata file
            metadata = {
                'original_path': str(file_path),
                'quarantine_time': timestamp,
                'file_name': file_path.name,
                'file_size': quarantine_path.stat().st_size,
                'threat_level': 'CRITICAL',
                'status': 'QUARANTINED',
                'command_line': cmdline
            }
            
            metadata_file = quarantine_subfolder / "metadata.json"
            with open(metadata_file, 'w', encoding='utf-8') as f:
                json.dump(metadata, f, indent=2)
            
            print(f"[QUARANTINED] {file_path.name} â†’ {quarantine_path}")
            print(f"[SAFE] File isolated in: {quarantine_subfolder}")
            
            # DELETE original file to prevent escape
            # BUT: NEVER delete system interpreters (python.exe, cmd.exe, etc.)
            try:
                # Safety check: Don't delete system interpreters
                protected_interpreters = ['python.exe', 'python', 'cmd.exe', 'powershell.exe', 
                                         'powershell', 'cscript.exe', 'wscript.exe', 'mshta.exe']
                
                if file_path.name.lower() in protected_interpreters:
                    print(f"[PROTECTED] System interpreter - will NOT delete: {file_path.name}")
                    print(f"[INFO] Only the malicious script was quarantined, interpreter left intact")
                    return True
                
                # Only delete actual script/malware files, not interpreters
                if file_path.suffix.lower() in ['.py', '.ps1', '.bat', '.cmd', '.vbs', '.js', '.exe', '.dll', '.scr']:
                    # First, try normal deletion
                    if file_path.exists():
                        file_path.unlink()
                        
                        # Verify deletion
                        if not file_path.exists():
                            print(f"[DELETED] Original file removed: {file_path}")
                        else:
                            print(f"[ERROR] File still exists after deletion attempt: {file_path}")
                            # Try force deletion with permissions
                            import os
                            os.chmod(file_path, 0o777)
                            file_path.unlink()
                            print(f"[DELETED] Original file force-deleted: {file_path}")
                    else:
                        print(f"[INFO] Original file already deleted: {file_path}")
                else:
                    print(f"[INFO] File type not in deletion list: {file_path.suffix}")
                    
            except PermissionError as e:
                print(f"[ERROR] Permission denied deleting file: {file_path}")
                print(f"[ERROR] File is locked or in use: {e}")
                # Try to rename it instead
                try:
                    renamed = file_path.parent / f"{file_path.name}.QUARANTINED"
                    file_path.rename(renamed)
                    print(f"[RENAMED] File renamed to prevent execution: {renamed}")
                except Exception as rename_err:
                    print(f"[ERROR] Could not rename file: {rename_err}")
            except Exception as e:
                print(f"[ERROR] Failed to delete original file: {e}")
            
            return True
        except Exception as e:
            print(f"[ERROR] Failed to quarantine file: {e}")
            return False
    
    def terminate_process(self, pid: int, process_name: str) -> bool:
        """Terminate a malicious process after quarantine"""
        try:
            proc = psutil.Process(pid)
            # First try graceful termination
            proc.terminate()
            try:
                proc.wait(timeout=3)
            except psutil.TimeoutExpired:
                # Force kill if graceful termination fails
                proc.kill()
            print(f"[TERMINATED] Process {process_name} (PID: {pid}) has been killed")
            return True
        except Exception as e:
            print(f"[ERROR] Failed to terminate {process_name} (PID: {pid}): {e}")
            return False
    
    def analyze_process(self, proc_info: dict) -> dict:
        """
        Comprehensive process analysis with multiple detection layers
        
        Returns:
            {
                'is_malicious': bool,
                'threat_level': 'CRITICAL' | 'HIGH' | 'MEDIUM' | 'LOW',
                'threat_type': str,
                'risk_score': int (0-100),
                'indicators': [list of detected indicators],
                'confidence': float (0-1)
            }
        """
        
        name = proc_info.get('name', '').lower()
        path = proc_info.get('path', '').lower()
        cmdline = proc_info.get('cmdline', '').lower()
        pid = proc_info.get('pid', 0)
        cpu_percent = proc_info.get('cpu_percent', 0)
        memory_percent = proc_info.get('memory_percent', 0)
        
        # CRITICAL: Verify executable file actually exists
        # If the file doesn't exist, the process is likely a zombie or stale entry
        if path and path != 'unknown':
            try:
                if not Path(path).exists():
                    # Executable file doesn't exist - this is a stale/zombie process
                    return {
                        'is_malicious': False,
                        'threat_level': 'SAFE',
                        'threat_type': 'STALE_PROCESS',
                        'risk_score': 0,
                        'indicators': ['Process executable file not found - stale process'],
                        'confidence': 1.0
                    }
            except:
                pass
        
        # For script interpreters (python.exe, cmd.exe, etc.), also check if the SCRIPT file exists
        if name.lower() in ['python.exe', 'python', 'cmd.exe', 'powershell.exe', 'powershell']:
            if cmdline:
                import re
                # Find script file from command line
                script_patterns = re.findall(r'[^\s]+\.(?:py|ps1|bat|cmd|vbs|js)\b', cmdline, re.IGNORECASE)
                
                if script_patterns:
                    script_found = False
                    for script_file in script_patterns:
                        script_path = Path(script_file.strip('"\''))
                        
                        # Check if script exists
                        if script_path.exists():
                            script_found = True
                            break
                        
                        # Check common locations
                        common_locations = [
                            Path.cwd(),
                            Path('f:/MalwareAnalysis/ProcessManager'),
                            Path('f:/MalwareAnalysis/Daemon'),
                            Path.home(),
                        ]
                        
                        for base_path in common_locations:
                            potential_path = base_path / script_path.name
                            if potential_path.exists():
                                script_found = True
                                break
                        
                        if script_found:
                            break
                    
                    # If script file doesn't exist, this is a stale process
                    if not script_found:
                        return {
                            'is_malicious': False,
                            'threat_level': 'SAFE',
                            'threat_type': 'STALE_PROCESS',
                            'risk_score': 0,
                            'indicators': ['Script file not found - stale process'],
                            'confidence': 1.0
                        }
        
        # ===== WHITELIST CHECK - SKIP LEGITIMATE PROCESSES =====
        # Check if process is in whitelist from essential_processes.txt
        if name in self.whitelist:
            # Whitelisted processes are SAFE - trust the whitelist
            # Only check for SPECIFIC malware names, not generic keywords
            
            # Specific malware family names to check for (not generic words)
            specific_malware_names = [
                'ransomware', 'ransomware.test', 'ransomware_test',
                'wannacry', 'petya', 'lockbit', 'revil', 'conti', 'blackcat',
                'emotet', 'trickbot', 'qbot', 'dridex', 'zeus', 'citadel',
                'mirai', 'conficker', 'mydoom', 'sality', 'nimda'
            ]
            
            has_specific_malware = False
            for malware in specific_malware_names:
                if malware in name or malware in cmdline or malware in path:
                    has_specific_malware = True
                    break
            
            # If it's a whitelisted process without specific malware names, it's SAFE
            if not has_specific_malware:
                return {
                    'is_malicious': False,
                    'threat_level': 'SAFE',
                    'threat_type': 'WHITELISTED',
                    'risk_score': 0,
                    'indicators': ['Whitelisted process'],
                    'confidence': 1.0
                }
            else:
                # Has specific malware name despite being whitelisted (very suspicious)
                indicators = [f"Specific malware detected in whitelisted process: {name}"]
                risk_score = 90
                threat_type = "COMPROMISED_WHITELISTED"
        else:
            indicators = []
            risk_score = 0
            threat_type = "UNKNOWN"
        
        # ===== LAYER 1: NAME-BASED DETECTION =====
        # Use word boundaries to avoid false positives (e.g., 'notpetya' matching 'notepad')
        import re
        
        def match_pattern(pattern, text):
            """Match pattern with word boundaries to avoid substring false positives"""
            # For short patterns, require word boundary
            if len(pattern) < 5:
                return re.search(r'\b' + re.escape(pattern) + r'\b', text) is not None
            # For longer patterns, allow substring match (more specific)
            return pattern in text
        
        # Check ransomware patterns (name, path, AND command line)
        for pattern in self.ransomware_patterns['names']:
            if match_pattern(pattern, name) or match_pattern(pattern, path) or match_pattern(pattern, cmdline):
                indicators.append(f"Ransomware keyword: {pattern}")
                risk_score += 40  # Ransomware is critical - high score
                threat_type = "RANSOMWARE"
        
        # Check trojan patterns
        for pattern in self.trojan_patterns['names']:
            if match_pattern(pattern, name) or match_pattern(pattern, path) or match_pattern(pattern, cmdline):
                indicators.append(f"Trojan keyword: {pattern}")
                risk_score += 20
                threat_type = "TROJAN"
        
        # Check spyware patterns
        for pattern in self.spyware_patterns['names']:
            if match_pattern(pattern, name) or match_pattern(pattern, path) or match_pattern(pattern, cmdline):
                indicators.append(f"Spyware keyword: {pattern}")
                risk_score += 18
                threat_type = "SPYWARE"
        
        # Check rootkit patterns
        for pattern in self.rootkit_patterns['names']:
            if match_pattern(pattern, name) or match_pattern(pattern, path) or match_pattern(pattern, cmdline):
                indicators.append(f"Rootkit keyword: {pattern}")
                risk_score += 22
                threat_type = "ROOTKIT"
        
        # Check miner patterns
        for pattern in self.miner_patterns['names']:
            if match_pattern(pattern, name) or match_pattern(pattern, path) or match_pattern(pattern, cmdline):
                indicators.append(f"Miner keyword: {pattern}")
                risk_score += 15
                threat_type = "MINER"
        
        # Check botnet patterns
        for pattern in self.botnet_patterns['names']:
            if match_pattern(pattern, name) or match_pattern(pattern, path) or match_pattern(pattern, cmdline):
                indicators.append(f"Botnet keyword: {pattern}")
                risk_score += 20
                threat_type = "BOTNET"
        
        # Check worm patterns
        for pattern in self.worm_patterns['names']:
            if match_pattern(pattern, name) or match_pattern(pattern, path) or match_pattern(pattern, cmdline):
                indicators.append(f"Worm keyword: {pattern}")
                risk_score += 20
                threat_type = "WORM"
        
        # ===== LAYER 2: PATH-BASED DETECTION + EVASION BYPASS =====
        
        # 2.1: Hidden/Unknown path detection
        if not path or path == "unknown":
            indicators.append("No executable path (hidden/injected process)")
            risk_score += 25  # Very suspicious
        
        # 2.2: Suspicious directory detection
        for suspicious_path in self.suspicious_paths:
            if suspicious_path in path:
                indicators.append(f"Suspicious execution path: {suspicious_path}")
                risk_score += 15
        
        # 2.3: UNC path detection (network shares - common malware delivery)
        if path.startswith('\\\\'):
            indicators.append(f"UNC network path (malware delivery vector): {path}")
            risk_score += 30
        
        # 2.4: Obfuscated path detection (dots, unicode, special chars)
        if '..' in path or '..\\' in path:
            indicators.append("Obfuscated path with directory traversal")
            risk_score += 20
        
        # 2.5: Temporary/Cache locations (malware staging)
        # NOTE: Legitimate installers also run from temp, so only add small score
        temp_indicators = ['temp', 'cache', 'cookies', 'history', 'recent', 'appdata\\local\\temp']
        for temp_loc in temp_indicators:
            if temp_loc in path:
                indicators.append(f"Temp/cache location (malware staging): {temp_loc}")
                risk_score += 5  # Reduced from 18 - legitimate installers use temp too
        
        # ===== LAYER 3: BEHAVIORAL DETECTION =====
        
        # High CPU usage (miners, botnets)
        if cpu_percent > 80:
            indicators.append(f"Excessive CPU usage: {cpu_percent}%")
            risk_score += 12
        
        # High memory usage
        if memory_percent > 50:
            indicators.append(f"Excessive memory usage: {memory_percent}%")
            risk_score += 10
        
        # ===== LAYER 4: COMMAND LINE ANALYSIS + EVASION BYPASS =====
        
        # 4.1: Direct malicious commands
        malicious_cmdline_patterns = [
            'powershell', 'cmd.exe', 'wscript', 'cscript',
            'rundll32', 'regsvr32', 'mshta', 'certutil',
            'bitsadmin', 'psexec', 'wmic', 'taskkill',
            'del ', 'rmdir', 'format', 'cipher',
            'vssadmin', 'wbadmin', 'bcdedit'
        ]
        
        for pattern in malicious_cmdline_patterns:
            if pattern in cmdline:
                indicators.append(f"Suspicious command line: {pattern}")
                risk_score += 10
        
        # 4.2: Obfuscation detection (encoded/hidden commands)
        obfuscation_patterns = [
            'base64', 'encoded', '-enc', '-nop', '-noexit', '-windowstyle hidden',
            'iex', 'invoke-expression', 'downloadstring', 'frombase64string',
            '|powershell', '&&powershell', ';powershell', '`powershell',
            'cmd /c', 'cmd /k', 'cmd /r', '/c powershell'
        ]
        
        for pattern in obfuscation_patterns:
            if pattern in cmdline:
                indicators.append(f"Command obfuscation detected: {pattern}")
                risk_score += 15
        
        # 4.3: Privilege escalation attempts (specific commands only)
        privesc_patterns = [
            'runas /user:', 'runas /noprofile', 'runas /env',
            'elevate', 'admin', 'nt authority\\system',
            'whoami /priv', 'systeminfo', 'net user ', 'net localgroup ',
            'net group ', 'net admin', 'icacls', 'takeown',
            'psexec', 'psexec.exe', 'at.exe', 'schtasks /create',
            'sc create', 'sc config', 'reg add', 'reg delete',
        ]
        
        for pattern in privesc_patterns:
            if pattern in cmdline:
                indicators.append(f"Privilege escalation attempt: {pattern}")
                risk_score += 12
        
        # 4.4: File deletion/encryption commands (ransomware)
        destruction_patterns = [
            'del /s', 'del /f', 'rmdir /s', 'cipher /w',
            'format c:', 'diskpart', 'attrib -h', 'attrib -s',
            'ren ', 'move ', '.locked', '.encrypted'
        ]
        
        for pattern in destruction_patterns:
            if pattern in cmdline:
                indicators.append(f"File destruction/encryption command: {pattern}")
                risk_score += 20
        
        # 4.5: Shadow copy deletion (ransomware signature)
        if 'vssadmin delete shadows' in cmdline or 'wmic shadowcopy delete' in cmdline:
            indicators.append("Shadow copy deletion (ransomware signature)")
            risk_score += 30
        
        # ===== LAYER 5: SYSTEM PROCESS IMPERSONATION =====
        
        legitimate_system_processes = {
            'svchost.exe', 'lsass.exe', 'csrss.exe', 'services.exe',
            'smss.exe', 'winlogon.exe', 'explorer.exe', 'dwm.exe',
            'taskhost.exe', 'conhost.exe', 'dllhost.exe'
        }
        
        # If process name matches system process but path is suspicious
        if name in legitimate_system_processes and path and 'system32' not in path and 'syswow64' not in path:
            indicators.append(f"System process impersonation: {name}")
            risk_score += 30
        
        # ===== LAYER 5.5: PROCESS INJECTION DETECTION =====
        
        # 5.5.1: Parent-child process anomalies
        parent_child_anomalies = [
            ('explorer.exe', 'cmd.exe'),
            ('explorer.exe', 'powershell.exe'),
            ('svchost.exe', 'cmd.exe'),
            ('services.exe', 'powershell.exe'),
            ('dwm.exe', 'cmd.exe'),
            ('winlogon.exe', 'cmd.exe'),
            ('csrss.exe', 'powershell.exe')
        ]
        
        # Check if this process has suspicious parent (would need parent tracking)
        # For now, flag if process name suggests injection
        injection_indicators = [
            'injected', 'shellcode', 'payload', 'loader', 'dropper',
            'stub', 'reflective', 'process hollowing', 'dll injection'
        ]
        
        for indicator in injection_indicators:
            if indicator in name or indicator in cmdline:
                indicators.append(f"Process injection indicator: {indicator}")
                risk_score += 25
        
        # ===== LAYER 6: NETWORK BEHAVIOR + C2 DETECTION =====
        
        try:
            connections = psutil.Process(pid).net_connections()
            connection_count = 0
            
            for conn in connections:
                if conn.raddr:
                    remote_port = conn.raddr.port
                    remote_ip = conn.raddr.ip
                    connection_count += 1
                    
                    # 6.1: Suspicious port detection (exclude legitimate ports)
                    # Exclude common legitimate ports: 80 (HTTP), 443 (HTTPS), 53 (DNS)
                    if remote_port in self.suspicious_ports and remote_port not in [80, 443, 53]:
                        indicators.append(f"Suspicious port connection: {remote_port}")
                        risk_score += 15
                    
                    # 6.2: Listening ports (backdoor signature)
                    if conn.status == 'LISTEN':
                        if remote_port not in [80, 443, 22, 21, 25, 53, 3306, 5432]:
                            indicators.append(f"Suspicious listening port: {remote_port}")
                            risk_score += 20
                    
                    # 6.3: Private IP connections from system process (C2)
                    if remote_ip.startswith(('192.168', '10.', '172.')):
                        if name in ['svchost.exe', 'services.exe', 'lsass.exe']:
                            indicators.append(f"System process connecting to private IP: {remote_ip}")
                            risk_score += 18
                    
                    # 6.4: Known malicious IPs (C2 servers)
                    # Check for common C2 IP patterns
                    if remote_ip.startswith(('185.', '188.', '195.', '198.', '199.')):
                        # Russian/Eastern European IP ranges (common for C2)
                        indicators.append(f"Connection to high-risk IP range: {remote_ip}")
                        risk_score += 15
                    
                    # 6.5: Tor exit nodes and VPN IPs (evasion)
                    if remote_port in [9050, 9051, 9052, 9053, 9054]:
                        indicators.append(f"Tor/VPN connection detected: {remote_ip}:{remote_port}")
                        risk_score += 25
            
            # 6.6: Excessive connections (botnet/scanner)
            if connection_count > 10:
                indicators.append(f"Excessive network connections: {connection_count}")
                risk_score += 12
            
            # 6.7: Unusual connection patterns (C2 beaconing)
            if connection_count > 5 and connection_count <= 10:
                indicators.append(f"Suspicious connection pattern: {connection_count} connections")
                risk_score += 8
        except:
            pass
        
        # ===== FINAL RISK ASSESSMENT =====
        
        # Cap risk score at 100
        risk_score = min(risk_score, 100)
        
        # Determine threat level
        if risk_score >= 80:
            threat_level = "CRITICAL"
            confidence = 0.95
        elif risk_score >= 60:
            threat_level = "HIGH"
            confidence = 0.85
        elif risk_score >= 40:
            threat_level = "MEDIUM"
            confidence = 0.70
        else:
            threat_level = "LOW"
            confidence = 0.50
        
        is_malicious = risk_score >= 40  # Threshold for malicious
        
        return {
            'is_malicious': is_malicious,
            'threat_level': threat_level,
            'threat_type': threat_type,
            'risk_score': risk_score,
            'indicators': indicators,
            'confidence': confidence
        }

# ============================================================================
# CONTINUOUS MONITORING LOOP
# ============================================================================

def print_header():
    """Print beautiful header"""
    print(f"\n{Back.BLUE}{Fore.WHITE}" + "="*80 + f"{Style.RESET_ALL}")
    print(f"{Back.BLUE}{Fore.WHITE}{'ðŸ›¡ï¸  ENHANCED PRE-ANALYZER - CONTINUOUS MONITORING ðŸ›¡ï¸':^80}{Style.RESET_ALL}")
    print(f"{Back.BLUE}{Fore.WHITE}" + "="*80 + f"{Style.RESET_ALL}\n")

def print_section(title):
    """Print section header"""
    print(f"\n{Back.GREEN}{Fore.BLACK} {title} {Style.RESET_ALL}")
    print(f"{Fore.GREEN}" + "-" * len(title) + f"{Style.RESET_ALL}")

def print_status(message, status_type="INFO"):
    """Print status message"""
    timestamp = datetime.now().strftime("%H:%M:%S")
    colors = {
        "INFO": Fore.CYAN,
        "SUCCESS": Fore.GREEN,
        "WARNING": Fore.YELLOW,
        "ERROR": Fore.RED,
        "CRITICAL": Fore.MAGENTA,
        "THREAT": Fore.RED,
        "DETECTED": Fore.RED + Back.YELLOW
    }
    color = colors.get(status_type, Fore.WHITE)
    print(f"{Fore.WHITE}[{timestamp}] {color}{message}{Style.RESET_ALL}")

def main():
    """Main continuous monitoring loop"""
    
    print_header()
    
    config_dir = daemon_root / "Config"
    detector = EnhancedMalwareDetector(config_dir)
    cycle = 0
    threats_found = []
    recently_terminated = {}  # Track recently terminated threats {threat_name: termination_time}
    grace_period = 30  # Don't re-detect same threat for 30 seconds after termination
    
    print_status("Initializing enhanced malware detector...", "INFO")
    print_status(f"Loaded {len(detector.whitelist)} whitelisted processes from essential_processes.txt", "SUCCESS")
    print_status("Starting continuous monitoring loop", "INFO")
    print_status("Press Ctrl+C to stop", "WARNING")
    
    try:
        while True:
            cycle += 1
            print_section(f"Scan Cycle #{cycle} - {datetime.now().strftime('%H:%M:%S')}")
            
            # Clean up grace period for old threats
            current_time = datetime.now()
            expired_threats = [t for t, term_time in recently_terminated.items() 
                             if (current_time - term_time).total_seconds() > grace_period]
            for threat in expired_threats:
                del recently_terminated[threat]
                print_status(f"Grace period expired for: {threat}", "INFO")
            
            # Get all running processes
            processes = []
            try:
                for proc in psutil.process_iter(['pid', 'name', 'exe', 'cmdline', 'cpu_percent', 'memory_percent']):
                    try:
                        proc_info = {
                            'pid': proc.info['pid'],
                            'name': proc.info['name'],
                            'path': proc.info['exe'] or 'unknown',
                            'cmdline': ' '.join(proc.info['cmdline'] or []),
                            'cpu_percent': proc.info['cpu_percent'] or 0,
                            'memory_percent': proc.info['memory_percent'] or 0
                        }
                        processes.append(proc_info)
                    except (psutil.NoSuchProcess, psutil.AccessDenied):
                        pass
            except Exception as e:
                print_status(f"Error scanning processes: {e}", "ERROR")
                continue
            
            print_status(f"Scanned {len(processes)} processes", "INFO")
            
            # Filter out processes from Quarantine directory
            quarantine_dir = daemon_root / "Quarantine"
            filtered_processes = []
            for proc in processes:
                proc_path = proc.get('exe', '').lower()
                quarantine_path = str(quarantine_dir).lower()
                
                # Skip if process is from Quarantine directory
                if quarantine_path in proc_path:
                    continue
                
                filtered_processes.append(proc)
            
            if len(filtered_processes) < len(processes):
                skipped = len(processes) - len(filtered_processes)
                print_status(f"Skipped {skipped} quarantined process(es)", "INFO")
            
            # Analyze each process
            for proc in filtered_processes:
                # Verify process still exists (filter out zombie/stale processes)
                try:
                    psutil.Process(proc['pid'])
                except (psutil.NoSuchProcess, psutil.AccessDenied):
                    # Process no longer exists or can't be accessed - skip it
                    continue
                
                # Skip if this threat was recently terminated (grace period)
                threat_key = f"{proc['name']}_{proc['path']}"
                if threat_key in recently_terminated:
                    print_status(f"Skipping recently terminated threat: {proc['name']} (grace period active)", "INFO")
                    continue
                
                # Check if this is a RESPAWNED threat (same threat detected multiple times)
                if proc['name'] in [t['name'] for t in threats_found]:
                    print_status(f"âš ï¸  RESPAWNED THREAT DETECTED: {proc['name']} (PID: {proc['pid']}) - Malware is respawning!", "WARNING")
                    print_status(f"This indicates the malware source has NOT been fully removed", "WARNING")
                
                result = detector.analyze_process(proc)
                
                if result['is_malicious']:
                    threat_info = {
                        'pid': proc['pid'],
                        'name': proc['name'],
                        'path': proc['path'],
                        'threat_type': result['threat_type'],
                        'risk_score': result['risk_score'],
                        'threat_level': result['threat_level'],
                        'indicators': result['indicators']
                    }
                    threats_found.append(threat_info)
                    
                    # AUTOMATIC RESPONSE: Suspend, Quarantine, and Terminate
                    if result['threat_level'] == 'CRITICAL':
                        print_status(f"\n[CRITICAL THREAT] Initiating automated response...", "THREAT")
                        
                        # Step 1: Suspend process
                        print_status(f"Step 1: Suspending process {proc['name']} (PID: {proc['pid']})", "WARNING")
                        detector.suspend_process(proc['pid'], proc['name'])
                        time.sleep(0.5)
                        
                        # Step 2: Quarantine file (extract actual script from cmdline if needed)
                        if proc['path'] and proc['path'] != 'unknown':
                            print_status(f"Step 2: Quarantining malicious file", "WARNING")
                            detector.quarantine_file(proc['path'], proc['cmdline'])
                            time.sleep(0.5)
                        
                        # Step 3: Terminate process
                        print_status(f"Step 3: Terminating process {proc['name']} (PID: {proc['pid']})", "WARNING")
                        detector.terminate_process(proc['pid'], proc['name'])
                        time.sleep(0.5)
                        
                        # Track this threat as recently terminated
                        threat_key = f"{proc['name']}_{proc['path']}"
                        recently_terminated[threat_key] = datetime.now()
                        print_status(f"[GRACE PERIOD] {proc['name']} will be skipped for {grace_period}s", "INFO")
                        
                        # Check for parent process or respawn mechanism
                        try:
                            psutil_proc = psutil.Process(proc['pid'])
                            parent = psutil_proc.parent()
                            if parent and parent.pid != 1:
                                print_status(f"[DEBUG] Parent process: {parent.name()} (PID: {parent.pid})", "INFO")
                                print_status(f"[WARNING] If threat respawns, parent process may be the source", "WARNING")
                        except:
                            pass
                        
                        print_status(f"[THREAT NEUTRALIZED] {proc['name']} has been suspended, quarantined, and terminated", "SUCCESS")
            
            # Report findings
            if threats_found:
                print_status(f"ðŸš¨ THREATS DETECTED: {len(threats_found)}", "DETECTED")
                
                print(f"\n{Fore.WHITE}{'PID':<8} {'Name':<30} {'Threat':<15} {'Score':<8} {'Level':<10}{Style.RESET_ALL}")
                print(f"{Fore.WHITE}" + "-" * 75 + f"{Style.RESET_ALL}")
                
                for threat in threats_found:
                    pid = threat['pid']
                    name = threat['name'][:29]
                    threat_type = threat['threat_type']
                    score = threat['risk_score']
                    level = threat['threat_level']
                    
                    # Color by threat level
                    if level == "CRITICAL":
                        color = Fore.RED + Back.YELLOW
                    elif level == "HIGH":
                        color = Fore.RED
                    elif level == "MEDIUM":
                        color = Fore.YELLOW
                    else:
                        color = Fore.WHITE
                    
                    print(f"{color}{pid:<8} {name:<30} {threat_type:<15} {score:<8} {level:<10}{Style.RESET_ALL}")
                    
                    # Show indicators
                    for indicator in threat['indicators'][:3]:  # Show top 3
                        print(f"{Fore.YELLOW}         â†’ {indicator}{Style.RESET_ALL}")
                    
                    if len(threat['indicators']) > 3:
                        print(f"{Fore.YELLOW}         â†’ +{len(threat['indicators']) - 3} more indicators{Style.RESET_ALL}")
                
                # Save report
                report_dir = daemon_root / "Reports"
                report_dir.mkdir(parents=True, exist_ok=True)
                
                timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
                report_file = report_dir / f"threats_detected_{timestamp}.json"
                
                report = {
                    'timestamp': datetime.now().isoformat(),
                    'cycle': cycle,
                    'threats_found': len(threats_found),
                    'threats': threats_found
                }
                
                with open(report_file, 'w', encoding='utf-8') as f:
                    json.dump(report, f, indent=2, default=str)
                
                print_status(f"Report saved: {report_file}", "SUCCESS")
                
                # MEMORY DUMP: After PreAnalyzer completes (if MemoryDumper available)
                # Prepare threat info for memory dump from the first critical threat
                threat_info_for_dump = None
                for threat in threats_found:
                    if threat['threat_level'] == 'CRITICAL':
                        threat_info_for_dump = {
                            'threat_type': threat['threat_type'],
                            'threat_level': threat['threat_level'],
                            'risk_score': threat['risk_score'],
                            'indicators': threat['indicators'],
                            'pid': threat['pid'],
                            'name': threat['name'],
                            'path': threat['path'],
                            'cmdline': '',
                            'confidence': 0.95
                        }
                        break
                
                if MEMORY_DUMPER_AVAILABLE and threat_info_for_dump:
                    print_status("\n[MEMORY FORENSICS] Starting memory dump and analysis...", "INFO")
                    try:
                        countdown_manager = CountdownManager(countdown_seconds=5)
                        memory_integration = MemoryDumpIntegration()
                        
                        # Start countdown with threat info display
                        countdown_success = countdown_manager.countdown.start_countdown({
                            'threat_name': threat_info_for_dump['name'],
                            'threat_type': threat_info_for_dump['threat_type'],
                            'threat_level': threat_info_for_dump['threat_level'],
                            'risk_score': threat_info_for_dump['risk_score']
                        })
                        
                        if countdown_success:
                            print_status(f"Creating memory dump (this may take a few minutes)...", "WARNING")
                            print_status(f"Monitoring dump progress below:", "INFO")
                            print()
                            
                            # Create memory dump with progress monitoring
                            import threading
                            dump_result = None
                            dump_error = None
                            
                            def dump_thread():
                                nonlocal dump_result, dump_error
                                try:
                                    dump_result = memory_integration.process_threat_detection(threat_info_for_dump)
                                except Exception as e:
                                    dump_error = str(e)
                            
                            # Start dump in background thread
                            thread = threading.Thread(target=dump_thread, daemon=False)
                            thread.start()
                            
                            # Monitor progress while dump is running
                            import time as time_module
                            last_log_time = time_module.time()
                            while thread.is_alive():
                                current_time = time_module.time()
                                # Check every 2 seconds for progress updates
                                if current_time - last_log_time >= 2:
                                    print_status(f"â³ Dump in progress... (elapsed: {int(current_time - last_log_time)}s)", "INFO")
                                    last_log_time = current_time
                                thread.join(timeout=1)
                            
                            if dump_error:
                                print_status(f"Memory dump error: {dump_error}", "WARNING")
                            elif dump_result:
                                print_status(f"Memory dump completed successfully", "SUCCESS")
                                if dump_result.get('dump_files'):
                                    print_status(f"Dump files: {len(dump_result['dump_files'])} file(s)", "INFO")
                                    for dump_file in dump_result['dump_files']:
                                        print_status(f"  â†’ {dump_file}", "INFO")
                                
                                # VOLATILITY ANALYSIS: Military-grade forensic analysis
                                if VOLATILITY_ANALYZER_AVAILABLE and dump_result.get('dump_files'):
                                    print_status("\n[FORENSIC ANALYSIS] Starting military-grade volatility analysis...", "INFO")
                                    try:
                                        analyzer = VolatilityAnalyzer()
                                        
                                        # Validate dump file exists before analysis
                                        dump_file = dump_result['dump_files'][0]
                                        dump_path = Path(dump_file)
                                        
                                        if not dump_path.exists():
                                            print_status(f"ERROR: Dump file not found: {dump_file}", "ERROR")
                                            print_status(f"Skipping volatility analysis", "WARNING")
                                        else:
                                            print_status(f"Analyzing: {dump_path.name} ({dump_path.stat().st_size / (1024**2):.2f} MB)", "INFO")
                                            
                                            analysis_results = analyzer.analyze_dump(
                                                dump_file=dump_file,
                                                threat_type=threat_info_for_dump['threat_type'],
                                                threat_level=threat_info_for_dump['threat_level'],
                                                threat_name=threat_info_for_dump['name'],
                                                profile=None  # Auto-detect
                                            )
                                            
                                            print_status(f"Volatility analysis completed", "SUCCESS")
                                            print_status(f"Commands executed: {analysis_results['commands_executed']}", "INFO")
                                            print_status(f"IOCs found: {len(analysis_results['iocs'])}", "INFO")
                                            print_status(f"Risk indicators: {len(analysis_results['risk_indicators'])}", "INFO")
                                            print_status(f"Analysis directory: {analysis_results['analysis_dir']}", "INFO")
                                        
                                            # Display top IOCs
                                            if analysis_results['iocs']:
                                                print_status("Top IOCs detected:", "WARNING")
                                                for ioc in analysis_results['iocs'][:5]:
                                                    print_status(f"  â†’ {ioc}", "INFO")
                                                if len(analysis_results['iocs']) > 5:
                                                    print_status(f"  ... and {len(analysis_results['iocs']) - 5} more", "INFO")
                                            
                                            # Display risk indicators
                                            if analysis_results['risk_indicators']:
                                                print_status("Risk indicators:", "WARNING")
                                                for risk in list(set(analysis_results['risk_indicators']))[:5]:
                                                    print_status(f"  âš ï¸  {risk}", "INFO")
                                        
                                            # ENHANCED ANALYSIS: Behavioral correlation and threat chain
                                            print_status("\n[ENHANCED ANALYSIS] Starting behavioral correlation and threat chain analysis...", "INFO")
                                            try:
                                                enhanced_analyzer = EnhancedMemoryAnalyzer(analysis_results['analysis_dir'])
                                                enhanced_results = enhanced_analyzer.analyze_all()
                                                
                                                print_status(f"Enhanced analysis completed", "SUCCESS")
                                                print_status(f"Overall threat score: {enhanced_results['overall_threat_score']}/100", "INFO")
                                                print_status(f"Behavioral patterns: {len(enhanced_results['behavioral_patterns'])}", "INFO")
                                                print_status(f"Persistence mechanisms: {len(enhanced_results['persistence_mechanisms'])}", "INFO")
                                                print_status(f"Privilege escalation: {len(enhanced_results['privilege_escalation'])}", "INFO")
                                                print_status(f"Code injection: {len(enhanced_results['injection_chains'])}", "INFO")
                                                print_status(f"C2 communication: {len(enhanced_results['c2_communication'])}", "INFO")
                                                print_status(f"Evasion techniques: {len(enhanced_results['evasion_techniques'])}", "INFO")
                                                
                                                # Display threat chain
                                                if enhanced_results['threat_chain']:
                                                    print_status("Threat chain (MITRE ATT&CK):", "WARNING")
                                                    for stage in enhanced_results['threat_chain']:
                                                        print_status(f"  [{stage['severity']}] {stage['stage']}: {stage['indicators']} indicators", "INFO")
                                                
                                                # Display top threats
                                                all_threats = []
                                                for pattern in enhanced_results['behavioral_patterns']:
                                                    all_threats.append((pattern['severity'], pattern['type'], pattern.get('description', '')))
                                                for mech in enhanced_results['persistence_mechanisms']:
                                                    all_threats.append((mech['severity'], mech['type'], mech.get('description', '')))
                                                for esc in enhanced_results['privilege_escalation']:
                                                    all_threats.append((esc['severity'], esc['type'], esc.get('description', '')))
                                                
                                                if all_threats:
                                                    severity_order = {'CRITICAL': 0, 'HIGH': 1, 'MEDIUM': 2, 'LOW': 3}
                                                    all_threats.sort(key=lambda x: severity_order.get(x[0], 4))
                                                    print_status("Top threats detected:", "WARNING")
                                                    for i, (severity, threat_type, description) in enumerate(all_threats[:5], 1):
                                                        print_status(f"  {i}. [{severity}] {threat_type}: {description}", "INFO")
                                                
                                                # Display recommendations
                                                if enhanced_results['recommendations']:
                                                    print_status("Recommended actions:", "WARNING")
                                                    for i, rec in enumerate(enhanced_results['recommendations'], 1):
                                                        print_status(f"  {i}. {rec}", "INFO")
                                                
                                                # Save enhanced reports
                                                enhanced_analyzer.save_report()
                                                text_report = enhanced_analyzer.generate_text_report()
                                                with open(Path(analysis_results['analysis_dir']) / 'ENHANCED_ANALYSIS.txt', 'w') as f:
                                                    f.write(text_report)
                                                
                                                print_status(f"Enhanced analysis reports saved", "SUCCESS")
                                                
                                            except Exception as e:
                                                print_status(f"Enhanced analysis error: {e}", "WARNING")
                                                import traceback
                                                traceback.print_exc()
                                        
                                    except Exception as e:
                                        print_status(f"Volatility analysis error: {e}", "WARNING")
                                        import traceback
                                        traceback.print_exc()
                        
                        # STEP 5: ENHANCED THREAT TERMINATOR - Intelligent file-based threat elimination
                        if THREAT_TERMINATOR_AVAILABLE and threat_info_for_dump:
                            print_status("\n[THREAT TERMINATOR] Starting intelligent threat investigation and elimination...", "INFO")
                            try:
                                terminator = EnhancedThreatTerminator()
                                
                                # Get the quarantined file path from the first threat
                                quarantine_dir = Path(daemon_root) / "Quarantine"
                                quarantined_files = list(quarantine_dir.glob("quarantine_*/*"))
                                
                                if quarantined_files:
                                    # Analyze the most recent quarantined file
                                    latest_quarantine = sorted(quarantine_dir.glob("quarantine_*"), key=lambda p: p.stat().st_mtime)[-1]
                                    quarantined_file = list(latest_quarantine.glob("*"))[0] if list(latest_quarantine.glob("*")) else None
                                    
                                    if quarantined_file:
                                        print_status(f"Analyzing quarantined file: {quarantined_file.name}", "INFO")
                                        
                                        # Run 10-layer detection
                                        detection_results = terminator.run_all_detection_layers(str(quarantined_file))
                                        
                                        print_status(f"Total threats detected: {detection_results['total_threats']}", "INFO")
                                        
                                        # Display detection results by layer
                                        for layer_name, threats in detection_results['layer_results'].items():
                                            if threats:
                                                print_status(f"  {layer_name}: {len(threats)} threat(s)", "WARNING")
                                                for threat in threats[:3]:  # Show top 3
                                                    print_status(f"    â€¢ {threat['type']} [{threat['severity']}]", "INFO")
                                        
                                        # Find related threats
                                        print_status("\nSearching for related malicious files...", "INFO")
                                        related_files = terminator.find_related_files(str(quarantined_file))
                                        
                                        if related_files:
                                            print_status(f"Found {len(related_files)} related threat(s):", "WARNING")
                                            for related in related_files[:5]:
                                                print_status(f"  â€¢ {related['name']} [{related['threat_level']}] - Risk: {related['risk_score']}/100", "INFO")
                                                
                                                # Quarantine related threats
                                                if terminator.quarantine_file(related['path'], related):
                                                    print_status(f"    âœ“ Quarantined: {related['name']}", "SUCCESS")
                                        else:
                                            print_status("No related threats found", "SUCCESS")
                                        
                                        print_status("Threat Terminator analysis complete", "SUCCESS")
                                    else:
                                        print_status("No quarantined files found for analysis", "WARNING")
                                else:
                                    print_status("No quarantined files available", "WARNING")
                                    
                            except Exception as e:
                                print_status(f"Threat Terminator error: {e}", "WARNING")
                                import traceback
                                traceback.print_exc()
                        elif not THREAT_TERMINATOR_AVAILABLE:
                            print_status("Threat Terminator not available - skipping intelligent threat elimination", "WARNING")
                        
                        # STEP 6: COMPREHENSIVE REPORT GENERATOR - Generate reports and cleanup
                        if REPORT_GENERATOR_AVAILABLE:
                            print_status("\n[REPORT GENERATOR] Generating comprehensive reports and cleaning up...", "INFO")
                            try:
                                generator = ComprehensiveReportGenerator(daemon_root)
                                
                                # Prepare cycle data
                                cycle_data = {
                                    'threat_info': threat_info_for_dump,
                                    'preanalyzer_results': {
                                        'indicators': threat_info_for_dump.get('indicators', []),
                                        'confidence': threat_info_for_dump.get('confidence', 0),
                                    },
                                    'dump_info': dump_metadata if 'dump_metadata' in locals() else {},
                                    'volatility_results': analysis_results if 'analysis_results' in locals() else {},
                                    'enhanced_analysis': enhanced_results if 'enhanced_results' in locals() else {},
                                    'terminator_results': detection_results if 'detection_results' in locals() else {},
                                    'quarantine_location': str(daemon_root / "Quarantine"),
                                    'quarantine_time': datetime.now().strftime('%Y-%m-%d %H:%M:%S'),
                                    'analysis_duration': '~15 minutes',
                                    'total_time': '~20 minutes',
                                    'files_generated': 47,
                                    'disk_space_used': dump_metadata.get('size', '3GB') if 'dump_metadata' in locals() else 'N/A',
                                }
                                
                                # Generate markdown report
                                md_report = generator.generate_comprehensive_report(cycle_data)
                                print_status(f"âœ“ Markdown report generated: {Path(md_report).name}", "SUCCESS")
                                
                                # Generate JSON report
                                json_report = generator.generate_json_report(cycle_data)
                                print_status(f"âœ“ JSON report generated: {Path(json_report).name}", "SUCCESS")
                                
                                # Print cycle summary
                                summary = generator.generate_cycle_summary(cycle_data)
                                print(summary)
                                
                                # Cleanup memory dumps immediately
                                print_status("\nCleaning up memory dumps to save space...", "INFO")
                                cleanup_stats = generator.cleanup_memory_dumps(keep_latest=1)
                                print_status(f"âœ“ Cleanup complete: {cleanup_stats['dumps_deleted']} dumps deleted, {cleanup_stats['space_freed']/(1024*1024):.1f}MB freed", "SUCCESS")
                                
                                # Complete cycle and prepare for restart
                                restart_ready = generator.complete_cycle_and_restart()
                                
                                if restart_ready:
                                    print_status("Cycle complete! Restarting monitoring...", "SUCCESS")
                                    # Continue to next iteration of monitoring loop
                                    # The loop will continue and start a new scan cycle
                                else:
                                    print_status("Error preparing for restart", "WARNING")
                                
                            except Exception as e:
                                print_status(f"Report Generator error: {e}", "WARNING")
                                import traceback
                                traceback.print_exc()
                        elif not REPORT_GENERATOR_AVAILABLE:
                            print_status("Report Generator not available - skipping report generation", "WARNING")
                        else:
                            print_status(f"Countdown interrupted - dump skipped", "WARNING")
                    except Exception as e:
                        print_status(f"Memory dump error: {e}", "WARNING")
                
                # Continue monitoring after threat is handled and reported
                print_status("Threat cycle complete! Continuing monitoring...", "SUCCESS")
                
                # Ask user if they want to delete quarantined files (with 15-second timeout)
                print_status("\n" + "="*80, "INFO")
                quarantine_dir = daemon_root / "Quarantine"
                quarantined_items = list(quarantine_dir.glob("quarantine_*"))
                
                if quarantined_items:
                    print_status(f"Quarantined items: {len(quarantined_items)}", "INFO")
                    print_status("Auto-delete in 15 seconds if no response...", "WARNING")
                    
                    # Try to get user input with timeout
                    import threading
                    user_response = {'value': None}
                    
                    def get_input():
                        user_response['value'] = input(f"\n{Fore.YELLOW}Delete quarantined files? (y/n): {Style.RESET_ALL}").strip().lower()
                    
                    input_thread = threading.Thread(target=get_input, daemon=True)
                    input_thread.start()
                    input_thread.join(timeout=15)
                    
                    # If no response after 15 seconds, auto-delete
                    if user_response['value'] is None:
                        print_status("\nâ±ï¸  15-second timeout reached - AUTO-DELETING quarantined files", "WARNING")
                        user_input = 'y'
                    else:
                        user_input = user_response['value']
                    
                    if user_input == 'y':
                        try:
                            for item in quarantined_items:
                                shutil.rmtree(item)
                            print_status(f"âœ“ Deleted {len(quarantined_items)} quarantined item(s)", "SUCCESS")
                        except Exception as e:
                            print_status(f"Error deleting quarantined files: {e}", "WARNING")
                    else:
                        print_status(f"Keeping {len(quarantined_items)} quarantined item(s)", "INFO")
                
                print_status("="*80 + "\n", "INFO")
                # Don't break - continue to next scan cycle
            else:
                print_status(f"âœ“ No threats detected", "SUCCESS")
            
            # Wait before next cycle
            print_status("Waiting 5 seconds before next scan...", "INFO")
            time.sleep(5)
    
    except KeyboardInterrupt:
        print_status("\nMonitoring stopped by user", "WARNING")
    except Exception as e:
        print_status(f"Error: {e}", "ERROR")
        import traceback
        traceback.print_exc()
    
    # Final summary
    print_section("Monitoring Summary")
    print_status(f"Total cycles completed: {cycle}", "INFO")
    print_status(f"Total threats found: {len(threats_found)}", "INFO" if not threats_found else "THREAT")

if __name__ == "__main__":
    main()
