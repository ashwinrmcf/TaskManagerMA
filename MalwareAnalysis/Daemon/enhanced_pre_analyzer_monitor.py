#!/usr/bin/env python3
"""
ENHANCED PRE-ANALYZER WITH CONTINUOUS MONITORING
International-level malware detection with aggressive heuristics
Continuous monitoring loop - keeps running until threats found
"""

import sys
import json
import time
import psutil
from pathlib import Path
from datetime import datetime
from colorama import init, Fore, Back, Style

# Initialize colorama
init(autoreset=True)

# Add daemon to path
daemon_root = Path(__file__).parent
sys.path.insert(0, str(daemon_root))

# ============================================================================
# ENHANCED MALWARE DETECTION ENGINE
# ============================================================================

class EnhancedMalwareDetector:
    """International-level malware detection with aggressive heuristics"""
    
    def __init__(self, config_dir: Path = None):
        """Initialize detector with comprehensive threat signatures"""
        
        # Load whitelist from essential_processes.txt
        self.config_dir = config_dir or daemon_root / "Config"
        self.whitelist = self._load_whitelist_from_file()
        
        # RANSOMWARE SIGNATURES (CIS/MITRE ATT&CK standards)
        self.ransomware_patterns = {
            'names': [
                'ransom', 'crypt', 'lock', 'encrypt', 'decrypt', 'wannacry', 'petya',
                'lockbit', 'revil', 'conti', 'blackcat', 'alphv', 'blackbasta',
                'cl0p', 'play', 'alphv', 'karakurt', 'darkside', 'darkside',
                'egregor', 'netwalker', 'sodinokibi', 'ragnar', 'maze', 'nefilim',
                'test.exe', '.test', 'ransomware.test'  # Test malware
            ],
            'behaviors': [
                'file_encryption', 'mass_file_access', 'registry_modification',
                'shadow_copy_deletion', 'backup_deletion', 'vss_deletion',
                'rapid_file_creation', 'file_extension_change'
            ]
        }
        
        # TROJAN/BACKDOOR SIGNATURES
        self.trojan_patterns = {
            'names': [
                'trojan', 'backdoor', 'rat', 'remote', 'access', 'tool',
                'agent', 'payload', 'loader', 'injector', 'dropper',
                'emotet', 'trickbot', 'qbot', 'dridex', 'zeus', 'citadel',
                'poison', 'poison_ivy', 'gh0st', 'darkcomet', 'njrat'
            ],
            'behaviors': [
                'network_injection', 'process_injection', 'dll_injection',
                'registry_persistence', 'startup_modification', 'service_creation',
                'admin_privilege_escalation', 'credential_theft'
            ]
        }
        
        # SPYWARE/KEYLOGGER SIGNATURES
        self.spyware_patterns = {
            'names': [
                'spy', 'keylog', 'stealer', 'monitor', 'track', 'sniff',
                'infostealer', 'password', 'credential', 'logger',
                'redline', 'vidar', 'raccoon', 'clipper', 'stealer',
                'infostealers', 'formgrabber', 'screenlogger'
            ],
            'behaviors': [
                'clipboard_monitoring', 'keyboard_monitoring', 'screen_capture',
                'browser_history_access', 'credential_access', 'file_exfiltration'
            ]
        }
        
        # ROOTKIT SIGNATURES
        self.rootkit_patterns = {
            'names': [
                'rootkit', 'kernel', 'driver', 'sys', 'hide', 'invisible',
                'zeroaccess', 'necurs', 'tdl', 'stuxnet', 'flame', 'duqu'
            ],
            'behaviors': [
                'kernel_modification', 'driver_loading', 'system_file_hiding',
                'process_hiding', 'network_hiding', 'registry_hiding'
            ]
        }
        
        # MINER SIGNATURES
        self.miner_patterns = {
            'names': [
                'miner', 'coin', 'bitcoin', 'monero', 'crypto', 'hash',
                'xmrig', 'cryptonight', 'stratum', 'pool', 'gpu',
                'minergate', 'nicehash', 'claymore', 'ethminer'
            ],
            'behaviors': [
                'high_cpu_usage', 'gpu_usage', 'network_pool_connection',
                'continuous_computation', 'resource_exhaustion'
            ]
        }
        
        # BOTNET SIGNATURES
        self.botnet_patterns = {
            'names': [
                'bot', 'botnet', 'command', 'control', 'c2', 'c&c',
                'mirai', 'dyn', 'ddos', 'conficker', 'mydoom', 'sality',
                'waledac', 'rustock', 'pushdo', 'kraken', 'ircbot'
            ],
            'behaviors': [
                'c2_communication', 'ddos_attack', 'command_execution',
                'propagation', 'self_replication', 'network_scanning'
            ]
        }
        
        # WORM SIGNATURES
        self.worm_patterns = {
            'names': [
                'worm', 'propagate', 'replicate', 'spread', 'mass_mail',
                'conficker', 'mydoom', 'nimda', 'melissa', 'iloveyou',
                'slammer', 'blaster', 'sasser', 'welchia'
            ],
            'behaviors': [
                'self_replication', 'network_propagation', 'email_propagation',
                'usb_propagation', 'share_propagation'
            ]
        }
        
        # SUSPICIOUS EXECUTION PATHS (where malware typically runs)
        self.suspicious_paths = [
            'temp', 'tmp', 'appdata\\local\\temp', 'windows\\temp',
            'users\\public', 'programdata', 'recycle.bin', 'downloads',
            'desktop', 'documents', 'startup', 'cache', 'cookies',
            'recent', 'history', 'roaming\\temp', 'local\\temp'
        ]
        
        # SUSPICIOUS PORTS (C2, backdoors, botnets)
        self.suspicious_ports = [
            6667,   # IRC
            1337,   # Elite proxy
            4444,   # Blaster
            5555,   # Pentagram
            8080,   # HTTP proxy
            27374,  # SubSeven
            31337,  # Back Orifice
            12345,  # NetBus
            54320,  # Schaufler
            9999,   # Urchin
            10000,  # Webmin
            20000,  # Usermin
            3389,   # RDP (suspicious if unexpected)
            445,    # SMB (worm propagation)
            139,    # NetBIOS
            135,    # RPC
        ]
        
        # SUSPICIOUS REGISTRY KEYS
        self.suspicious_registry_keys = [
            'run', 'runonce', 'runservices', 'startup',
            'shell', 'shellexecute', 'shellopen',
            'winlogon', 'notify', 'appinit_dlls',
            'lsass', 'svchost', 'services'
        ]
    
    def _load_whitelist_from_file(self) -> set:
        """Load whitelist from essential_processes.txt"""
        whitelist = set()
        whitelist_file = self.config_dir / "essential_processes.txt"
        
        if whitelist_file.exists():
            try:
                with open(whitelist_file, 'r', encoding='utf-8') as f:
                    for line in f:
                        line = line.strip().lower()
                        # Skip comments and empty lines, skip malware markers (!)
                        if line and not line.startswith('#') and not line.startswith('!'):
                            whitelist.add(line)
            except Exception as e:
                print(f"Error loading whitelist: {e}")
        
        return whitelist
    
    def analyze_process(self, proc_info: dict) -> dict:
        """
        Comprehensive process analysis with multiple detection layers
        
        Returns:
            {
                'is_malicious': bool,
                'threat_level': 'CRITICAL' | 'HIGH' | 'MEDIUM' | 'LOW',
                'threat_type': str,
                'risk_score': int (0-100),
                'indicators': [list of detected indicators],
                'confidence': float (0-1)
            }
        """
        
        name = proc_info.get('name', '').lower()
        path = proc_info.get('path', '').lower()
        cmdline = proc_info.get('cmdline', '').lower()
        pid = proc_info.get('pid', 0)
        cpu_percent = proc_info.get('cpu_percent', 0)
        memory_percent = proc_info.get('memory_percent', 0)
        
        # ===== WHITELIST CHECK - SKIP LEGITIMATE PROCESSES =====
        # Check if process is in whitelist from essential_processes.txt
        if name in self.whitelist:
            # BUT: Check if it's running from a LEGITIMATE system path
            # Legitimate system processes run from: C:\Windows\System32, C:\Windows\SysWOW64
            legitimate_paths = [
                'c:\\windows\\system32',
                'c:\\windows\\syswow64',
                'c:\\windows\\',
                'c:\\program files',
                'c:\\program files (x86)',
                'c:\\programdata\\microsoft',
                'c:\\winnt\\system32'
            ]
            
            is_legit_path = any(legit in path for legit in legitimate_paths)
            
            # If whitelisted process is running from SUSPICIOUS path = MALICIOUS
            if not is_legit_path and path and path != 'unknown':
                # Whitelisted name but wrong path = SPOOFED SYSTEM PROCESS
                indicators = [f"System process impersonation: {name} running from {path}"]
                risk_score = 85  # Very high confidence it's spoofed
                threat_type = "SYSTEM_PROCESS_SPOOFING"
            else:
                # Legitimate whitelisted process from legitimate path
                return {
                    'is_malicious': False,
                    'threat_level': 'SAFE',
                    'threat_type': 'WHITELISTED',
                    'risk_score': 0,
                    'indicators': ['Whitelisted process from legitimate path'],
                    'confidence': 1.0
                }
        else:
            indicators = []
            risk_score = 0
            threat_type = "UNKNOWN"
        
        # ===== LAYER 1: NAME-BASED DETECTION =====
        
        # Check ransomware patterns
        for pattern in self.ransomware_patterns['names']:
            if pattern in name or pattern in path:
                indicators.append(f"Ransomware keyword: {pattern}")
                risk_score += 25
                threat_type = "RANSOMWARE"
        
        # Check trojan patterns
        for pattern in self.trojan_patterns['names']:
            if pattern in name or pattern in path:
                indicators.append(f"Trojan keyword: {pattern}")
                risk_score += 20
                threat_type = "TROJAN"
        
        # Check spyware patterns
        for pattern in self.spyware_patterns['names']:
            if pattern in name or pattern in path:
                indicators.append(f"Spyware keyword: {pattern}")
                risk_score += 18
                threat_type = "SPYWARE"
        
        # Check rootkit patterns
        for pattern in self.rootkit_patterns['names']:
            if pattern in name or pattern in path:
                indicators.append(f"Rootkit keyword: {pattern}")
                risk_score += 22
                threat_type = "ROOTKIT"
        
        # Check miner patterns
        for pattern in self.miner_patterns['names']:
            if pattern in name or pattern in path:
                indicators.append(f"Miner keyword: {pattern}")
                risk_score += 15
                threat_type = "MINER"
        
        # Check botnet patterns
        for pattern in self.botnet_patterns['names']:
            if pattern in name or pattern in path:
                indicators.append(f"Botnet keyword: {pattern}")
                risk_score += 20
                threat_type = "BOTNET"
        
        # Check worm patterns
        for pattern in self.worm_patterns['names']:
            if pattern in name or pattern in path:
                indicators.append(f"Worm keyword: {pattern}")
                risk_score += 20
                threat_type = "WORM"
        
        # ===== LAYER 2: PATH-BASED DETECTION + EVASION BYPASS =====
        
        # 2.1: Hidden/Unknown path detection
        if not path or path == "unknown":
            indicators.append("No executable path (hidden/injected process)")
            risk_score += 25  # Very suspicious
        
        # 2.2: Suspicious directory detection
        for suspicious_path in self.suspicious_paths:
            if suspicious_path in path:
                indicators.append(f"Suspicious execution path: {suspicious_path}")
                risk_score += 15
        
        # 2.3: UNC path detection (network shares - common malware delivery)
        if path.startswith('\\\\'):
            indicators.append(f"UNC network path (malware delivery vector): {path}")
            risk_score += 30
        
        # 2.4: Obfuscated path detection (dots, unicode, special chars)
        if '..' in path or '..\\' in path:
            indicators.append("Obfuscated path with directory traversal")
            risk_score += 20
        
        # 2.5: Temporary/Cache locations (malware staging)
        temp_indicators = ['temp', 'cache', 'cookies', 'history', 'recent', 'appdata\\local\\temp']
        for temp_loc in temp_indicators:
            if temp_loc in path:
                indicators.append(f"Temp/cache location (malware staging): {temp_loc}")
                risk_score += 18
        
        # ===== LAYER 3: BEHAVIORAL DETECTION =====
        
        # High CPU usage (miners, botnets)
        if cpu_percent > 80:
            indicators.append(f"Excessive CPU usage: {cpu_percent}%")
            risk_score += 12
        
        # High memory usage
        if memory_percent > 50:
            indicators.append(f"Excessive memory usage: {memory_percent}%")
            risk_score += 10
        
        # ===== LAYER 4: COMMAND LINE ANALYSIS + EVASION BYPASS =====
        
        # 4.1: Direct malicious commands
        malicious_cmdline_patterns = [
            'powershell', 'cmd.exe', 'wscript', 'cscript',
            'rundll32', 'regsvr32', 'mshta', 'certutil',
            'bitsadmin', 'psexec', 'wmic', 'taskkill',
            'del ', 'rmdir', 'format', 'cipher',
            'vssadmin', 'wbadmin', 'bcdedit'
        ]
        
        for pattern in malicious_cmdline_patterns:
            if pattern in cmdline:
                indicators.append(f"Suspicious command line: {pattern}")
                risk_score += 10
        
        # 4.2: Obfuscation detection (encoded/hidden commands)
        obfuscation_patterns = [
            'base64', 'encoded', '-enc', '-nop', '-noexit', '-windowstyle hidden',
            'iex', 'invoke-expression', 'downloadstring', 'frombase64string',
            '|powershell', '&&powershell', ';powershell', '`powershell',
            'cmd /c', 'cmd /k', 'cmd /r', '/c powershell'
        ]
        
        for pattern in obfuscation_patterns:
            if pattern in cmdline:
                indicators.append(f"Command obfuscation detected: {pattern}")
                risk_score += 15
        
        # 4.3: Privilege escalation attempts
        privesc_patterns = [
            'runas', 'elevate', 'admin', 'system', 'nt authority',
            'whoami', 'systeminfo', 'net user', 'net localgroup'
        ]
        
        for pattern in privesc_patterns:
            if pattern in cmdline:
                indicators.append(f"Privilege escalation attempt: {pattern}")
                risk_score += 12
        
        # 4.4: File deletion/encryption commands (ransomware)
        destruction_patterns = [
            'del /s', 'del /f', 'rmdir /s', 'cipher /w',
            'format c:', 'diskpart', 'attrib -h', 'attrib -s',
            'ren ', 'move ', '.locked', '.encrypted'
        ]
        
        for pattern in destruction_patterns:
            if pattern in cmdline:
                indicators.append(f"File destruction/encryption command: {pattern}")
                risk_score += 20
        
        # 4.5: Shadow copy deletion (ransomware signature)
        if 'vssadmin delete shadows' in cmdline or 'wmic shadowcopy delete' in cmdline:
            indicators.append("Shadow copy deletion (ransomware signature)")
            risk_score += 30
        
        # ===== LAYER 5: SYSTEM PROCESS IMPERSONATION =====
        
        legitimate_system_processes = {
            'svchost.exe', 'lsass.exe', 'csrss.exe', 'services.exe',
            'smss.exe', 'winlogon.exe', 'explorer.exe', 'dwm.exe',
            'taskhost.exe', 'conhost.exe', 'dllhost.exe'
        }
        
        # If process name matches system process but path is suspicious
        if name in legitimate_system_processes and path and 'system32' not in path and 'syswow64' not in path:
            indicators.append(f"System process impersonation: {name}")
            risk_score += 30
        
        # ===== LAYER 5.5: PROCESS INJECTION DETECTION =====
        
        # 5.5.1: Parent-child process anomalies
        parent_child_anomalies = [
            ('explorer.exe', 'cmd.exe'),
            ('explorer.exe', 'powershell.exe'),
            ('svchost.exe', 'cmd.exe'),
            ('services.exe', 'powershell.exe'),
            ('dwm.exe', 'cmd.exe'),
            ('winlogon.exe', 'cmd.exe'),
            ('csrss.exe', 'powershell.exe')
        ]
        
        # Check if this process has suspicious parent (would need parent tracking)
        # For now, flag if process name suggests injection
        injection_indicators = [
            'injected', 'shellcode', 'payload', 'loader', 'dropper',
            'stub', 'reflective', 'process hollowing', 'dll injection'
        ]
        
        for indicator in injection_indicators:
            if indicator in name or indicator in cmdline:
                indicators.append(f"Process injection indicator: {indicator}")
                risk_score += 25
        
        # ===== LAYER 6: NETWORK BEHAVIOR + C2 DETECTION =====
        
        try:
            connections = psutil.Process(pid).net_connections()
            connection_count = 0
            
            for conn in connections:
                if conn.raddr:
                    remote_port = conn.raddr.port
                    remote_ip = conn.raddr.ip
                    connection_count += 1
                    
                    # 6.1: Suspicious port detection
                    if remote_port in self.suspicious_ports:
                        indicators.append(f"Suspicious port connection: {remote_port}")
                        risk_score += 15
                    
                    # 6.2: Listening ports (backdoor signature)
                    if conn.status == 'LISTEN':
                        if remote_port not in [80, 443, 22, 21, 25, 53, 3306, 5432]:
                            indicators.append(f"Suspicious listening port: {remote_port}")
                            risk_score += 20
                    
                    # 6.3: Private IP connections from system process (C2)
                    if remote_ip.startswith(('192.168', '10.', '172.')):
                        if name in ['svchost.exe', 'services.exe', 'lsass.exe']:
                            indicators.append(f"System process connecting to private IP: {remote_ip}")
                            risk_score += 18
            
            # 6.4: Excessive connections (botnet/scanner)
            if connection_count > 10:
                indicators.append(f"Excessive network connections: {connection_count}")
                risk_score += 12
        except:
            pass
        
        # ===== FINAL RISK ASSESSMENT =====
        
        # Cap risk score at 100
        risk_score = min(risk_score, 100)
        
        # Determine threat level
        if risk_score >= 80:
            threat_level = "CRITICAL"
            confidence = 0.95
        elif risk_score >= 60:
            threat_level = "HIGH"
            confidence = 0.85
        elif risk_score >= 40:
            threat_level = "MEDIUM"
            confidence = 0.70
        else:
            threat_level = "LOW"
            confidence = 0.50
        
        is_malicious = risk_score >= 40  # Threshold for malicious
        
        return {
            'is_malicious': is_malicious,
            'threat_level': threat_level,
            'threat_type': threat_type,
            'risk_score': risk_score,
            'indicators': indicators,
            'confidence': confidence
        }

# ============================================================================
# CONTINUOUS MONITORING LOOP
# ============================================================================

def print_header():
    """Print beautiful header"""
    print(f"\n{Back.BLUE}{Fore.WHITE}" + "="*80 + f"{Style.RESET_ALL}")
    print(f"{Back.BLUE}{Fore.WHITE}{'üõ°Ô∏è  ENHANCED PRE-ANALYZER - CONTINUOUS MONITORING üõ°Ô∏è':^80}{Style.RESET_ALL}")
    print(f"{Back.BLUE}{Fore.WHITE}" + "="*80 + f"{Style.RESET_ALL}\n")

def print_section(title):
    """Print section header"""
    print(f"\n{Back.GREEN}{Fore.BLACK} {title} {Style.RESET_ALL}")
    print(f"{Fore.GREEN}" + "-" * len(title) + f"{Style.RESET_ALL}")

def print_status(message, status_type="INFO"):
    """Print status message"""
    timestamp = datetime.now().strftime("%H:%M:%S")
    colors = {
        "INFO": Fore.CYAN,
        "SUCCESS": Fore.GREEN,
        "WARNING": Fore.YELLOW,
        "ERROR": Fore.RED,
        "CRITICAL": Fore.MAGENTA,
        "THREAT": Fore.RED,
        "DETECTED": Fore.RED + Back.YELLOW
    }
    color = colors.get(status_type, Fore.WHITE)
    print(f"{Fore.WHITE}[{timestamp}] {color}{message}{Style.RESET_ALL}")

def main():
    """Main continuous monitoring loop"""
    
    print_header()
    
    config_dir = daemon_root / "Config"
    detector = EnhancedMalwareDetector(config_dir)
    cycle = 0
    threats_found = []
    
    print_status("Initializing enhanced malware detector...", "INFO")
    print_status(f"Loaded {len(detector.whitelist)} whitelisted processes from essential_processes.txt", "SUCCESS")
    print_status("Starting continuous monitoring loop", "INFO")
    print_status("Press Ctrl+C to stop", "WARNING")
    
    try:
        while True:
            cycle += 1
            print_section(f"Scan Cycle #{cycle} - {datetime.now().strftime('%H:%M:%S')}")
            
            # Get all running processes
            processes = []
            try:
                for proc in psutil.process_iter(['pid', 'name', 'exe', 'cmdline', 'cpu_percent', 'memory_percent']):
                    try:
                        proc_info = {
                            'pid': proc.info['pid'],
                            'name': proc.info['name'],
                            'path': proc.info['exe'] or 'unknown',
                            'cmdline': ' '.join(proc.info['cmdline'] or []),
                            'cpu_percent': proc.info['cpu_percent'] or 0,
                            'memory_percent': proc.info['memory_percent'] or 0
                        }
                        processes.append(proc_info)
                    except (psutil.NoSuchProcess, psutil.AccessDenied):
                        pass
            except Exception as e:
                print_status(f"Error scanning processes: {e}", "ERROR")
                continue
            
            print_status(f"Scanned {len(processes)} processes", "INFO")
            
            # Analyze each process
            malicious_processes = []
            for proc_info in processes:
                analysis = detector.analyze_process(proc_info)
                
                if analysis['is_malicious']:
                    malicious_processes.append({
                        'pid': proc_info['pid'],
                        'name': proc_info['name'],
                        'path': proc_info['path'],
                        'analysis': analysis
                    })
            
            # Report findings
            if malicious_processes:
                print_status(f"üö® THREATS DETECTED: {len(malicious_processes)}", "DETECTED")
                
                print(f"\n{Fore.WHITE}{'PID':<8} {'Name':<30} {'Threat':<15} {'Score':<8} {'Level':<10}{Style.RESET_ALL}")
                print(f"{Fore.WHITE}" + "-" * 75 + f"{Style.RESET_ALL}")
                
                for threat in malicious_processes:
                    pid = threat['pid']
                    name = threat['name'][:29]
                    threat_type = threat['analysis']['threat_type']
                    score = threat['analysis']['risk_score']
                    level = threat['analysis']['threat_level']
                    
                    # Color by threat level
                    if level == "CRITICAL":
                        color = Fore.RED + Back.YELLOW
                    elif level == "HIGH":
                        color = Fore.RED
                    elif level == "MEDIUM":
                        color = Fore.YELLOW
                    else:
                        color = Fore.WHITE
                    
                    print(f"{color}{pid:<8} {name:<30} {threat_type:<15} {score:<8} {level:<10}{Style.RESET_ALL}")
                    
                    # Show indicators
                    for indicator in threat['analysis']['indicators'][:3]:  # Show top 3
                        print(f"{Fore.YELLOW}         ‚Üí {indicator}{Style.RESET_ALL}")
                    
                    if len(threat['analysis']['indicators']) > 3:
                        print(f"{Fore.YELLOW}         ‚Üí +{len(threat['analysis']['indicators']) - 3} more indicators{Style.RESET_ALL}")
                
                threats_found.extend(malicious_processes)
                
                # Save report
                report_dir = daemon_root / "Reports"
                report_dir.mkdir(parents=True, exist_ok=True)
                
                timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
                report_file = report_dir / f"threats_detected_{timestamp}.json"
                
                report = {
                    'timestamp': datetime.now().isoformat(),
                    'cycle': cycle,
                    'threats_found': len(malicious_processes),
                    'threats': [
                        {
                            'pid': t['pid'],
                            'name': t['name'],
                            'path': t['path'],
                            'threat_type': t['analysis']['threat_type'],
                            'risk_score': t['analysis']['risk_score'],
                            'threat_level': t['analysis']['threat_level'],
                            'indicators': t['analysis']['indicators']
                        }
                        for t in malicious_processes
                    ]
                }
                
                with open(report_file, 'w', encoding='utf-8') as f:
                    json.dump(report, f, indent=2, default=str)
                
                print_status(f"Report saved: {report_file}", "SUCCESS")
                
                # Break on threat found (or continue based on your preference)
                print_status("Threats detected! Stopping monitoring.", "WARNING")
                break
            else:
                print_status(f"‚úì No threats detected", "SUCCESS")
            
            # Wait before next cycle
            print_status("Waiting 5 seconds before next scan...", "INFO")
            time.sleep(5)
    
    except KeyboardInterrupt:
        print_status("\nMonitoring stopped by user", "WARNING")
    except Exception as e:
        print_status(f"Error: {e}", "ERROR")
        import traceback
        traceback.print_exc()
    
    # Final summary
    print_section("Monitoring Summary")
    print_status(f"Total cycles completed: {cycle}", "INFO")
    print_status(f"Total threats found: {len(threats_found)}", "INFO" if not threats_found else "THREAT")

if __name__ == "__main__":
    main()
