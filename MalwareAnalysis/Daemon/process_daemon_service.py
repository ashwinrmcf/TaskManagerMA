#!/usr/bin/env python3
"""
Process Daemon Service - Background Malware Analysis System
Runs the enhanced process daemon silently in background with tray access
"""

import sys
import os
import time
import threading
import logging
import json
import psutil
from pathlib import Path
from datetime import datetime
import win32serviceutil
import win32service
import win32event
import servicemanager

# Add current directory to path for imports
sys.path.insert(0, os.path.dirname(os.path.abspath(__file__)))

# Import the daemon logic
try:
    from process_daemon_console import ProcessDaemon
    DAEMON_AVAILABLE = True
except ImportError:
    DAEMON_AVAILABLE = False

class ProcessDaemonService(win32serviceutil.ServiceFramework):
    """Windows service that runs the Process Daemon silently in background"""
    
    _svc_name_ = "ProcessDaemonService"
    _svc_display_name_ = "Process Manager Daemon Service"
    _svc_description_ = "Silent background malware analysis daemon with real-time threat detection and termination"
    
    def __init__(self, args):
        win32serviceutil.ServiceFramework.__init__(self, args)
        self.hWaitStop = win32event.CreateEvent(None, 0, 0, None)
        self.running = False
        
        # Service configuration
        self.service_dir = Path(__file__).parent
        self.log_dir = Path(r"F:\MalwareAnalysis\Logs\DaemonService")
        self.log_dir.mkdir(parents=True, exist_ok=True)
        
        # Set up logging
        self.setup_logging()
        
        # Initialize daemon
        self.daemon = None
        
    def setup_logging(self):
        """Set up service logging"""
        log_file = self.log_dir / f"daemon_service_{datetime.now().strftime('%Y%m%d')}.log"
        
        logging.basicConfig(
            level=logging.INFO,
            format='%(asctime)s - %(levelname)s - %(message)s',
            handlers=[
                logging.FileHandler(log_file),
                logging.StreamHandler()
            ]
        )
        
        self.logger = logging.getLogger(__name__)
        
    def SvcStop(self):
        """Stop the service"""
        self.logger.info("Process Daemon Service stopping...")
        self.ReportServiceStatus(win32service.SERVICE_STOP_PENDING)
        
        # Stop the daemon
        if self.daemon:
            self.daemon.running = False
        
        self.running = False
        win32event.SetEvent(self.hWaitStop)
        
    def SvcDoRun(self):
        """Main service execution"""
        self.logger.info("Process Daemon Service starting...")
        servicemanager.LogMsg(
            servicemanager.EVENTLOG_INFORMATION_TYPE,
            servicemanager.PYS_SERVICE_STARTED,
            (self._svc_name_, '')
        )
        
        self.running = True
        self.main_service_loop()
        
    def main_service_loop(self):
        """Main service loop running the daemon"""
        try:
            if not DAEMON_AVAILABLE:
                self.logger.error("Process Daemon not available - service cannot start")
                return
            
            self.logger.info("Initializing Process Daemon...")
            
            # Create daemon instance with service mode
            self.daemon = ProcessDaemonServiceWrapper()
            
            self.logger.info("Process Daemon Service started successfully")
            
            # Run daemon in background
            daemon_thread = threading.Thread(target=self.run_daemon, daemon=True)
            daemon_thread.start()
            
            # Service status monitoring
            status_interval = 30  # seconds
            last_status_time = time.time()
            
            while self.running:
                # Check if we should stop
                if win32event.WaitForSingleObject(self.hWaitStop, 1000) == win32event.WAIT_OBJECT_0:
                    break
                
                # Periodic status logging
                current_time = time.time()
                if current_time - last_status_time >= status_interval:
                    self.log_service_status()
                    last_status_time = current_time
                
                time.sleep(1)
                
        except Exception as e:
            self.logger.error(f"Service error: {e}")
            servicemanager.LogErrorMsg(f"Process Daemon Service error: {e}")
        finally:
            self.logger.info("Process Daemon Service stopped")
            
    def run_daemon(self):
        """Run the daemon in background"""
        try:
            self.logger.info("Starting daemon monitoring loop...")
            self.daemon.run_silent_monitoring()
        except Exception as e:
            self.logger.error(f"Daemon error: {e}")
            
    def log_service_status(self):
        """Log service status"""
        try:
            # Get system stats
            cpu_percent = psutil.cpu_percent(interval=1)
            memory = psutil.virtual_memory()
            
            status = {
                'timestamp': datetime.now().isoformat(),
                'service_running': self.running,
                'daemon_running': self.daemon.running if self.daemon else False,
                'cpu_percent': cpu_percent,
                'memory_percent': memory.percent,
                'threats_detected': self.daemon.threats_detected if self.daemon else 0,
                'threats_eliminated': self.daemon.threats_eliminated if self.daemon else 0
            }
            
            # Write status to file for tray app
            status_file = self.service_dir / "daemon_service_status.json"
            with open(status_file, 'w') as f:
                json.dump(status, f, indent=2)
                
            self.logger.info(f"Service status: CPU {cpu_percent}%, Memory {memory.percent}%, "
                           f"Threats: {status['threats_detected']}/{status['threats_eliminated']}")
                           
        except Exception as e:
            self.logger.error(f"Status logging error: {e}")

class ProcessDaemonServiceWrapper:
    """Wrapper for ProcessDaemon to run as a service"""
    
    def __init__(self):
        self.running = False
        self.threats_detected = 0
        self.threats_eliminated = 0
        self.daemon_instance = None
        
    def run_silent_monitoring(self):
        """Run daemon monitoring silently"""
        try:
            # Import and create daemon
            if DAEMON_AVAILABLE:
                # Create a modified daemon for service mode
                self.daemon_instance = SilentProcessDaemon()
                self.running = True
                
                # Run the daemon
                self.daemon_instance.run_service_mode()
                
        except Exception as e:
            logging.error(f"Silent monitoring error: {e}")

class SilentProcessDaemon:
    """Silent version of ProcessDaemon for service mode"""
    
    def __init__(self):
        self.running = True
        self.threats_detected = 0
        self.threats_eliminated = 0
        
        # Tray notification system
        self.tray_notification_file = Path(__file__).parent / "daemon_notifications.json"
        
        # Initialize components silently
        self.initialize_silent_components()
        
    def initialize_silent_components(self):
        """Initialize daemon components for silent operation"""
        try:
            # Import real components
            from process_manager_gui import load_essential_processes
            
            # Load essential processes
            self.essential_processes = set()
            self.malware_patterns = set()
            
            script_dir = Path(__file__).parent
            essential_file = script_dir / "essential_processes.txt"
            
            if essential_file.exists():
                essential_data = load_essential_processes(str(essential_file))
                if essential_data:
                    self.essential_processes = essential_data.get('essential_processes', set())
                    self.malware_patterns = essential_data.get('malware_patterns', set())
                    
            logging.info(f"Loaded {len(self.essential_processes)} essential processes, "
                        f"{len(self.malware_patterns)} malware patterns")
                        
        except Exception as e:
            logging.error(f"Component initialization error: {e}")
            
    def run_service_mode(self):
        """Run daemon in service mode (silent)"""
        logging.info("Process Daemon running in service mode...")
        
        scan_interval = 60  # Start with 60 seconds
        
        while self.running:
            try:
                # Perform threat scan
                threats_found = self.scan_for_threats()
                
                if threats_found:
                    logging.info(f"Threats detected: {len(threats_found)}")
                    self.threats_detected += len(threats_found)
                    
                    # Terminate threats
                    eliminated = self.terminate_threats(threats_found)
                    self.threats_eliminated += eliminated
                    
                    # Faster scanning after threats
                    scan_interval = 10
                    
                else:
                    # Gradual return to normal interval
                    scan_interval = min(scan_interval + 10, 60)
                
                # Wait for next scan
                for i in range(scan_interval):
                    if not self.running:
                        break
                    time.sleep(1)
                    
            except Exception as e:
                logging.error(f"Service scan error: {e}")
                time.sleep(30)  # Wait before retry
                
    def scan_for_threats(self):
        """Scan for threats silently"""
        threats = []
        
        try:
            for proc in psutil.process_iter(['pid', 'name', 'cmdline']):
                try:
                    pinfo = proc.info
                    proc_name = pinfo['name'].lower() if pinfo['name'] else 'unknown'
                    
                    # Skip essential processes
                    if proc_name in self.essential_processes:
                        continue
                    
                    # Check for malware patterns
                    if proc_name in self.malware_patterns:
                        threats.append({
                            'pid': pinfo['pid'],
                            'name': proc_name,
                            'risk': 'CRITICAL'
                        })
                        continue
                    
                    # Check for suspicious patterns
                    suspicious_keywords = ['ransom', 'crypt', 'trojan', 'virus', 'malware']
                    for keyword in suspicious_keywords:
                        if keyword in proc_name:
                            threats.append({
                                'pid': pinfo['pid'],
                                'name': proc_name,
                                'risk': 'HIGH'
                            })
                            break
                            
                except (psutil.NoSuchProcess, psutil.AccessDenied):
                    continue
                    
        except Exception as e:
            logging.error(f"Threat scan error: {e}")
            
        return threats
        
    def terminate_threats(self, threats):
        """Terminate detected threats and send tray notifications"""
        eliminated = 0
        
        for threat in threats:
            try:
                pid = threat['pid']
                name = threat['name']
                risk = threat['risk']
                
                # Terminate process
                proc = psutil.Process(pid)
                proc.terminate()
                proc.wait(timeout=5)
                
                eliminated += 1
                logging.info(f"Terminated threat: {name} (PID: {pid})")
                
                # Send tray notification
                self.send_tray_notification(
                    title="ðŸ›¡ï¸ Threat Eliminated",
                    message=f"Killed {risk} threat: {name}",
                    threat_type=risk,
                    process_name=name,
                    pid=pid
                )
                
            except Exception as e:
                logging.error(f"Failed to terminate {name}: {e}")
                
        # Send summary notification if multiple threats
        if eliminated > 1:
            self.send_tray_notification(
                title="ðŸš¨ Multiple Threats Eliminated",
                message=f"Successfully terminated {eliminated} malicious processes",
                threat_type="SUMMARY",
                process_name="Multiple",
                pid=0
            )
                
        return eliminated
    
    def send_tray_notification(self, title, message, threat_type, process_name, pid):
        """Send notification to tray app"""
        try:
            notification = {
                'timestamp': datetime.now().isoformat(),
                'title': title,
                'message': message,
                'threat_type': threat_type,
                'process_name': process_name,
                'pid': pid,
                'read': False
            }
            
            # Load existing notifications
            notifications = []
            if self.tray_notification_file.exists():
                try:
                    with open(self.tray_notification_file, 'r') as f:
                        notifications = json.load(f)
                except:
                    notifications = []
            
            # Add new notification
            notifications.append(notification)
            
            # Keep only last 50 notifications
            notifications = notifications[-50:]
            
            # Save notifications
            with open(self.tray_notification_file, 'w') as f:
                json.dump(notifications, f, indent=2)
                
            logging.info(f"Tray notification sent: {title} - {message}")
            
        except Exception as e:
            logging.error(f"Failed to send tray notification: {e}")

def main():
    """Main entry point"""
    if len(sys.argv) == 1:
        servicemanager.Initialize()
        servicemanager.PrepareToHostSingle(ProcessDaemonService)
        servicemanager.StartServiceCtrlDispatcher()
    else:
        win32serviceutil.HandleCommandLine(ProcessDaemonService)

if __name__ == '__main__':
    main()
