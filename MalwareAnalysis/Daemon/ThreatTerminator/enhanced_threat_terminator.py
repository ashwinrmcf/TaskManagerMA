#!/usr/bin/env python3
"""
ENHANCED THREAT TERMINATOR - Intelligent File-Based Threat Elimination
Investigates malicious files, finds related threats, and safely quarantines them
Uses PreAnalyzer detection logic for intelligent threat identification
"""

import sys
import json
import os
import shutil
import subprocess
import psutil
import hashlib
import re
from pathlib import Path
from datetime import datetime
from colorama import init, Fore, Back, Style

init(autoreset=True)

daemon_root = Path(__file__).parent.parent
sys.path.insert(0, str(daemon_root))

# Import PreAnalyzer for detection logic
try:
    from PreAnalyzer.enhanced_pre_analyzer_monitor import EnhancedMalwareDetector
    PREANALYZER_AVAILABLE = True
except ImportError:
    PREANALYZER_AVAILABLE = False

# ============================================================================
# ENHANCED THREAT TERMINATOR - FILE-BASED THREAT ELIMINATION
# ============================================================================

class EnhancedThreatTerminator:
    """Intelligent threat elimination focusing on malicious files"""
    
    def __init__(self, config_dir: Path = None):
        """Initialize enhanced terminator"""
        self.config_dir = config_dir or daemon_root / "Config"
        self.reports_dir = daemon_root / "Reports"
        self.logs_dir = daemon_root / "Logs" / "threat_termination"
        self.quarantine_dir = daemon_root / "Quarantine"
        
        # Create directories
        self.logs_dir.mkdir(parents=True, exist_ok=True)
        self.quarantine_dir.mkdir(parents=True, exist_ok=True)
        
        # Load safety lists
        self.system_files = self._load_system_files()
        self.essential_processes = self._load_essential_processes()
        self.daemon_files = self._load_daemon_files()
        
        # Initialize PreAnalyzer if available
        if PREANALYZER_AVAILABLE:
            self.detector = EnhancedMalwareDetector(self.config_dir)
        else:
            self.detector = None
        
        # Logs
        self.action_log = []
        self.quarantine_log = []
        self.skipped_log = []
        self.related_threats = []
    
    def _load_system_files(self) -> set:
        """Protected system files and directories"""
        return {
            # Windows directories
            'c:\\windows', 'c:\\programfiles', 'c:\\program files (x86)',
            'c:\\programdata\\microsoft', 'c:\\windows\\system32',
            'c:\\windows\\syswow64', 'c:\\windows\\drivers',
            'c:\\windows\\winsxs', 'c:\\windows\\servicing',
            
            # Critical system files
            'ntoskrnl.exe', 'hal.dll', 'kernel32.dll', 'ntdll.dll',
            'csrss.exe', 'smss.exe', 'services.exe', 'lsass.exe',
            'svchost.exe', 'explorer.exe', 'dwm.exe', 'winlogon.exe',
            
            # Registry
            'c:\\windows\\system32\\config',
            
            # Boot files
            'bootmgr', 'boot.ini', 'ntldr',
        }
    
    def _load_essential_processes(self) -> set:
        """Load essential processes from whitelist"""
        essential = set()
        whitelist_file = self.config_dir / "essential_processes.txt"
        
        if whitelist_file.exists():
            try:
                with open(whitelist_file, 'r', encoding='utf-8') as f:
                    for line in f:
                        line = line.strip().lower()
                        if line and not line.startswith('#') and not line.startswith('!'):
                            essential.add(line)
            except Exception as e:
                print(f"Error loading essential processes: {e}")
        
        return essential
    
    def _load_daemon_files(self) -> set:
        """Daemon files that must NEVER be deleted"""
        return {
            'f:\\malwareanalysis\\daemon',
            'enhanced_pre_analyzer_monitor.py',
            'process_daemon_console.py',
            'threat_terminator.py',
            'enhanced_threat_terminator.py',
        }
    
    # ========================================================================
    # 10-LAYER DETECTION ENGINE
    # ========================================================================
    
    def detect_layer1_file_signatures(self, file_path: str) -> list:
        """Layer 1: File Signature Detection"""
        threats = []
        file_name = Path(file_path).name.lower()
        
        signatures = {
            'ransomware': ['ransomware', 'encrypt', 'decrypt', 'payment', 'bitcoin'],
            'trojan': ['trojan', 'backdoor', 'remote', 'shell', 'payload'],
            'spyware': ['spy', 'keylog', 'monitor', 'capture', 'steal'],
            'rootkit': ['rootkit', 'kernel', 'hook', 'driver'],
            'worm': ['worm', 'propagate', 'spread', 'replicate'],
        }
        
        try:
            with open(file_path, 'rb') as f:
                content = f.read(500000).decode('utf-8', errors='ignore').lower()
            
            for malware_type, keywords in signatures.items():
                for keyword in keywords:
                    if keyword in file_name or keyword in content:
                        threats.append({
                            'layer': 1,
                            'type': f'SIGNATURE_{malware_type.upper()}',
                            'severity': 'HIGH',
                            'indicator': keyword
                        })
        except:
            pass
        
        return threats
    
    def detect_layer2_network_based(self, file_path: str) -> list:
        """Layer 2: Network-Based Detection"""
        threats = []
        c2_ips = ['185.220.101', '188.166', '195.154', '198.51.100', '199.192.112']
        c2_ports = [4444, 5555, 6666, 7777, 8888, 9999, 1337, 31337, 9050, 9051]
        
        try:
            with open(file_path, 'rb') as f:
                content = f.read(500000).decode('utf-8', errors='ignore').lower()
            
            for ip in c2_ips:
                if ip in content:
                    threats.append({
                        'layer': 2,
                        'type': 'C2_IP_PATTERN',
                        'severity': 'CRITICAL',
                        'indicator': ip
                    })
            
            for port in c2_ports:
                if str(port) in content:
                    threats.append({
                        'layer': 2,
                        'type': 'C2_PORT_PATTERN',
                        'severity': 'HIGH',
                        'indicator': str(port)
                    })
        except:
            pass
        
        return threats
    
    def detect_layer3_activity_based(self, file_path: str) -> list:
        """Layer 3: Activity-Based Detection"""
        threats = []
        activities = {
            'file_ops': ['del ', 'rmdir', 'format', 'cipher', 'vssadmin', 'wbadmin'],
            'registry_ops': ['hklm\\run', 'hkcu\\run', 'currentversion'],
            'process_ops': ['createremotethread', 'writeprocessmemory', 'runas'],
            'network_ops': ['socket', 'connect', 'send', 'recv', 'ftp', 'http'],
        }
        
        try:
            with open(file_path, 'rb') as f:
                content = f.read(500000).decode('utf-8', errors='ignore').lower()
            
            for activity_type, patterns in activities.items():
                for pattern in patterns:
                    if pattern in content:
                        threats.append({
                            'layer': 3,
                            'type': f'ACTIVITY_{activity_type.upper()}',
                            'severity': 'HIGH',
                            'indicator': pattern
                        })
        except:
            pass
        
        return threats
    
    def detect_layer4_behavioral(self, file_path: str) -> list:
        """Layer 4: Behavioral Pattern Detection"""
        threats = []
        patterns = [
            (r'(\d+\.\d+\.\d+\.\d+):(\d+)', 'C2_BEACONING'),
            (r'(POST|PUT|GET).*\?.*=', 'DATA_EXFILTRATION'),
            (r'(base64|encoded|obfuscated)', 'COMMAND_OBFUSCATION'),
        ]
        
        try:
            with open(file_path, 'rb') as f:
                content = f.read(500000).decode('utf-8', errors='ignore')
            
            for pattern, threat_type in patterns:
                if re.search(pattern, content, re.IGNORECASE):
                    threats.append({
                        'layer': 4,
                        'type': threat_type,
                        'severity': 'CRITICAL',
                        'indicator': pattern
                    })
        except:
            pass
        
        return threats
    
    def detect_layer5_heuristic(self, file_path: str) -> list:
        """Layer 5: Heuristic Analysis"""
        threats = []
        
        try:
            stat = Path(file_path).stat()
            
            if stat.st_size > 100 * 1024 * 1024:
                threats.append({
                    'layer': 5,
                    'type': 'SUSPICIOUS_SIZE',
                    'severity': 'MEDIUM',
                    'indicator': f'{stat.st_size} bytes'
                })
            
            if stat.st_mode & 0o111:
                threats.append({
                    'layer': 5,
                    'type': 'EXECUTABLE_FILE',
                    'severity': 'MEDIUM',
                    'indicator': 'executable'
                })
        except:
            pass
        
        return threats
    
    def detect_layer6_hash_based(self, file_path: str) -> list:
        """Layer 6: Hash-Based Detection"""
        threats = []
        
        try:
            sha256 = hashlib.sha256()
            with open(file_path, 'rb') as f:
                for chunk in iter(lambda: f.read(4096), b''):
                    sha256.update(chunk)
            
            file_hash = sha256.hexdigest()
            
            # Known malware hashes (example)
            known_hashes = {
                'a' * 64: 'Ransomware.Generic',
                'b' * 64: 'Trojan.Generic',
            }
            
            if file_hash in known_hashes:
                threats.append({
                    'layer': 6,
                    'type': 'KNOWN_MALWARE_HASH',
                    'severity': 'CRITICAL',
                    'indicator': file_hash[:16] + '...'
                })
        except:
            pass
        
        return threats
    
    def detect_layer7_packer(self, file_path: str) -> list:
        """Layer 7: Packer Detection"""
        threats = []
        packers = {b'UPX': 'UPX', b'ASPack': 'ASPack', b'Themida': 'Themida'}
        
        try:
            with open(file_path, 'rb') as f:
                content = f.read(1000)
            
            for sig, name in packers.items():
                if sig in content:
                    threats.append({
                        'layer': 7,
                        'type': 'PACKED_EXECUTABLE',
                        'severity': 'MEDIUM',
                        'indicator': name
                    })
        except:
            pass
        
        return threats
    
    def detect_layer8_anomaly(self, file_path: str) -> list:
        """Layer 8: Anomaly Detection"""
        threats = []
        file_name = Path(file_path).name.lower()
        
        if file_name.count('.') > 1:
            threats.append({
                'layer': 8,
                'type': 'DOUBLE_EXTENSION',
                'severity': 'MEDIUM',
                'indicator': file_name
            })
        
        if file_name.startswith('.'):
            threats.append({
                'layer': 8,
                'type': 'HIDDEN_FILE',
                'severity': 'MEDIUM',
                'indicator': file_name
            })
        
        return threats
    
    def detect_layer9_context(self, file_path: str) -> list:
        """Layer 9: Context-Based Detection"""
        threats = []
        suspicious_locs = ['temp', 'appdata', 'cache', 'cookies', 'recent', 'startup']
        
        path_lower = str(file_path).lower()
        for loc in suspicious_locs:
            if loc in path_lower:
                threats.append({
                    'layer': 9,
                    'type': 'SUSPICIOUS_LOCATION',
                    'severity': 'MEDIUM',
                    'indicator': loc
                })
        
        return threats
    
    def detect_layer10_preanalyzer(self, file_path: str) -> list:
        """Layer 10: PreAnalyzer Detection"""
        threats = []
        
        if not self.detector:
            return threats
        
        try:
            analysis = self.detector.analyze_process({
                'name': Path(file_path).name,
                'path': str(file_path),
                'cmdline': str(file_path),
                'pid': 0,
                'cpu_percent': 0,
                'memory_percent': 0
            })
            
            if analysis.get('is_malicious'):
                threats.append({
                    'layer': 10,
                    'type': analysis.get('threat_type'),
                    'severity': analysis.get('threat_level'),
                    'indicator': f"Risk: {analysis.get('risk_score')}/100"
                })
        except:
            pass
        
        return threats
    
    def run_all_detection_layers(self, file_path: str) -> dict:
        """Run all 10 detection layers"""
        print(f"\n{Fore.CYAN}{'='*80}")
        print(f"10-LAYER THREAT DETECTION ANALYSIS")
        print(f"{'='*80}\n")
        
        all_threats = []
        layer_results = {}
        
        layers = [
            (self.detect_layer1_file_signatures, "File Signature Detection"),
            (self.detect_layer2_network_based, "Network-Based Detection"),
            (self.detect_layer3_activity_based, "Activity-Based Detection"),
            (self.detect_layer4_behavioral, "Behavioral Pattern Detection"),
            (self.detect_layer5_heuristic, "Heuristic Analysis"),
            (self.detect_layer6_hash_based, "Hash-Based Detection"),
            (self.detect_layer7_packer, "Packer Detection"),
            (self.detect_layer8_anomaly, "Anomaly Detection"),
            (self.detect_layer9_context, "Context-Based Detection"),
            (self.detect_layer10_preanalyzer, "PreAnalyzer Detection"),
        ]
        
        for layer_func, layer_name in layers:
            threats = layer_func(file_path)
            layer_results[layer_name] = threats
            all_threats.extend(threats)
            print(f"{Fore.YELLOW}[{layer_name}] Found: {len(threats)} threat(s)")
        
        print(f"\n{Fore.GREEN}Total Threats Detected: {len(all_threats)}")
        
        return {
            'total_threats': len(all_threats),
            'layer_results': layer_results,
            'all_threats': all_threats
        }
    
    def is_system_file(self, file_path: str) -> bool:
        """Check if file is a protected system file"""
        path_lower = str(file_path).lower()
        
        # Check against protected directories
        for protected in self.system_files:
            if protected in path_lower:
                return True
        
        # Check against daemon files
        for daemon_file in self.daemon_files:
            if daemon_file in path_lower:
                return True
        
        return False
    
    # ========================================================================
    # MALWARE IN SYSTEM PROTECTION - 5-STEP VERIFICATION
    # ========================================================================
    
    def verify_file_hash(self, file_path: str) -> tuple:
        """Step 1: Hash Verification - Compare against known legitimate hashes"""
        try:
            sha256 = hashlib.sha256()
            with open(file_path, 'rb') as f:
                for chunk in iter(lambda: f.read(4096), b''):
                    sha256.update(chunk)
            
            file_hash = sha256.hexdigest()
            
            # Known legitimate Windows file hashes (example)
            legitimate_hashes = {
                'kernel32.dll': ['a1b2c3d4e5f6', 'b2c3d4e5f6g7'],
                'ntdll.dll': ['x9y8z7w6v5u4', 'y8z7w6v5u4t3'],
                'csrss.exe': ['p1q2r3s4t5u6', 'q2r3s4t5u6v7'],
            }
            
            file_name = Path(file_path).name.lower()
            expected_hashes = legitimate_hashes.get(file_name, [])
            
            if file_hash[:12] in expected_hashes:
                return True, "✅ Hash matches legitimate file"
            elif expected_hashes:
                return False, f"❌ Hash mismatch - likely malware"
            else:
                return None, "⚠️  No hash database entry"
        except:
            return None, "⚠️  Could not calculate hash"
    
    def verify_file_location(self, file_path: str) -> tuple:
        """Step 2: Location Verification - Check if file is in correct directory"""
        file_name = Path(file_path).name.lower()
        actual_location = str(Path(file_path).parent).lower()
        
        # Legitimate locations for system files
        legitimate_locations = {
            'kernel32.dll': ['c:\\windows\\system32', 'c:\\windows\\syswow64'],
            'ntdll.dll': ['c:\\windows\\system32', 'c:\\windows\\syswow64'],
            'csrss.exe': ['c:\\windows\\system32'],
            'svchost.exe': ['c:\\windows\\system32'],
            'explorer.exe': ['c:\\windows'],
        }
        
        expected_locations = legitimate_locations.get(file_name, [])
        
        if not expected_locations:
            return None, "⚠️  Unknown file"
        
        for expected in expected_locations:
            if actual_location == expected:
                return True, f"✅ Correct location: {actual_location}"
        
        return False, f"❌ Wrong location - found in {actual_location}, expected {expected_locations}"
    
    def verify_file_metadata(self, file_path: str) -> tuple:
        """Step 3: Metadata Verification - Check file metadata"""
        file_name = Path(file_path).name.lower()
        
        # Legitimate metadata for system files
        legitimate_metadata = {
            'kernel32.dll': 'Microsoft Corporation',
            'ntdll.dll': 'Microsoft Corporation',
            'csrss.exe': 'Microsoft Corporation',
            'svchost.exe': 'Microsoft Corporation',
            'explorer.exe': 'Microsoft Corporation',
        }
        
        expected_company = legitimate_metadata.get(file_name)
        
        if not expected_company:
            return None, "⚠️  Unknown file"
        
        try:
            # Try to read file metadata (simplified check)
            with open(file_path, 'rb') as f:
                content = f.read(1000).decode('utf-8', errors='ignore')
            
            if 'Microsoft' in content or 'Windows' in content:
                return True, "✅ Metadata appears legitimate"
            else:
                return False, "❌ Metadata mismatch - likely malware"
        except:
            return None, "⚠️  Could not read metadata"
    
    def verify_file_behavior(self, file_path: str) -> tuple:
        """Step 4: Behavioral Analysis - Check for suspicious imports"""
        suspicious_patterns = [
            'WinExec', 'CreateRemoteThread', 'WriteProcessMemory',
            'SetWindowsHookEx', 'RegSetValueEx', 'DeleteFileA',
            'CreateServiceA', 'CreateProcessA', 'ShellExecute',
        ]
        
        try:
            with open(file_path, 'rb') as f:
                content = f.read(100000).decode('utf-8', errors='ignore').upper()
            
            found_suspicious = []
            for pattern in suspicious_patterns:
                if pattern.upper() in content:
                    found_suspicious.append(pattern)
            
            if found_suspicious:
                return False, f"❌ Suspicious behavior - uses {found_suspicious[:3]}"
            else:
                return True, "✅ No suspicious behavior detected"
        except:
            return None, "⚠️  Could not analyze behavior"
    
    def comprehensive_file_verification(self, file_path: str) -> tuple:
        """Run 5-step verification for files in protected locations"""
        print(f"\n{Fore.YELLOW}⚠️  COMPREHENSIVE FILE VERIFICATION")
        print(f"File: {file_path}\n")
        
        file_name = Path(file_path).name
        
        # Step 1: Hash Verification
        hash_result, hash_msg = self.verify_file_hash(file_path)
        print(f"[1/4] Hash Verification: {hash_msg}")
        if hash_result is True:
            return True, "Legitimate file - hash verified"
        
        # Step 2: Location Verification
        loc_result, loc_msg = self.verify_file_location(file_path)
        print(f"[2/4] Location Verification: {loc_msg}")
        if loc_result is False:
            return False, "Malware - wrong location"
        
        # Step 3: Metadata Verification
        meta_result, meta_msg = self.verify_file_metadata(file_path)
        print(f"[3/4] Metadata Verification: {meta_msg}")
        if meta_result is False:
            return False, "Malware - metadata mismatch"
        
        # Step 4: Behavioral Analysis
        behav_result, behav_msg = self.verify_file_behavior(file_path)
        print(f"[4/4] Behavioral Analysis: {behav_msg}")
        if behav_result is False:
            return False, "Malware - suspicious behavior"
        
        # All checks passed or inconclusive
        if hash_result is False or loc_result is False or meta_result is False or behav_result is False:
            return False, "Malware - verification failed"
        
        return True, "Legitimate file - all checks passed"
    
    def is_daemon_file(self, file_path: str) -> bool:
        """Check if file belongs to daemon"""
        path_lower = str(file_path).lower()
        for daemon_file in self.daemon_files:
            if daemon_file in path_lower:
                return True
        return False
    
    def calculate_file_hash(self, file_path: str) -> str:
        """Calculate SHA256 hash of file"""
        try:
            sha256_hash = hashlib.sha256()
            with open(file_path, "rb") as f:
                for byte_block in iter(lambda: f.read(4096), b""):
                    sha256_hash.update(byte_block)
            return sha256_hash.hexdigest()
        except Exception as e:
            return ""
    
    def analyze_file_with_preanalyzer(self, file_path: str) -> dict:
        """Use PreAnalyzer to analyze file"""
        if not self.detector:
            return {'is_malicious': False, 'threat_level': 'SAFE'}
        
        try:
            # Get file info
            file_name = Path(file_path).name
            file_path_str = str(file_path)
            
            # Create process info dict for PreAnalyzer
            proc_info = {
                'name': file_name,
                'path': file_path_str,
                'cmdline': file_path_str,
                'pid': 0,
                'cpu_percent': 0,
                'memory_percent': 0
            }
            
            # Analyze with PreAnalyzer
            result = self.detector.analyze_process(proc_info)
            return result
        except Exception as e:
            print(f"Error analyzing file with PreAnalyzer: {e}")
            return {'is_malicious': False, 'threat_level': 'SAFE'}
    
    def find_related_files(self, malicious_file: str, search_dir: str = None) -> list:
        """Find related malicious files in the system"""
        related = []
        
        if not search_dir:
            search_dir = "f:\\MalwareAnalysis"
        
        search_path = Path(search_dir)
        if not search_path.exists():
            return related
        
        malicious_name = Path(malicious_file).stem.lower()
        
        try:
            # Search for files with similar names
            for file_path in search_path.rglob("*"):
                if not file_path.is_file():
                    continue
                
                # Skip system files
                if self.is_system_file(str(file_path)):
                    continue
                
                file_name = file_path.name.lower()
                
                # Check for similar names or known malware patterns
                if (malicious_name in file_name or 
                    file_name in malicious_name or
                    'ransomware' in file_name or
                    'malware' in file_name or
                    'trojan' in file_name or
                    'virus' in file_name):
                    
                    # Analyze with PreAnalyzer
                    analysis = self.analyze_file_with_preanalyzer(str(file_path))
                    
                    if analysis.get('is_malicious'):
                        related.append({
                            'path': str(file_path),
                            'name': file_name,
                            'threat_level': analysis.get('threat_level'),
                            'threat_type': analysis.get('threat_type'),
                            'risk_score': analysis.get('risk_score'),
                            'indicators': analysis.get('indicators', [])
                        })
        except Exception as e:
            print(f"Error finding related files: {e}")
        
        return related
    
    def quarantine_file(self, file_path: str, threat_info: dict = None) -> bool:
        """Safely quarantine a malicious file"""
        try:
            file_path = Path(file_path)
            
            if not file_path.exists():
                self.skipped_log.append(f"File not found: {file_path}")
                return False
            
            # Check if system file
            if self.is_system_file(str(file_path)):
                self.skipped_log.append(f"PROTECTED: System file - {file_path}")
                return False
            
            # Check if daemon file
            if self.is_daemon_file(str(file_path)):
                self.skipped_log.append(f"PROTECTED: Daemon file - {file_path}")
                return False
            
            # Create quarantine directory with timestamp
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            quarantine_subdir = self.quarantine_dir / f"quarantine_{timestamp}_{file_path.stem}"
            quarantine_subdir.mkdir(parents=True, exist_ok=True)
            
            # Copy file to quarantine
            quarantine_path = quarantine_subdir / file_path.name
            shutil.copy2(file_path, quarantine_path)
            
            # Delete original
            file_path.unlink()
            
            # Log action
            log_entry = {
                'timestamp': datetime.now().isoformat(),
                'action': 'QUARANTINE',
                'file': str(file_path),
                'quarantine_location': str(quarantine_path),
                'threat_info': threat_info or {}
            }
            self.quarantine_log.append(log_entry)
            self.action_log.append(log_entry)
            
            print(f"{Fore.GREEN}✓ QUARANTINED: {file_path.name}")
            print(f"  Location: {quarantine_path}")
            
            return True
        
        except Exception as e:
            self.skipped_log.append(f"Error quarantining {file_path}: {e}")
            print(f"{Fore.RED}✗ Error quarantining file: {e}")
            return False
    
    def investigate_and_eliminate(self, malicious_file: str) -> dict:
        """
        Investigate malicious file and eliminate it and related threats
        """
        print(f"\n{Fore.CYAN}{'='*80}")
        print(f"ENHANCED THREAT INVESTIGATION AND ELIMINATION")
        print(f"{'='*80}\n")
        
        # Step 1: Analyze the malicious file
        print(f"{Fore.YELLOW}[STEP 1] Analyzing malicious file...")
        print(f"-" * 80)
        
        file_path = Path(malicious_file)
        
        if not file_path.exists():
            print(f"{Fore.RED}✗ File not found: {malicious_file}")
            return {'status': 'failed', 'reason': 'File not found'}
        
        print(f"File: {file_path.name}")
        print(f"Path: {file_path}")
        print(f"Size: {file_path.stat().st_size} bytes")
        print(f"Hash: {self.calculate_file_hash(str(file_path))}")
        
        # Analyze with PreAnalyzer
        analysis = self.analyze_file_with_preanalyzer(str(file_path))
        print(f"Threat Level: {analysis.get('threat_level')}")
        print(f"Threat Type: {analysis.get('threat_type')}")
        print(f"Risk Score: {analysis.get('risk_score')}/100")
        
        if analysis.get('indicators'):
            print(f"Indicators:")
            for indicator in analysis.get('indicators', [])[:5]:
                print(f"  • {indicator}")
        
        # Step 2: Find related threats
        print(f"\n{Fore.YELLOW}[STEP 2] Searching for related malicious files...")
        print(f"-" * 80)
        
        related_files = self.find_related_files(str(file_path))
        
        if related_files:
            print(f"Found {len(related_files)} related threat(s):")
            for i, related in enumerate(related_files, 1):
                print(f"  {i}. {related['name']}")
                print(f"     Threat: {related['threat_type']} [{related['threat_level']}]")
                print(f"     Risk: {related['risk_score']}/100")
            self.related_threats = related_files
        else:
            print(f"No related threats found")
        
        # Step 3: Quarantine threats
        print(f"\n{Fore.YELLOW}[STEP 3] Quarantining threats...")
        print(f"-" * 80)
        
        quarantined_count = 0
        
        # Quarantine main threat
        threat_info = {
            'type': analysis.get('threat_type'),
            'level': analysis.get('threat_level'),
            'risk_score': analysis.get('risk_score'),
            'indicators': analysis.get('indicators', [])
        }
        
        if self.quarantine_file(str(file_path), threat_info):
            quarantined_count += 1
        
        # Quarantine related threats
        for related in related_files:
            if self.quarantine_file(related['path'], related):
                quarantined_count += 1
        
        # Step 4: Generate report
        print(f"\n{Fore.CYAN}{'='*80}")
        print(f"ELIMINATION REPORT")
        print(f"{'='*80}\n")
        
        print(f"Main Threat: {file_path.name}")
        print(f"Threat Type: {analysis.get('threat_type')}")
        print(f"Threat Level: {analysis.get('threat_level')}")
        print(f"Related Threats Found: {len(related_files)}")
        print(f"Files Quarantined: {quarantined_count}")
        print(f"Files Skipped (Protected): {len(self.skipped_log)}")
        
        if self.skipped_log:
            print(f"\nProtected Files (Not Touched):")
            for skip in self.skipped_log[-5:]:
                print(f"  • {skip}")
        
        # Save report
        report = {
            'timestamp': datetime.now().isoformat(),
            'main_threat': {
                'file': str(file_path),
                'name': file_path.name,
                'threat_type': analysis.get('threat_type'),
                'threat_level': analysis.get('threat_level'),
                'risk_score': analysis.get('risk_score'),
                'indicators': analysis.get('indicators', [])
            },
            'related_threats': related_files,
            'quarantined_count': quarantined_count,
            'action_log': self.action_log,
            'quarantine_log': self.quarantine_log,
            'skipped_log': self.skipped_log
        }
        
        report_file = self.logs_dir / f"elimination_report_{datetime.now().strftime('%Y%m%d_%H%M%S')}.json"
        with open(report_file, 'w', encoding='utf-8') as f:
            json.dump(report, f, indent=2)
        
        print(f"\nReport saved: {report_file}")
        
        return {
            'status': 'success',
            'main_threat': file_path.name,
            'related_threats': len(related_files),
            'quarantined': quarantined_count,
            'report': str(report_file)
        }


def main():
    """Test enhanced threat terminator"""
    terminator = EnhancedThreatTerminator()
    
    # Test on the quarantined file from PreAnalyzer
    test_file = "f:\\MalwareAnalysis\\ProcessManager\\ransomware_test.py"
    
    if Path(test_file).exists():
        result = terminator.investigate_and_eliminate(test_file)
        print(f"\n{Fore.GREEN}Result: {result['status']}")
    else:
        print(f"{Fore.YELLOW}Test file not found (already quarantined): {test_file}")
        print(f"This is expected - PreAnalyzer already quarantined it")


if __name__ == "__main__":
    main()
