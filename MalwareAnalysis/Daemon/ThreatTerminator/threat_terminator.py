#!/usr/bin/env python3
"""
THREAT TERMINATOR - Advanced Threat Elimination Module
Reads Volatility analysis reports and safely eliminates threats
Multiple safety layers to prevent accidental system damage
"""

import sys
import json
import os
import shutil
import subprocess
import psutil
from pathlib import Path
from datetime import datetime
from colorama import init, Fore, Back, Style

init(autoreset=True)

daemon_root = Path(__file__).parent.parent
sys.path.insert(0, str(daemon_root))

# ============================================================================
# THREAT TERMINATOR - SAFE THREAT ELIMINATION
# ============================================================================

class ThreatTerminator:
    """Advanced threat elimination with multiple safety layers"""
    
    def __init__(self, config_dir: Path = None):
        """Initialize terminator with safety checks"""
        self.config_dir = config_dir or daemon_root / "Config"
        self.reports_dir = daemon_root / "Reports"
        self.logs_dir = daemon_root / "Logs" / "threat_termination"
        self.quarantine_dir = daemon_root / "Quarantine"
        
        # Create directories
        self.logs_dir.mkdir(parents=True, exist_ok=True)
        self.quarantine_dir.mkdir(parents=True, exist_ok=True)
        
        # Load safety lists
        self.essential_processes = self._load_essential_processes()
        self.system_files = self._load_system_files()
        self.daemon_processes = self._get_daemon_processes()
        
        # Termination log
        self.termination_log = []
        self.quarantine_log = []
        self.skipped_log = []
    
    def _load_essential_processes(self) -> set:
        """Load essential processes from whitelist"""
        essential = set()
        whitelist_file = self.config_dir / "essential_processes.txt"
        
        if whitelist_file.exists():
            try:
                with open(whitelist_file, 'r', encoding='utf-8') as f:
                    for line in f:
                        line = line.strip().lower()
                        if line and not line.startswith('#') and not line.startswith('!'):
                            essential.add(line)
            except Exception as e:
                print(f"Error loading essential processes: {e}")
        
        return essential
    
    def _load_system_files(self) -> set:
        """Load critical system files that must NEVER be deleted"""
        return {
            # Windows core
            'c:\\windows\\system32',
            'c:\\windows\\syswow64',
            'c:\\windows\\drivers',
            'c:\\windows\\winsxs',
            'c:\\windows\\servicing',
            'c:\\programdata\\microsoft\\windows',
            'c:\\programdata\\microsoft\\windows defender',
            
            # System files (NEVER delete)
            'ntoskrnl.exe', 'hal.dll', 'kernel32.dll', 'ntdll.dll',
            'csrss.exe', 'smss.exe', 'services.exe', 'lsass.exe',
            'svchost.exe', 'explorer.exe', 'dwm.exe', 'winlogon.exe',
            
            # Registry hives (NEVER touch)
            'c:\\windows\\system32\\config',
            'c:\\windows\\system32\\config\\sam',
            'c:\\windows\\system32\\config\\security',
            'c:\\windows\\system32\\config\\software',
            'c:\\windows\\system32\\config\\system',
            
            # Boot files
            'bootmgr', 'boot.ini', 'ntldr', 'hal.dll',
            
            # Daemon files (NEVER delete self)
            'f:\\malwareanalysis\\daemon',
            'process_daemon_console.py',
            'enhanced_pre_analyzer_monitor.py',
        }
    
    def _get_daemon_processes(self) -> set:
        """Get current daemon process IDs"""
        daemon_pids = set()
        try:
            for proc in psutil.process_iter(['pid', 'name', 'cmdline']):
                try:
                    cmdline = ' '.join(proc.info['cmdline'] or []).lower()
                    if 'daemon' in cmdline or 'threat_terminator' in cmdline:
                        daemon_pids.add(proc.info['pid'])
                except:
                    pass
        except:
            pass
        return daemon_pids
    
    def read_volatility_report(self, report_path: str) -> dict:
        """Read and parse Volatility analysis report"""
        try:
            with open(report_path, 'r', encoding='utf-8') as f:
                report = json.load(f)
            return report
        except Exception as e:
            print(f"Error reading report: {e}")
            return {}
    
    def analyze_threat_report(self, report: dict) -> dict:
        """Analyze report and extract threat information"""
        threats = {
            'critical': [],
            'high': [],
            'medium': [],
            'processes_to_terminate': [],
            'files_to_quarantine': [],
            'registry_to_check': [],
            'suspicious_dlls': [],
            'network_indicators': []
        }
        
        # Extract threats from report
        if 'threats' in report:
            for threat in report['threats']:
                threat_level = threat.get('threat_level', 'unknown').lower()
                
                if threat_level == 'critical':
                    threats['critical'].append(threat)
                    threats['processes_to_terminate'].append(threat)
                elif threat_level == 'high':
                    threats['high'].append(threat)
                    threats['processes_to_terminate'].append(threat)
                elif threat_level == 'medium':
                    threats['medium'].append(threat)
        
        # Extract file indicators
        if 'file_analysis' in report:
            for file_info in report['file_analysis']:
                if file_info.get('is_malicious'):
                    threats['files_to_quarantine'].append(file_info)
        
        # Extract DLL indicators
        if 'dll_analysis' in report:
            for dll in report['dll_analysis']:
                if dll.get('is_suspicious'):
                    threats['suspicious_dlls'].append(dll)
        
        # Extract network indicators
        if 'network_analysis' in report:
            threats['network_indicators'] = report['network_analysis']
        
        return threats
    
    def is_safe_to_terminate(self, process_info: dict) -> tuple:
        """
        Check if process is safe to terminate
        Returns: (is_safe: bool, reason: str)
        """
        pid = process_info.get('pid')
        name = process_info.get('name', '').lower()
        path = process_info.get('path', '').lower()
        
        # LAYER 1: Never terminate daemon processes
        if pid in self.daemon_processes:
            return False, "PROTECTED: Daemon process (would kill the protector)"
        
        # LAYER 2: Never terminate essential processes
        if name in self.essential_processes:
            return False, "PROTECTED: Essential process in whitelist"
        
        # LAYER 3: Never terminate system core processes
        system_core = {
            'system', 'idle', 'csrss.exe', 'smss.exe', 'services.exe',
            'lsass.exe', 'svchost.exe', 'explorer.exe', 'dwm.exe',
            'winlogon.exe', 'ntoskrnl.exe', 'hal.dll'
        }
        if name in system_core:
            return False, "PROTECTED: System core process"
        
        # LAYER 4: Never terminate if running from system directories
        system_dirs = ['c:\\windows\\system32', 'c:\\windows\\syswow64', 'c:\\program files']
        if any(sys_dir in path for sys_dir in system_dirs):
            # Even if flagged, system directory processes need user confirmation
            return False, "PROTECTED: Running from system directory (needs user confirmation)"
        
        # LAYER 5: Check if process is actually running
        try:
            if not psutil.pid_exists(pid):
                return False, "PROTECTED: Process no longer running"
        except:
            return False, "PROTECTED: Cannot verify process status"
        
        # If all checks pass, it's safe to terminate
        return True, "SAFE: All checks passed"
    
    def is_safe_to_delete_file(self, file_path: str) -> tuple:
        """
        Check if file is safe to delete
        Returns: (is_safe: bool, reason: str)
        """
        file_lower = file_path.lower()
        
        # LAYER 1: Never delete system files
        for sys_file in self.system_files:
            if sys_file in file_lower:
                return False, f"PROTECTED: System file ({sys_file})"
        
        # LAYER 2: Never delete from Windows directories
        windows_protected = [
            'c:\\windows\\',
            'c:\\programdata\\microsoft\\windows',
            'c:\\program files',
            'c:\\program files (x86)'
        ]
        if any(protected in file_lower for protected in windows_protected):
            return False, "PROTECTED: File in Windows/Program Files directory"
        
        # LAYER 3: Never delete daemon files
        if 'malwareanalysis\\daemon' in file_lower:
            return False, "PROTECTED: Daemon file"
        
        # LAYER 4: Check if file exists
        try:
            if not os.path.exists(file_path):
                return False, "PROTECTED: File does not exist"
        except:
            return False, "PROTECTED: Cannot access file"
        
        # LAYER 5: Never delete registry files
        if file_lower.endswith('.reg') or 'registry' in file_lower:
            return False, "PROTECTED: Registry file"
        
        # If all checks pass, it's safe to delete
        return True, "SAFE: All checks passed"
    
    def quarantine_file(self, file_path: str) -> bool:
        """Safely quarantine a file instead of deleting"""
        try:
            file_name = Path(file_path).name
            quarantine_path = self.quarantine_dir / f"{datetime.now().strftime('%Y%m%d_%H%M%S')}_{file_name}"
            
            if os.path.isfile(file_path):
                shutil.copy2(file_path, quarantine_path)
                self.quarantine_log.append({
                    'original_path': file_path,
                    'quarantine_path': str(quarantine_path),
                    'timestamp': datetime.now().isoformat()
                })
                return True
        except Exception as e:
            print(f"Error quarantining file: {e}")
        
        return False
    
    def terminate_process_tree(self, pid: int, process_name: str) -> bool:
        """
        Terminate process and all children
        SAFETY: Multiple checks before termination
        """
        try:
            # Final safety check
            is_safe, reason = self.is_safe_to_terminate({'pid': pid, 'name': process_name})
            if not is_safe:
                self.skipped_log.append({
                    'pid': pid,
                    'name': process_name,
                    'reason': reason,
                    'timestamp': datetime.now().isoformat()
                })
                return False
            
            # Get process and children
            parent = psutil.Process(pid)
            children = parent.children(recursive=True)
            
            # Terminate children first (bottom-up)
            for child in children:
                try:
                    child.terminate()
                    child.wait(timeout=3)
                except psutil.NoSuchProcess:
                    pass
                except Exception as e:
                    print(f"Error terminating child {child.pid}: {e}")
            
            # Terminate parent
            parent.terminate()
            parent.wait(timeout=3)
            
            self.termination_log.append({
                'pid': pid,
                'name': process_name,
                'action': 'terminated',
                'timestamp': datetime.now().isoformat()
            })
            
            return True
        
        except psutil.NoSuchProcess:
            return False
        except Exception as e:
            print(f"Error terminating process {pid}: {e}")
            return False
    
    def ask_user_confirmation(self, threat_info: dict, action: str) -> bool:
        """Ask user before taking action on suspicious items"""
        print(f"\n{Fore.YELLOW}{'='*70}")
        print(f"SUSPICIOUS ITEM DETECTED - USER CONFIRMATION REQUIRED")
        print(f"{'='*70}{Style.RESET_ALL}")
        
        print(f"\n{Fore.CYAN}Threat Information:{Style.RESET_ALL}")
        for key, value in threat_info.items():
            print(f"  {key}: {value}")
        
        print(f"\n{Fore.YELLOW}Proposed Action: {action}{Style.RESET_ALL}")
        print(f"{Fore.RED}WARNING: This action cannot be undone!{Style.RESET_ALL}")
        
        while True:
            response = input(f"\n{Fore.YELLOW}Do you want to proceed? (y/n): {Style.RESET_ALL}").lower().strip()
            if response in ['y', 'yes']:
                return True
            elif response in ['n', 'no']:
                return False
            else:
                print("Invalid input. Please enter 'y' or 'n'")
    
    def execute_threat_elimination(self, report_path: str) -> dict:
        """
        Main execution: Read report and eliminate threats
        Returns: Summary of actions taken
        """
        print(f"\n{Fore.CYAN}{'='*70}")
        print(f"THREAT TERMINATOR - READING VOLATILITY REPORT")
        print(f"{'='*70}{Style.RESET_ALL}")
        
        # Read report
        report = self.read_volatility_report(report_path)
        if not report:
            return {'status': 'failed', 'reason': 'Could not read report'}
        
        print(f"{Fore.GREEN}âœ“ Report loaded successfully{Style.RESET_ALL}")
        
        # Analyze threats
        threats = self.analyze_threat_report(report)
        print(f"{Fore.YELLOW}Found {len(threats['critical'])} CRITICAL threats{Style.RESET_ALL}")
        print(f"{Fore.YELLOW}Found {len(threats['high'])} HIGH threats{Style.RESET_ALL}")
        
        # Process critical threats
        for threat in threats['critical']:
            pid = threat.get('pid')
            name = threat.get('name')
            threat_type = threat.get('threat_type')
            
            is_safe, reason = self.is_safe_to_terminate(threat)
            
            if is_safe:
                print(f"\n{Fore.RED}Terminating CRITICAL threat: {name} (PID: {pid}){Style.RESET_ALL}")
                self.terminate_process_tree(pid, name)
            else:
                print(f"\n{Fore.YELLOW}SUSPICIOUS but PROTECTED: {name}{Style.RESET_ALL}")
                print(f"Reason: {reason}")
                
                # Ask user
                if self.ask_user_confirmation(threat, f"Terminate {name}?"):
                    self.terminate_process_tree(pid, name)
                else:
                    self.skipped_log.append({
                        'pid': pid,
                        'name': name,
                        'reason': 'User declined termination',
                        'timestamp': datetime.now().isoformat()
                    })
        
        # Process files
        for file_info in threats['files_to_quarantine']:
            file_path = file_info.get('path')
            
            is_safe, reason = self.is_safe_to_delete_file(file_path)
            
            if is_safe:
                print(f"\n{Fore.RED}Quarantining malicious file: {file_path}{Style.RESET_ALL}")
                self.quarantine_file(file_path)
            else:
                print(f"\n{Fore.YELLOW}SUSPICIOUS file but PROTECTED: {file_path}{Style.RESET_ALL}")
                print(f"Reason: {reason}")
                
                if self.ask_user_confirmation(file_info, f"Quarantine {file_path}?"):
                    self.quarantine_file(file_path)
                else:
                    self.skipped_log.append({
                        'file': file_path,
                        'reason': 'User declined quarantine',
                        'timestamp': datetime.now().isoformat()
                    })
        
        # Generate summary
        summary = {
            'status': 'completed',
            'processes_terminated': len(self.termination_log),
            'files_quarantined': len(self.quarantine_log),
            'items_skipped': len(self.skipped_log),
            'termination_log': self.termination_log,
            'quarantine_log': self.quarantine_log,
            'skipped_log': self.skipped_log
        }
        
        return summary
    
    def save_elimination_report(self, summary: dict) -> str:
        """Save elimination report"""
        try:
            report_name = f"threat_elimination_{datetime.now().strftime('%Y%m%d_%H%M%S')}.json"
            report_path = self.reports_dir / report_name
            
            with open(report_path, 'w', encoding='utf-8') as f:
                json.dump(summary, f, indent=2)
            
            return str(report_path)
        except Exception as e:
            print(f"Error saving report: {e}")
            return None


# ============================================================================
# MAIN EXECUTION
# ============================================================================

def main():
    """Main execution"""
    print(f"\n{Fore.CYAN}{'='*70}")
    print(f"THREAT TERMINATOR - ADVANCED THREAT ELIMINATION")
    print(f"{'='*70}{Style.RESET_ALL}")
    
    # Initialize terminator
    terminator = ThreatTerminator()
    
    # Find latest Volatility report
    reports_dir = Path(f"{daemon_root}/Reports")
    if not reports_dir.exists():
        print(f"{Fore.RED}No reports directory found{Style.RESET_ALL}")
        return
    
    # Get latest report
    reports = sorted(reports_dir.glob("*.json"), key=os.path.getmtime, reverse=True)
    if not reports:
        print(f"{Fore.RED}No reports found{Style.RESET_ALL}")
        return
    
    latest_report = reports[0]
    print(f"{Fore.GREEN}Using report: {latest_report.name}{Style.RESET_ALL}")
    
    # Execute elimination
    summary = terminator.execute_threat_elimination(str(latest_report))
    
    # Save report
    report_path = terminator.save_elimination_report(summary)
    if report_path:
        print(f"\n{Fore.GREEN}Elimination report saved: {report_path}{Style.RESET_ALL}")
    
    # Print summary
    print(f"\n{Fore.CYAN}{'='*70}")
    print(f"ELIMINATION SUMMARY")
    print(f"{'='*70}{Style.RESET_ALL}")
    print(f"Processes terminated: {summary['processes_terminated']}")
    print(f"Files quarantined: {summary['files_quarantined']}")
    print(f"Items skipped (protected): {summary['items_skipped']}")


if __name__ == '__main__':
    main()
