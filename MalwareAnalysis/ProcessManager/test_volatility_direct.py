#!/usr/bin/env python3
"""
ğŸ” Individual Test Script for Volatility-Direct Components
Tests each component separately to identify the exact failure point.
"""

import json
import sys
import psutil
from pathlib import Path
from datetime import datetime

def test_json_extraction():
    """Test 1: Check if we can find and parse volatility JSON results"""
    print("="*60)
    print("ğŸ” TEST 1: JSON Extraction from Volatility Results")
    print("="*60)
    
    try:
        # ğŸ¯ FIX: Look in the correct directory where volatility results are actually saved
        script_dir = Path(__file__).parent.parent  # Go up to MalwareAnalysis directory
        volatility_dir = script_dir / "Logs" / "RapidVolatility"
        
        print(f"ğŸ“ Script directory: {script_dir}")
        print(f"ğŸ“ Volatility directory: {volatility_dir}")
        print(f"ğŸ“‚ Directory exists: {volatility_dir.exists()}")
        
        if not volatility_dir.exists():
            print("âŒ Volatility logs directory not found")
            return []
        
        # Look for JSON data export files directly
        json_files = list(volatility_dir.glob("*data_export.json"))
        
        if json_files:
            for json_file in json_files:
                print(f"   ğŸ“„ {json_file.name} (modified: {datetime.fromtimestamp(json_file.stat().st_mtime)})")
        
        # Get the most recent JSON file
        if len(json_files) > 1:
            json_file = max(json_files, key=lambda x: x.stat().st_mtime)
            print(f"âœ… Using latest file: {json_file.name}")
        elif json_files:
            json_file = json_files[0]
            print(f"âœ… Using file: {json_file.name}")
        else:
            print("âŒ No JSON data export files found")
            return []
        print(f"ğŸ“Š Found {len(json_files)} JSON export files")
        
        if not json_files:
            print("âŒ No JSON data export files found")
            return []
        
        json_file = json_files[0]
        print(f"ğŸ“„ Loading: {json_file.name}")
        print(f"ğŸ“ File size: {json_file.stat().st_size / 1024:.1f} KB")
        
        # Load and parse JSON data
        with open(json_file, 'r', encoding='utf-8') as f:
            volatility_data = json.load(f)
        
        print("âœ… JSON loaded successfully")
        print(f"ğŸ”‘ Top-level keys: {list(volatility_data.keys())}")
        
        dangerous_processes = []
        
        # Extract process information from volatility data
        if 'threats_detected' in volatility_data:
            processes = volatility_data['threats_detected']
            
            print(f"[VOLATILITY-EXTRACT] ğŸ” Analyzing {len(processes)} threats from volatility results...")
        
            for i, proc in enumerate(processes):
                try:
                    # Show structure of first few processes for debugging
                    if i < 3:
                        print(f"   DEBUG Process {i+1} structure: {list(proc.keys()) if isinstance(proc, dict) else type(proc)}")
                    
                    # Handle different possible structures
                    if isinstance(proc, dict):
                        risk_level = proc.get('risk_level', proc.get('severity', 'LOW'))
                        classification = proc.get('classification', proc.get('type', 'SAFE'))
                    else:
                        continue
                
                    # Extract dangerous and suspicious processes
                    if (risk_level in ['HIGH', 'CRITICAL'] or 
                        classification in ['DANGEROUS', 'SUSPICIOUS', 'MALICIOUS']):
                        
                        dangerous_proc = {
                            'PID': proc.get('pid'),
                            'Name': proc.get('name', 'Unknown'),
                            'Path': proc.get('path', ''),
                            'Risk': risk_level,
                            'Classification': classification,
                            'Indicators': proc.get('indicators', []),
                            'Source': 'Volatility Analysis'
                        }
                        
                        dangerous_processes.append(dangerous_proc)
                        print(f"ğŸš¨ THREAT FOUND: {dangerous_proc['Name']} (PID: {dangerous_proc['PID']}) - {risk_level}")
                
                except Exception as e:
                    print(f"   âš ï¸ Error processing process data: {e}")
                    continue
        
                # Extract dangerous and suspicious processes
                if (risk_level in ['HIGH', 'CRITICAL'] or 
                    classification in ['DANGEROUS', 'SUSPICIOUS', 'MALICIOUS']):
                    
                    dangerous_proc = {
                        'PID': proc.get('pid'),
                        'Name': proc.get('name', 'Unknown'),
                        'Path': proc.get('path', ''),
                        'Risk': risk_level,
                        'Classification': classification,
                        'Indicators': proc.get('indicators', []),
                        'Source': 'Volatility Analysis'
                    }
                    
                    dangerous_processes.append(dangerous_proc)
                    print(f"ğŸš¨ THREAT FOUND: {dangerous_proc['Name']} (PID: {dangerous_proc['PID']}) - {risk_level}")
        
        # Also check statistics data for additional threat info
        if 'statistics' in volatility_data:
            stats = volatility_data['statistics']
            print(f"[VOLATILITY-EXTRACT] ğŸ“Š Statistics: {stats}")
        
        print(f"âœ… TEST 1 RESULT: Extracted {len(dangerous_processes)} dangerous/suspicious processes")
        return dangerous_processes
        
    except FileNotFoundError as e:
        print(f"âŒ File not found: {e}")
        return []
    except json.JSONDecodeError as e:
        print(f"âŒ JSON parse error: {e}")
        return []
    except Exception as e:
        print(f"âŒ Unexpected error: {e}")
        return []

def test_process_matching():
    """Test 2: Check if we can match processes in current system"""
    print("\n" + "="*60)
    print("ğŸ” TEST 2: Process Matching in Current System")
    print("="*60)
    
    try:
        # Get some current processes for testing
        current_processes = []
        for proc in list(psutil.process_iter(['pid', 'name', 'exe']))[:10]:
            try:
                current_processes.append({
                    'PID': proc.info['pid'],
                    'Name': proc.info['name'],
                    'Path': proc.info.get('exe', ''),
                    'Risk': 'TEST',
                    'Classification': 'TEST',
                    'Source': 'Test Data'
                })
            except (psutil.NoSuchProcess, psutil.AccessDenied):
                continue
        
        print(f"ğŸ” Found {len(current_processes)} current processes for testing")
        
        # Test matching logic
        for test_proc in current_processes[:3]:  # Test first 3
            print(f"\nğŸ¯ Testing match for: {test_proc['Name']} (PID: {test_proc['PID']})")
            
            # Method 1: Exact PID Match
            if psutil.pid_exists(test_proc['PID']):
                try:
                    proc = psutil.Process(test_proc['PID'])
                    if proc.name().lower() == test_proc['Name'].lower():
                        print(f"   âœ… PID Match: Found {test_proc['Name']} with PID {test_proc['PID']}")
                    else:
                        print(f"   âš ï¸ PID exists but name mismatch: {proc.name()} != {test_proc['Name']}")
                except (psutil.NoSuchProcess, psutil.AccessDenied):
                    print(f"   âŒ PID {test_proc['PID']} access denied")
            else:
                print(f"   âŒ PID {test_proc['PID']} does not exist")
            
            # Method 2: Name-based matching
            matches = []
            for proc in psutil.process_iter(['pid', 'name']):
                try:
                    if proc.info['name'] and proc.info['name'].lower() == test_proc['Name'].lower():
                        matches.append(proc.info['pid'])
                except (psutil.NoSuchProcess, psutil.AccessDenied):
                    continue
            
            print(f"   ğŸ” Name matches: {len(matches)} processes ({matches[:5]})")
        
        print("âœ… TEST 2 RESULT: Process matching logic works")
        return True
        
    except Exception as e:
        print(f"âŒ TEST 2 ERROR: {e}")
        return False

def test_process_termination(test_processes):
    """Test 3: Check if we can safely test termination logic (without actually killing)"""
    print("\n" + "="*60)
    print("ğŸ” TEST 3: Process Termination Logic (DRY RUN)")
    print("="*60)
    
    try:
        if not test_processes:
            print("âš ï¸ No test processes provided - creating dummy data")
            test_processes = [
                {'PID': 999999, 'Name': 'dummy_test.exe', 'Path': 'C:\\test\\dummy.exe', 'Risk': 'HIGH'},
                {'PID': 999998, 'Name': 'fake_malware.exe', 'Path': 'C:\\temp\\fake.exe', 'Risk': 'CRITICAL'}
            ]
        
        print(f"ğŸ¯ Testing termination logic with {len(test_processes)} processes")
        
        for vol_proc in test_processes:
            print(f"\nğŸ” Testing termination for: {vol_proc['Name']} (PID: {vol_proc.get('PID')})")
            
            vol_pid = vol_proc.get('PID')
            vol_name = vol_proc.get('Name', 'Unknown')
            vol_path = vol_proc.get('Path', '')
            risk_level = vol_proc.get('Risk', 'HIGH')
            
            target_processes = []
            
            # Method 1: Exact PID Match (if process still exists with same PID)
            try:
                if vol_pid and psutil.pid_exists(vol_pid):
                    proc = psutil.Process(vol_pid)
                    if proc.name().lower() == vol_name.lower():
                        target_processes.append(proc)
                        print(f"   âœ… Found exact PID match: {vol_name} (PID: {vol_pid})")
                else:
                    print(f"   âŒ PID {vol_pid} does not exist")
            except (psutil.NoSuchProcess, psutil.AccessDenied):
                print(f"   âŒ PID {vol_pid} access denied")
            
            # Method 2: Name-based matching (if PID changed)
            if not target_processes:
                try:
                    for proc in psutil.process_iter(['pid', 'name', 'exe']):
                        if proc.info['name'] and proc.info['name'].lower() == vol_name.lower():
                            target_processes.append(proc)
                            print(f"   âœ… Found name match: {vol_name} (New PID: {proc.pid})")
                            break  # Just find first match for testing
                except (psutil.NoSuchProcess, psutil.AccessDenied):
                    pass
            
            if target_processes:
                for proc in target_processes:
                    print(f"   ğŸ¯ WOULD TERMINATE: {proc.name()} (PID: {proc.pid}) [DRY RUN]")
                    # In real termination, would call: kill_process_and_children(proc.pid)
            else:
                print(f"   âš ï¸ No matching processes found for {vol_name}")
        
        print("âœ… TEST 3 RESULT: Termination logic structure is correct")
        return True
        
    except Exception as e:
        print(f"âŒ TEST 3 ERROR: {e}")
        return False

def main():
    """Run all individual tests"""
    print("ğŸš€ VOLATILITY-DIRECT INDIVIDUAL COMPONENT TESTING")
    print("This will test each component separately to find the exact issue")
    print("="*80)
    
    # Test 1: JSON Extraction
    dangerous_processes = test_json_extraction()
    
    # Test 2: Process Matching
    matching_works = test_process_matching()
    
    # Test 3: Termination Logic (dry run)
    termination_works = test_process_termination(dangerous_processes)
    
    # Summary
    print("\n" + "="*60)
    print("ğŸ“Š TEST SUMMARY")
    print("="*60)
    print(f"âœ… JSON Extraction: {'PASS' if dangerous_processes else 'FAIL'}")
    print(f"âœ… Process Matching: {'PASS' if matching_works else 'FAIL'}")
    print(f"âœ… Termination Logic: {'PASS' if termination_works else 'FAIL'}")
    
    if dangerous_processes and matching_works and termination_works:
        print("\nğŸ‰ ALL TESTS PASS - Components should work!")
        print("The issue is likely in the workflow integration or timing.")
    else:
        print("\nâš ï¸ SOME TESTS FAILED - Issue identified in individual components")
    
    print("\nğŸ” Next steps:")
    if not dangerous_processes:
        print("   - Check if volatility JSON file exists and has correct structure")
    if not matching_works:
        print("   - Check process access permissions")
    if not termination_works:
        print("   - Check termination logic implementation")

if __name__ == "__main__":
    main()
