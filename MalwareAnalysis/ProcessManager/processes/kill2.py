import os
import psutil
import subprocess
import time
import threading
import re
from datetime import datetime
# Define essential processes to be ignored
essential_processes = {
    'System Idle Process','OneDriveSetup.exe','PhotosApp.exe','SystemSettings.exe','UserOOBEBroker.exe','WerFault.exe','WindowsPackageManagerServer.exe','winpmem_mini.exe','UserOOBEBroker.exe','SystemSettings.exe', 'System', 'Registry', 'smss.exe', 'csrss.exe', 'wininit.exe',
    'winlogon.exe', 'services.exe', 'lsass.exe', 'svchost.exe', 'fontdrvhost.exe','PhotosService.exe','msedgewebview2.exe',
    'spoolsv.exe','rundll32.exe','wuauclt.exe','MoUsoCoreWorker.exe' ,'MpDefenderCoreService.exe', 'MsMpEng.exe', 'SearchIndexer.exe',
    'explorer.exe','DeviceCensus.exe','MpCmdRun.exe','sppsvc.exe', 'RuntimeBroker.exe', 'SecurityHealthService.exe', 'notepad.exe',
    'Taskmgr.exe', 'dwm.exe','dllhost.exe','sihost.exe','NisSrv.exe','taskhostw.exe','FileCoAuth.exe','SearchApp.exe','ctfmon.exe','audiodg.exe','StartMenuExperienceHost.exe','smartscreen.exe','SecurityHealthSystray.exe','ApplicationFrameHost.exe','TextInputHost.exe' ,'cmd.exe', 'conhost.exe', 'makecab.exe', 'TrustedInstaller.exe',
    'TiWorker.exe', 'python.exe','py.exe', 'msedge.exe', 'SgrmBroker.exe', 'ShellExperienceHost.exe',
    'OneDrive.exe', 'MicrosoftEdgeUpdate.exe', 'backgroundTaskHost.exe', 'HxTsr.exe',
    'OneDriveStandaloneUpdater.exe', 'SearchProtocolHost.exe', 'SearchFilterHost.exe',
    'WmiPrvSE.exe','WinRAR.exe','MemCompression', 'Microsoft.SharePoint.exe', 'PhoneExperienceHost.exe'
}
# Additional critical system processes
critical_users = {'SYSTEM', 'LOCAL SERVICE', 'NETWORK SERVICE'}

def should_monitor_process(proc):
    """Determines if a process should be monitored (non-essential, non-system critical)."""
    try:
        if proc.username() in critical_users:
            return False
        
        if proc.name() in essential_processes:
            return False
        
        return True
    except (psutil.AccessDenied, psutil.ZombieProcess, psutil.NoSuchProcess):
        return False  # Skip if process info is inaccessible

def p_kill(monitor_interval=30, dry_run=False):
    dry_run=False 	
    """Background process that continuously checks for malware and handles it."""
    while True:
        try:
            for proc in psutil.process_iter(['pid', 'name', 'username']):
                if should_monitor_process(proc):
                    timestamp = datetime.now().strftime('%Y-%m-%d %H:%M:%S')
                    print(f"[{timestamp}] Detected potential malicious process: {proc.info['name']} (PID: {proc.info['pid']}) owned by {proc.info['username']}")

                    if dry_run:
                        print(f"[Dry Run] Would suspend process {proc.info['name']} (PID: {proc.info['pid']})")
                    else:
                        try:
                            proc.suspend()  # Suspend the suspicious process
                            print(f"Suspended process {proc.info['name']} (PID: {proc.info['pid']})")
                        except Exception as e:
                            print(f"Error handling process {proc.info['name']} (PID: {proc.info['pid']}): {e}")

            time.sleep(monitor_interval)  # Wait before the next check
        except Exception as e:
            print(f"Error in monitoring loop: {e}")
            time.sleep(monitor_interval)  # Avoid infinite loop on errors

def start_background_monitoring(dry_run=False):
    """Starts the p_kill process in a separate thread to avoid blocking the main program."""
    monitoring_thread = threading.Thread(target=p_kill, args=(30, dry_run), daemon=True)
    monitoring_thread.start()

if __name__ == "__main__":
    # Start the background monitoring process
    start_background_monitoring(dry_run=True)

    # Main program logic can go here, while the monitoring continues in the background
    while True:
        time.sleep(60)  # Keep the main program running
