import os
import sys
import ctypes
import psutil
import subprocess
import time
import threading
import re

def is_admin():
    if ctypes.windll.shell32.IsUserAnAdmin():
        print("Is_admin")
    else:
        ctypes.windll.shell32.ShellExecuteW(None, 'runas', sys.executable, r"C:\Users\ayush\AppData\Roaming\Microsoft\Windows\Start Menu\Programs\Startup\kill1.py", None, 1)

def capture_memory_dump(dump_path=r"C:\memory_dump.raw"):
    """Captures a memory dump to the specified path."""
    print(f"Capturing memory dump to {dump_path}...")
    result = subprocess.run(["winpmem_mini.exe", dump_path], capture_output=True, text=True)
    print("Capture result:", result.returncode)
    
    if result.returncode != 0:
        print("Failed to capture memory dump:", result.stderr)
        print("Output:", result.stdout)
        return False
    
    print("Memory dump captured successfully.")
    return True

def analyze_memory_dump(dump_path=r"C:\memory_dump.raw", output_file='123.txt'):
    """Analyzes the memory dump for malicious processes using Volatility."""
    
    if not os.path.isfile(dump_path):
        print(f"Error: The specified dump path does not exist: {dump_path}")
        return

    print(f"Analyzing memory dump {dump_path} for malicious processes...")
    volatility_script = r"C:\Users\ayush\Desktop\volatility3-develop\vol.py"

    result = subprocess.run(
        ["python", volatility_script, "-f", dump_path, "windows.malfind"],
        stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True
    )

    if result.returncode != 0:
        print("Error during analysis:")
        print(result.stderr)
        return
    
    with open(output_file, 'w') as file:
        file.write(result.stdout)

    print(f"Analysis complete. Results saved to {output_file}")

essential_processes = {
    'System Idle Process','OneDriveSetup.exe','PhotosApp.exe','SystemSettings.exe','UserOOBEBroker.exe','WerFault.exe','WindowsPackageManagerServer.exe','winpmem_mini.exe','UserOOBEBroker.exe','SystemSettings.exe', 'System', 'Registry', 'smss.exe', 'csrss.exe', 'wininit.exe',
    'winlogon.exe', 'services.exe', 'lsass.exe', 'svchost.exe', 'fontdrvhost.exe','PhotosService.exe','msedgewebview2.exe',
    'spoolsv.exe','rundll32.exe','wuauclt.exe','MoUsoCoreWorker.exe' ,'MpDefenderCoreService.exe', 'MsMpEng.exe', 'SearchIndexer.exe',
    'explorer.exe','DeviceCensus.exe','MpCmdRun.exe','sppsvc.exe', 'RuntimeBroker.exe', 'SecurityHealthService.exe', 'notepad.exe',
    'Taskmgr.exe', 'dwm.exe','dllhost.exe','sihost.exe','NisSrv.exe','taskhostw.exe','FileCoAuth.exe','SearchApp.exe','ctfmon.exe','audiodg.exe','StartMenuExperienceHost.exe','smartscreen.exe','SecurityHealthSystray.exe','ApplicationFrameHost.exe','TextInputHost.exe' ,'cmd.exe', 'conhost.exe', 'makecab.exe', 'TrustedInstaller.exe',
    'TiWorker.exe', 'python.exe','py.exe', 'msedge.exe', 'SgrmBroker.exe', 'ShellExperienceHost.exe',
    'OneDrive.exe', 'MicrosoftEdgeUpdate.exe', 'backgroundTaskHost.exe', 'HxTsr.exe',
    'OneDriveStandaloneUpdater.exe', 'SearchProtocolHost.exe', 'SearchFilterHost.exe',
    'WmiPrvSE.exe','WinRAR.exe','MemCompression', 'Microsoft.SharePoint.exe', 'PhoneExperienceHost.exe'
}


critical_users = {'SYSTEM', 'LOCAL SERVICE', 'NETWORK SERVICE'}

def should_monitor_process(proc):
    """Determines if a process should be monitored (non-essential, non-system critical)."""
    try:
        if proc.username() in critical_users or proc.name() in essential_processes:
            return False
        return True
    except (psutil.AccessDenied, psutil.ZombieProcess, psutil.NoSuchProcess):
        return False

def extract_malicious_pids(filename):
    """Extracts PIDs from a file using regex."""
    pids_list = []
    with open(filename, 'r') as file:
        for line in file:
            match = re.match(r'^\s*(\d+)', line)
            if match:
                pids_list.append(int(match.group(1)))

    print(f"Extracted PIDs: {pids_list}")
    return pids_list

def kill_malicious_processes():
    """Captures a memory dump, analyzes it, and kills malicious processes."""
    dump_path = r"C:\memory_dump.raw"
    capture_memory_dump(dump_path)
    analyze_memory_dump(dump_path)
    malicious_pids = extract_malicious_pids('123.txt')

    killed_processes = []
    for pid in malicious_pids:
        try:
            proc = psutil.Process(pid)
            proc_name = proc.name()
            proc.kill()
            killed_processes.append((pid, proc_name))
            print(f"Killed malicious process {proc_name} (PID: {pid})")
        except (psutil.NoSuchProcess, psutil.AccessDenied, psutil.ZombieProcess, PermissionError) as e:
            print(f"Could not terminate process {pid}: {e}")
        except Exception as e:
            print(f"An error occurred with PID {pid}: {e}")

    print("\nList of processes killed:")
    for pid, proc_name in killed_processes:
        print(f"Process: {proc_name}, PID: {pid}")

def p_kill(monitor_interval=90):
    """Background process that continuously checks for malware and handles it."""
    while True:
        try:
            kill_malicious_processes()
            time.sleep(monitor_interval)
        except Exception as e:
            print(f"Error in monitoring loop: {e}")
            time.sleep(monitor_interval)

def start_background_monitoring():
    """Starts the p_kill process in a separate thread."""
    
    monitoring_thread = threading.Thread(target=p_kill, args=(30,), daemon=True)
    monitoring_thread.start()

if __name__ == "__main__":
    is_admin() 	
    start_background_monitoring()

    try:
        while True:
            time.sleep(60)  # Main program running without blocking the monitoring thread
    except KeyboardInterrupt:
        print("Monitoring stopped.")
