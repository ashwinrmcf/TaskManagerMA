#!/usr/bin/env python3
"""
Malware-Resistant GUI Framework
Prevents GUI deletion and interference during ransomware analysis
"""

import os
import sys
import time
import shutil
import threading
import subprocess
from pathlib import Path
from PyQt5.QtCore import QTimer, QThread, pyqtSignal
from PyQt5.QtWidgets import QApplication, QMessageBox

class FileProtectionService:
    """Protects critical GUI files from malware deletion"""
    
    def __init__(self):
        self.protected_files = {}
        self.backup_dir = Path("f:/MalwareAnalysis/GUI_BACKUP")
        self.backup_dir.mkdir(exist_ok=True)
        self.monitoring = True
        
    def protect_file(self, file_path):
        """Add file to protection and create backup"""
        file_path = Path(file_path)
        if not file_path.exists():
            return False
            
        # Create backup
        backup_path = self.backup_dir / file_path.name
        try:
            shutil.copy2(file_path, backup_path)
            self.protected_files[str(file_path)] = str(backup_path)
            print(f"[FILE-PROTECT] Protected: {file_path.name}")
            return True
        except Exception as e:
            print(f"[FILE-PROTECT] Failed to protect {file_path}: {e}")
            return False
    
    def check_and_restore(self):
        """Check protected files and restore if deleted"""
        restored = []
        
        for original_path, backup_path in self.protected_files.items():
            original = Path(original_path)
            backup = Path(backup_path)
            
            if not original.exists() and backup.exists():
                try:
                    shutil.copy2(backup, original)
                    restored.append(original_path)
                    print(f"[FILE-RESTORE] Restored: {original.name}")
                except Exception as e:
                    print(f"[FILE-RESTORE] Failed to restore {original}: {e}")
        
        return restored
    
    def start_monitoring(self):
        """Start file monitoring in background thread"""
        def monitor_loop():
            while self.monitoring:
                self.check_and_restore()
                time.sleep(1)  # Check every second
        
        monitor_thread = threading.Thread(target=monitor_loop, daemon=True)
        monitor_thread.start()
        print("[FILE-PROTECT] Monitoring started")
    
    def stop_monitoring(self):
        """Stop file monitoring"""
        self.monitoring = False

class ProcessProtectionService:
    """Protects GUI process from termination"""
    
    def __init__(self):
        self.gui_pid = os.getpid()
        self.restart_script = None
        self.monitoring = True
        
    def create_restart_script(self):
        """Create script to restart GUI if killed"""
        script_path = Path("f:/MalwareAnalysis/restart_gui.bat")
        
        script_content = f'''@echo off
echo GUI Protection: Restarting application...
timeout /t 2 /nobreak >nul
cd /d "{Path(__file__).parent}"
python process_manager_gui.py
'''
        
        try:
            with open(script_path, 'w') as f:
                f.write(script_content)
            self.restart_script = script_path
            print(f"[PROCESS-PROTECT] Restart script created: {script_path}")
        except Exception as e:
            print(f"[PROCESS-PROTECT] Failed to create restart script: {e}")
    
    def start_watchdog(self):
        """Start process watchdog"""
        def watchdog_loop():
            while self.monitoring:
                try:
                    # Check if our process still exists
                    import psutil
                    if not psutil.pid_exists(self.gui_pid):
                        print("[PROCESS-PROTECT] GUI process killed - triggering restart")
                        if self.restart_script and self.restart_script.exists():
                            subprocess.Popen([str(self.restart_script)], shell=True)
                        break
                except:
                    pass
                time.sleep(2)
        
        watchdog_thread = threading.Thread(target=watchdog_loop, daemon=True)
        watchdog_thread.start()
        print("[PROCESS-PROTECT] Watchdog started")
    
    def stop_watchdog(self):
        """Stop process watchdog"""
        self.monitoring = False

class MalwareResistantGUI:
    """Main malware-resistant GUI framework"""
    
    def __init__(self, main_window):
        self.main_window = main_window
        self.file_protection = FileProtectionService()
        self.process_protection = ProcessProtectionService()
        self.emergency_mode = False
        
    def initialize_protection(self):
        """Initialize all protection mechanisms"""
        print("[MALWARE-RESISTANT] Initializing protection...")
        
        # Protect critical files
        gui_files = [
            "process_manager_gui.py",
            "process_manager_gui.exe", 
            __file__,
            "essential_processes.txt"
        ]
        
        for filename in gui_files:
            file_path = Path(__file__).parent / filename
            if file_path.exists():
                self.file_protection.protect_file(file_path)
        
        # Start monitoring services
        self.file_protection.start_monitoring()
        self.process_protection.create_restart_script()
        self.process_protection.start_watchdog()
        
        # Setup emergency detection
        self.setup_emergency_detection()
        
        print("[MALWARE-RESISTANT] Protection active")
    
    def setup_emergency_detection(self):
        """Setup emergency mode detection"""
        self.emergency_timer = QTimer()
        self.emergency_timer.timeout.connect(self.check_emergency_conditions)
        self.emergency_timer.start(1000)  # Check every second
    
    def check_emergency_conditions(self):
        """Check for emergency conditions requiring protection mode"""
        try:
            import psutil
            
            # Check for high system load (possible ransomware activity)
            cpu_percent = psutil.cpu_percent(interval=0.1)
            memory_percent = psutil.virtual_memory().percent
            
            if cpu_percent > 80 or memory_percent > 90:
                if not self.emergency_mode:
                    self.activate_emergency_mode()
            elif self.emergency_mode and cpu_percent < 50 and memory_percent < 70:
                self.deactivate_emergency_mode()
                
        except Exception as e:
            print(f"[EMERGENCY-CHECK] Error: {e}")
    
    def activate_emergency_mode(self):
        """Activate emergency protection mode"""
        if self.emergency_mode:
            return
            
        print("[EMERGENCY] Activating emergency protection mode")
        self.emergency_mode = True
        
        # Slow down GUI updates to reduce system load
        if hasattr(self.main_window, 'refresh_timer'):
            self.main_window.refresh_timer.setInterval(10000)  # 10 seconds
        
        # Only create backups if there's an actual threat detected, not just high resource usage
        print("[EMERGENCY] Emergency mode active - backups will be created only when critical threats are detected")
        
        # Show warning
        try:
            QMessageBox.warning(
                self.main_window,
                "Emergency Mode",
                "High system activity detected. GUI protection mode activated. Backups will be created only when critical threats are detected."
            )
        except:
            pass
    
    def deactivate_emergency_mode(self):
        """Deactivate emergency protection mode"""
        if not self.emergency_mode:
            return
            
        print("[EMERGENCY] Deactivating emergency protection mode")
        self.emergency_mode = False
        
        # Restore normal GUI update frequency
        if hasattr(self.main_window, 'refresh_timer'):
            self.main_window.refresh_timer.setInterval(2000)  # 2 seconds
    
    def create_emergency_backups(self, threat_detected=False):
        """Create emergency backups of critical data only when threats are detected"""
        if not threat_detected:
            print("[EMERGENCY] Backup skipped - no critical threat detected")
            return
            
        try:
            emergency_dir = Path("f:/MalwareAnalysis/EMERGENCY_BACKUP")
            emergency_dir.mkdir(exist_ok=True)
            
            # Check if we already have recent backups (within last hour)
            recent_backups = [f for f in emergency_dir.glob("ProcessManager_backup_*") 
                            if (time.time() - int(f.name.split('_')[-1])) < 3600]
            
            if recent_backups:
                print(f"[EMERGENCY] Recent backup exists, skipping: {recent_backups[0].name}")
                return
            
            # Backup entire ProcessManager directory
            source_dir = Path(__file__).parent
            backup_dir = emergency_dir / f"ProcessManager_backup_{int(time.time())}"
            
            shutil.copytree(source_dir, backup_dir, ignore=shutil.ignore_patterns('*.pyc', '__pycache__', '*.raw', '*.dmp'))
            print(f"[EMERGENCY] Created critical threat backup: {backup_dir}")
            
        except Exception as e:
            print(f"[EMERGENCY] Backup failed: {e}")
    
    def handle_gui_attack(self):
        """Handle direct attack on GUI"""
        print("[ATTACK-DETECTED] GUI under attack - implementing countermeasures")
        
        # Immediately create backups (GUI attack is a critical threat)
        self.create_emergency_backups(threat_detected=True)
        
        # Restore any deleted files
        restored = self.file_protection.check_and_restore()
        if restored:
            print(f"[ATTACK-RESPONSE] Restored {len(restored)} files")
        
        # Show attack notification
        try:
            QMessageBox.critical(
                self.main_window,
                "Security Alert",
                f"Malware attack detected on GUI!\nRestored {len(restored)} files.\nContinuing in protected mode."
            )
        except:
            pass
    
    def trigger_critical_threat_backup(self, threat_type, threat_name):
        """Trigger emergency backup when critical threats are detected"""
        print(f"[CRITICAL-THREAT] {threat_type} detected: {threat_name}")
        self.create_emergency_backups(threat_detected=True)
    
    def shutdown_protection(self):
        """Shutdown protection services"""
        print("[MALWARE-RESISTANT] Shutting down protection...")
        
        self.file_protection.stop_monitoring()
        self.process_protection.stop_watchdog()
        
        if hasattr(self, 'emergency_timer'):
            self.emergency_timer.stop()

def apply_malware_resistance(main_window):
    """Apply malware resistance to main window"""
    print("[MALWARE-RESISTANCE] Applying malware resistance...")
    
    # Create resistance framework
    resistance = MalwareResistantGUI(main_window)
    resistance.initialize_protection()
    
    # Store reference
    main_window.malware_resistance = resistance
    
    # Patch close event
    original_close = main_window.closeEvent
    
    def protected_close_event(event):
        try:
            resistance.shutdown_protection()
        except:
            pass
        original_close(event)
    
    main_window.closeEvent = protected_close_event
    
    print("[MALWARE-RESISTANCE] Protection applied successfully")
    return resistance

if __name__ == "__main__":
    print("Malware-Resistant GUI Framework")
    print("Use apply_malware_resistance(main_window) to protect your GUI")
