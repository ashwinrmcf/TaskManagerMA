#!/usr/bin/env python3
"""
Process Manager Windows Service
Runs the malware analysis system as a background Windows service
"""

import sys
import os
import time
import threading
import logging
import json
from pathlib import Path
from datetime import datetime, timezone
import psutil
import win32serviceutil
import win32service
import win32event
import servicemanager
import socket

# Add current directory to path for imports
sys.path.insert(0, os.path.dirname(os.path.abspath(__file__)))

# Import core functionality
from countdown_dump_handler import CountdownDumpHandler
from fortress_protection_system import FortressProtectionSystem
from smart_aggressive_protection import SmartAggressiveProtection
from malware_resistant_gui import MalwareResistantGUI

class ProcessManagerService(win32serviceutil.ServiceFramework):
    """Windows service for Process Manager malware analysis system"""
    
    _svc_name_ = "ProcessManagerService"
    _svc_display_name_ = "Process Manager Malware Analysis Service"
    _svc_description_ = "Automated malware detection and analysis service with memory forensics capabilities"
    
    def __init__(self, args):
        win32serviceutil.ServiceFramework.__init__(self, args)
        self.hWaitStop = win32event.CreateEvent(None, 0, 0, None)
        self.running = False
        
        # Service configuration
        self.service_dir = Path(__file__).parent
        self.log_dir = Path(r"F:\MalwareAnalysis\Logs\Service")
        self.log_dir.mkdir(parents=True, exist_ok=True)
        
        # Set up logging
        self.setup_logging()
        
        # Core components
        self.essential_processes = set()
        self.malware_patterns = set()
        self.protection_systems = {}
        self.monitoring_thread = None
        self.analysis_thread = None
        
        # Service state
        self.service_status = {
            'status': 'stopped',
            'processes_monitored': 0,
            'threats_detected': 0,
            'last_analysis': None,
            'uptime_start': None
        }
        
        self.logger.info("Process Manager Service initialized")
    
    def setup_logging(self):
        """Set up service logging"""
        log_file = self.log_dir / f"service_{datetime.now().strftime('%Y%m%d')}.log"
        
        logging.basicConfig(
            level=logging.INFO,
            format='%(asctime)s - %(levelname)s - %(message)s',
            handlers=[
                logging.FileHandler(log_file),
                logging.StreamHandler()
            ]
        )
        self.logger = logging.getLogger('ProcessManagerService')
    
    def SvcStop(self):
        """Stop the service"""
        self.logger.info("Service stop requested")
        self.ReportServiceStatus(win32service.SERVICE_STOP_PENDING)
        win32event.SetEvent(self.hWaitStop)
        self.running = False
        
        # Stop all protection systems
        self.stop_protection_systems()
        
        self.service_status['status'] = 'stopped'
        self.logger.info("Service stopped successfully")
    
    def SvcDoRun(self):
        """Main service execution"""
        self.logger.info("Process Manager Service starting...")
        servicemanager.LogMsg(
            servicemanager.EVENTLOG_INFORMATION_TYPE,
            servicemanager.PYS_SERVICE_STARTED,
            (self._svc_name_, '')
        )
        
        self.running = True
        self.service_status['status'] = 'running'
        self.service_status['uptime_start'] = datetime.now()
        
        try:
            # Initialize core components
            self.initialize_service()
            
            # Start monitoring
            self.start_monitoring()
            
            # Main service loop
            self.run_service_loop()
            
        except Exception as e:
            self.logger.error(f"Service error: {e}")
            servicemanager.LogErrorMsg(f"Service error: {e}")
        
        self.logger.info("Service execution completed")
    
    def initialize_service(self):
        """Initialize all service components"""
        self.logger.info("Initializing service components...")
        
        # Load essential processes
        self.load_essential_processes()
        
        # Initialize protection systems
        self.initialize_protection_systems()
        
        # Create status file for tray communication
        self.create_status_file()
        
        self.logger.info("Service components initialized successfully")
    
    def load_essential_processes(self):
        """Load essential processes whitelist"""
        try:
            essential_file = self.service_dir / 'essential_processes.txt'
            if essential_file.exists():
                with open(essential_file, 'r', encoding='utf-8') as f:
                    for line in f:
                        line = line.strip()
                        if line and not line.startswith('#'):
                            if line.startswith('!'):
                                # Malware pattern
                                self.malware_patterns.add(line[1:].lower())
                            else:
                                # Essential process
                                self.essential_processes.add(line.lower())
                
                self.logger.info(f"Loaded {len(self.essential_processes)} essential processes, "
                               f"{len(self.malware_patterns)} malware patterns")
            else:
                self.logger.warning("Essential processes file not found")
        except Exception as e:
            self.logger.error(f"Error loading essential processes: {e}")
    
    def initialize_protection_systems(self):
        """Initialize protection systems"""
        try:
            # Smart Aggressive Protection
            self.protection_systems['smart_aggressive'] = SmartAggressiveProtection()
            
            # Fortress Protection (if available)
            try:
                self.protection_systems['fortress'] = FortressProtectionSystem()
            except Exception as e:
                self.logger.warning(f"Fortress protection not available: {e}")
            
            # Malware Resistant GUI (background mode)
            try:
                self.protection_systems['malware_resistant'] = MalwareResistantGUI()
            except Exception as e:
                self.logger.warning(f"Malware resistant GUI not available: {e}")
            
            self.logger.info(f"Initialized {len(self.protection_systems)} protection systems")
            
        except Exception as e:
            self.logger.error(f"Error initializing protection systems: {e}")
    
    def start_monitoring(self):
        """Start background monitoring threads"""
        self.logger.info("Starting monitoring threads...")
        
        # Process monitoring thread
        self.monitoring_thread = threading.Thread(
            target=self.process_monitoring_loop,
            daemon=True
        )
        self.monitoring_thread.start()
        
        # Analysis thread
        self.analysis_thread = threading.Thread(
            target=self.analysis_loop,
            daemon=True
        )
        self.analysis_thread.start()
        
        self.logger.info("Monitoring threads started")
    
    def process_monitoring_loop(self):
        """Main process monitoring loop"""
        self.logger.info("Process monitoring started")
        
        while self.running:
            try:
                # Get current processes
                current_processes = self.get_current_processes()
                self.service_status['processes_monitored'] = len(current_processes)
                
                # Analyze for threats
                threats = self.analyze_processes(current_processes)
                
                if threats:
                    self.service_status['threats_detected'] += len(threats)
                    self.handle_threats(threats)
                
                # Update status file
                self.update_status_file()
                
                # Sleep for monitoring interval
                time.sleep(5)  # 5-second monitoring interval
                
            except Exception as e:
                self.logger.error(f"Error in process monitoring: {e}")
                time.sleep(10)  # Longer sleep on error
    
    def analysis_loop(self):
        """Background analysis loop for complete automated cycles"""
        self.logger.info("Analysis loop started - Full automated cycling enabled")
        
        cycle_count = 0
        
        while self.running:
            try:
                cycle_count += 1
                self.logger.info(f"ðŸ”„ Starting automated analysis cycle #{cycle_count}")
                
                # Step 1: Check for unknown processes (like GUI dialog)
                unknown_processes = self.find_unknown_processes()
                
                if unknown_processes:
                    self.logger.info(f"ðŸ“‹ Found {len(unknown_processes)} unknown processes")
                    
                    # Step 2: Create memory dump for analysis
                    dump_file = self.create_comprehensive_memory_dump()
                    
                    if dump_file:
                        # Step 3: Run Volatility analysis
                        self.run_volatility_analysis(dump_file)
                        
                        # Step 4: Terminate suspicious processes
                        self.terminate_suspicious_processes(unknown_processes)
                        
                        # Step 5: Cleanup and prepare for next cycle
                        self.cleanup_analysis_cycle(dump_file)
                        
                        self.logger.info("âœ… Analysis cycle completed successfully")
                    else:
                        self.logger.error("âŒ Memory dump failed - skipping cycle")
                else:
                    self.logger.info("âœ… No unknown processes found - system clean")
                
                # Step 6: System health check
                self.system_health_check()
                
                # Step 7: Wait before next cycle (configurable interval)
                cycle_interval = 300  # 5 minutes between cycles
                self.logger.info(f"â±ï¸ Waiting {cycle_interval} seconds before next cycle...")
                
                for i in range(cycle_interval):
                    if not self.running:
                        break
                    time.sleep(1)
                
            except Exception as e:
                self.logger.error(f"âŒ Error in analysis cycle #{cycle_count}: {e}")
                time.sleep(60)  # Wait 1 minute on error before retry
    
    def get_current_processes(self):
        """Get current system processes"""
        processes = []
        try:
            for proc in psutil.process_iter(['pid', 'name', 'exe', 'cmdline', 'create_time']):
                try:
                    processes.append(proc.info)
                except (psutil.NoSuchProcess, psutil.AccessDenied):
                    continue
        except Exception as e:
            self.logger.error(f"Error getting processes: {e}")
        
        return processes
    
    def analyze_processes(self, processes):
        """Analyze processes for threats"""
        threats = []
        
        for proc in processes:
            try:
                proc_name = proc.get('name', '').lower()
                proc_exe = proc.get('exe', '').lower()
                
                # Skip essential processes
                if self.is_essential_process(proc_name, proc_exe):
                    continue
                
                # Check against malware patterns
                if self.is_malware_process(proc_name, proc_exe):
                    threats.append({
                        'pid': proc.get('pid'),
                        'name': proc.get('name'),
                        'exe': proc.get('exe'),
                        'type': 'malware_pattern',
                        'severity': 'high'
                    })
                
                # Check for suspicious behavior
                if self.is_suspicious_process(proc):
                    threats.append({
                        'pid': proc.get('pid'),
                        'name': proc.get('name'),
                        'exe': proc.get('exe'),
                        'type': 'suspicious_behavior',
                        'severity': 'medium'
                    })
                    
            except Exception as e:
                self.logger.error(f"Error analyzing process {proc}: {e}")
        
        return threats
    
    def is_essential_process(self, proc_name, proc_exe):
        """Check if process is essential"""
        for essential in self.essential_processes:
            if essential in proc_name or essential in proc_exe:
                return True
        return False
    
    def is_malware_process(self, proc_name, proc_exe):
        """Check if process matches malware patterns"""
        for pattern in self.malware_patterns:
            if pattern in proc_name or pattern in proc_exe:
                return True
        return False
    
    def is_suspicious_process(self, proc):
        """Check for suspicious process behavior"""
        # Add heuristic analysis here
        proc_name = proc.get('name', '').lower()
        proc_exe = proc.get('exe', '').lower()
        
        # Suspicious patterns
        suspicious_patterns = [
            'temp', 'tmp', 'appdata\\local\\temp',
            'random', 'svchost', 'winlogon', 'csrss'
        ]
        
        # Check for suspicious locations
        if proc_exe:
            for pattern in suspicious_patterns:
                if pattern in proc_exe and 'system32' not in proc_exe:
                    return True
        
        return False
    
    def handle_threats(self, threats):
        """Handle detected threats"""
        self.logger.warning(f"Detected {len(threats)} threats")
        
        for threat in threats:
            try:
                self.logger.warning(f"Threat detected: {threat}")
                
                # Create memory dump if high severity
                if threat['severity'] == 'high':
                    self.create_memory_dump(threat)
                
                # Terminate malicious processes
                if threat['type'] == 'malware_pattern':
                    self.terminate_process(threat['pid'])
                
            except Exception as e:
                self.logger.error(f"Error handling threat {threat}: {e}")
    
    def create_memory_dump(self, threat):
        """Create memory dump for analysis"""
        try:
            dump_dir = Path(r"F:\MalwareAnalysis\ServiceDumps")
            dump_dir.mkdir(parents=True, exist_ok=True)
            
            timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
            dump_file = dump_dir / f"threat_dump_{threat['pid']}_{timestamp}.raw"
            
            # Use countdown dump handler
            dump_handler = CountdownDumpHandler()
            success = dump_handler.create_memory_dump(str(dump_file))
            
            if success:
                self.logger.info(f"Memory dump created: {dump_file}")
                self.service_status['last_analysis'] = datetime.now()
            else:
                self.logger.error("Failed to create memory dump")
                
        except Exception as e:
            self.logger.error(f"Error creating memory dump: {e}")
    
    def terminate_process(self, pid):
        """Terminate malicious process"""
        try:
            proc = psutil.Process(pid)
            proc.terminate()
            proc.wait(timeout=5)
            self.logger.info(f"Terminated process {pid}")
        except psutil.NoSuchProcess:
            self.logger.warning(f"Process {pid} already terminated")
        except Exception as e:
            self.logger.error(f"Error terminating process {pid}: {e}")
    
    def find_unknown_processes(self):
        """Find processes not in essential processes list (like GUI dialog)"""
        unknown_processes = []
        
        try:
            current_processes = self.get_current_processes()
            
            for proc in current_processes:
                proc_name = proc.get('name', '').lower()
                proc_exe = proc.get('exe', '').lower()
                
                # Skip essential processes
                if self.is_essential_process(proc_name, proc_exe):
                    continue
                
                # Add to unknown processes list
                unknown_processes.append({
                    'pid': proc.get('pid'),
                    'name': proc.get('name'),
                    'exe': proc.get('exe'),
                    'cmdline': proc.get('cmdline', []),
                    'create_time': proc.get('create_time')
                })
            
            return unknown_processes
            
        except Exception as e:
            self.logger.error(f"Error finding unknown processes: {e}")
            return []
    
    def create_comprehensive_memory_dump(self):
        """Create comprehensive memory dump like GUI system"""
        try:
            dump_dir = Path(r"F:\MalwareAnalysis\ServiceDumps")
            dump_dir.mkdir(parents=True, exist_ok=True)
            
            timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
            dump_file = dump_dir / f"service_dump_{timestamp}.raw"
            
            self.logger.info(f"ðŸ—‚ï¸ Creating comprehensive memory dump: {dump_file}")
            
            # Use countdown dump handler for comprehensive dump
            dump_handler = CountdownDumpHandler()
            success = dump_handler.create_memory_dump(str(dump_file))
            
            if success and dump_file.exists():
                size_gb = dump_file.stat().st_size / (1024**3)
                self.logger.info(f"âœ… Memory dump created successfully: {size_gb:.2f} GB")
                return str(dump_file)
            else:
                self.logger.error("âŒ Memory dump creation failed")
                return None
                
        except Exception as e:
            self.logger.error(f"Error creating memory dump: {e}")
            return None
    
    def run_volatility_analysis(self, dump_file):
        """Run Volatility analysis on memory dump"""
        try:
            self.logger.info(f"ðŸ”¬ Starting Volatility analysis on: {Path(dump_file).name}")
            
            # Create analysis session directory
            analysis_dir = Path(r"F:\MalwareAnalysis\ServiceAnalysis")
            analysis_dir.mkdir(parents=True, exist_ok=True)
            
            timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
            session_dir = analysis_dir / f"Session_{timestamp}"
            session_dir.mkdir(exist_ok=True)
            
            # Run basic Volatility commands (simplified for service)
            volatility_commands = [
                'windows.info',
                'windows.pslist',
                'windows.pstree',
                'windows.handles',
                'windows.cmdline',
                'windows.netstat'
            ]
            
            results = {}
            for cmd in volatility_commands:
                try:
                    self.logger.info(f"Running Volatility command: {cmd}")
                    # Simplified command execution - in real implementation would use subprocess
                    # For now, just log the attempt
                    results[cmd] = f"Command {cmd} executed"
                except Exception as e:
                    self.logger.error(f"Volatility command {cmd} failed: {e}")
                    results[cmd] = f"Failed: {e}"
            
            # Save results
            results_file = session_dir / "volatility_results.json"
            with open(results_file, 'w') as f:
                json.dump(results, f, indent=2, default=str)
            
            self.logger.info(f"âœ… Volatility analysis completed: {len(results)} commands executed")
            self.service_status['last_analysis'] = datetime.now()
            
        except Exception as e:
            self.logger.error(f"Error in Volatility analysis: {e}")
    
    def terminate_suspicious_processes(self, unknown_processes):
        """Terminate suspicious processes after analysis"""
        terminated_count = 0
        
        try:
            self.logger.info(f"ðŸŽ¯ Analyzing {len(unknown_processes)} unknown processes for termination")
            
            for proc_info in unknown_processes:
                try:
                    pid = proc_info.get('pid')
                    name = proc_info.get('name', 'unknown')
                    
                    # Risk assessment (simplified)
                    risk_level = self.assess_process_risk(proc_info)
                    
                    if risk_level in ['HIGH', 'CRITICAL']:
                        self.logger.warning(f"ðŸš¨ Terminating {risk_level} risk process: {name} (PID: {pid})")
                        self.terminate_process(pid)
                        terminated_count += 1
                    elif risk_level == 'MEDIUM':
                        self.logger.info(f"âš ï¸ Terminating suspicious process: {name} (PID: {pid})")
                        self.terminate_process(pid)
                        terminated_count += 1
                    else:
                        self.logger.info(f"â„¹ï¸ Keeping low-risk process: {name} (PID: {pid})")
                
                except Exception as e:
                    self.logger.error(f"Error processing {proc_info}: {e}")
            
            self.logger.info(f"âœ… Process termination complete: {terminated_count} processes terminated")
            
        except Exception as e:
            self.logger.error(f"Error in process termination: {e}")
    
    def assess_process_risk(self, proc_info):
        """Assess risk level of a process"""
        proc_name = proc_info.get('name', '').lower()
        proc_exe = proc_info.get('exe', '').lower()
        
        # Check against malware patterns first
        if self.is_malware_process(proc_name, proc_exe):
            return 'CRITICAL'
        
        # Check for suspicious behavior
        if self.is_suspicious_process(proc_info):
            return 'HIGH'
        
        # Check for medium risk indicators
        suspicious_locations = ['temp', 'tmp', 'appdata\\local\\temp']
        for location in suspicious_locations:
            if location in proc_exe:
                return 'MEDIUM'
        
        return 'LOW'
    
    def cleanup_analysis_cycle(self, dump_file):
        """Cleanup after analysis cycle"""
        try:
            self.logger.info("ðŸ§¹ Starting analysis cycle cleanup")
            
            # Optional: Remove memory dump to save space (configurable)
            cleanup_dumps = True  # Make this configurable
            
            if cleanup_dumps and dump_file and Path(dump_file).exists():
                dump_size = Path(dump_file).stat().st_size / (1024**3)
                Path(dump_file).unlink()
                self.logger.info(f"ðŸ—‘ï¸ Cleaned up memory dump: {dump_size:.2f} GB freed")
            
            # Cleanup old analysis sessions (keep only last 5)
            analysis_dir = Path(r"F:\MalwareAnalysis\ServiceAnalysis")
            if analysis_dir.exists():
                sessions = sorted(analysis_dir.glob("Session_*"), key=lambda x: x.stat().st_mtime)
                if len(sessions) > 5:
                    for old_session in sessions[:-5]:
                        import shutil
                        shutil.rmtree(old_session, ignore_errors=True)
                        self.logger.info(f"ðŸ—‘ï¸ Cleaned up old session: {old_session.name}")
            
            self.logger.info("âœ… Cleanup completed")
            
        except Exception as e:
            self.logger.error(f"Error in cleanup: {e}")
    
    def check_and_analyze_dumps(self):
        """Legacy method - now handled by automated cycle"""
        pass
    
    def system_health_check(self):
        """Perform system health check"""
        try:
            # Check CPU and memory usage
            cpu_percent = psutil.cpu_percent(interval=1)
            memory_percent = psutil.virtual_memory().percent
            
            if cpu_percent > 90 or memory_percent > 95:
                self.logger.warning(f"High system usage: CPU {cpu_percent}%, Memory {memory_percent}%")
            
        except Exception as e:
            self.logger.error(f"Error in system health check: {e}")
    
    def create_status_file(self):
        """Create status file for tray communication"""
        status_file = self.service_dir / 'service_status.json'
        try:
            with open(status_file, 'w') as f:
                json.dump(self.service_status, f, default=str, indent=2)
        except Exception as e:
            self.logger.error(f"Error creating status file: {e}")
    
    def update_status_file(self):
        """Update status file"""
        self.create_status_file()
    
    def stop_protection_systems(self):
        """Stop all protection systems"""
        for name, system in self.protection_systems.items():
            try:
                if hasattr(system, 'stop'):
                    system.stop()
                self.logger.info(f"Stopped {name} protection system")
            except Exception as e:
                self.logger.error(f"Error stopping {name}: {e}")
    
    def run_service_loop(self):
        """Main service loop"""
        self.logger.info("Service loop started")
        
        while self.running:
            # Wait for stop event
            rc = win32event.WaitForSingleObject(self.hWaitStop, 1000)
            if rc == win32event.WAIT_OBJECT_0:
                # Stop event signaled
                break
        
        self.logger.info("Service loop ended")


def install_service():
    """Install the service"""
    try:
        win32serviceutil.InstallService(
            ProcessManagerService._svc_reg_class_,
            ProcessManagerService._svc_name_,
            ProcessManagerService._svc_display_name_,
            startType=win32service.SERVICE_AUTO_START,
            description=ProcessManagerService._svc_description_
        )
        print("Service installed successfully")
        print("Service will start automatically at boot")
    except Exception as e:
        print(f"Error installing service: {e}")


def uninstall_service():
    """Uninstall the service"""
    try:
        win32serviceutil.RemoveService(ProcessManagerService._svc_name_)
        print("Service uninstalled successfully")
    except Exception as e:
        print(f"Error uninstalling service: {e}")


if __name__ == '__main__':
    if len(sys.argv) == 1:
        servicemanager.Initialize()
        servicemanager.PrepareToHostSingle(ProcessManagerService)
        servicemanager.StartServiceCtrlDispatcher()
    else:
        if sys.argv[1] == 'install':
            install_service()
        elif sys.argv[1] == 'uninstall':
            uninstall_service()
        else:
            win32serviceutil.HandleCommandLine(ProcessManagerService)
