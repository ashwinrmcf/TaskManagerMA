"""
GUI Integration for Threading Fixes
This file provides the integration code to connect threading_fixes.py to your main GUI
"""

from threading_fixes import integrate_threading_fixes
import sys
import os

def apply_threading_fixes_to_gui():
    """
    Apply threading fixes to the main GUI to prevent freezing
    Call this function after your GUI is initialized
    """
    
    # Import the main GUI classes
    try:
        # Add the current directory to Python path if needed
        current_dir = os.path.dirname(os.path.abspath(__file__))
        if current_dir not in sys.path:
            sys.path.insert(0, current_dir)
            
        # Import your main GUI module
        import process_manager_gui
        
        # Find all SecurityTab instances and apply threading fixes
        from PyQt5.QtWidgets import QApplication
        
        app = QApplication.instance()
        if app:
            for widget in app.allWidgets():
                # Check if this is a SecurityTab widget
                if hasattr(widget, 'add_console_message') and hasattr(widget, 'update_status'):
                    print(f"[THREADING-FIX] Applying threading fixes to {widget.__class__.__name__}")
                    
                    # Apply the threading integration
                    integrate_threading_fixes(widget)
                    
                    # Add specific method overrides for your GUI
                    add_gui_specific_overrides(widget)
                    
                    print(f"[THREADING-FIX] ‚úÖ Threading fixes applied successfully")
                    
    except Exception as e:
        print(f"[THREADING-FIX] ‚ùå Error applying threading fixes: {str(e)}")
        
def add_gui_specific_overrides(security_tab):
    """Add specific method overrides for your SecurityTab"""
    
    # Override the memory dump methods to use threading
    original_dump_method = getattr(security_tab, 'dump_system_memory_winpmem', None)
    if original_dump_method:
        def threaded_dump_system_memory_winpmem(dump_file):
            """Threaded version of dump_system_memory_winpmem"""
            security_tab.add_console_message("üöÄ Starting threaded system memory dump...", "INFO")
            
            # Convert to threaded operation
            return security_tab.threaded_memory_dump("full", None, str(dump_file.parent))
            
        security_tab.dump_system_memory_winpmem = threaded_dump_system_memory_winpmem
        
    # Override daemon stop methods
    original_stop_method = getattr(security_tab, 'stop_daemon', None)
    if original_stop_method:
        def threaded_stop_daemon():
            """Threaded version of stop_daemon"""
            security_tab.add_console_message("üõë Starting threaded daemon stop...", "INFO")
            
            # Stop any refresh timers first
            if hasattr(security_tab, 'refresh_timer') and security_tab.refresh_timer:
                security_tab.refresh_timer.stop()
                
            # Use threaded stop
            return security_tab.threaded_daemon_stop()
            
        security_tab.stop_daemon = threaded_stop_daemon
        
    # Override process dump methods
    original_dump_processes = getattr(security_tab, 'dump_selected_processes', None)
    if original_dump_processes:
        def threaded_dump_selected_processes():
            """Threaded version of dump_selected_processes"""
            security_tab.add_console_message("üöÄ Starting threaded process dumps...", "INFO")
            
            # Get selected processes (this part should be quick)
            selected_processes = []
            try:
                # Extract process selection logic here
                # This is a placeholder - you'd need to adapt based on your actual selection logic
                if hasattr(security_tab, 'process_table'):
                    table = security_tab.process_table
                    for row in range(table.rowCount()):
                        if table.item(row, 0) and table.item(row, 0).isSelected():
                            pid_item = table.item(row, 0)
                            name_item = table.item(row, 1)
                            if pid_item and name_item:
                                try:
                                    pid = int(pid_item.text())
                                    name = name_item.text()
                                    selected_processes.append({'pid': pid, 'name': name})
                                except ValueError:
                                    continue
            except Exception as e:
                security_tab.add_console_message(f"Error getting selected processes: {str(e)}", "ERROR")
                
            # Use threaded dump for selected processes
            return security_tab.threaded_memory_dump("process", selected_processes)
            
        security_tab.dump_selected_processes = threaded_dump_selected_processes
        
    # Add callback methods for threading events
    def on_dump_complete(dump_file):
        """Handle completion of memory dump"""
        security_tab.add_console_message(f"üéØ Memory dump completed, starting analysis...", "SUCCESS")
        
        # Trigger volatility analysis if available
        if hasattr(security_tab, 'run_volatility_analysis'):
            try:
                security_tab.run_volatility_analysis(dump_file)
            except Exception as e:
                security_tab.add_console_message(f"Error starting volatility analysis: {str(e)}", "ERROR")
                
    def on_daemon_stopped():
        """Handle daemon stop completion"""
        security_tab.add_console_message("üîÑ Daemon stopped, updating GUI state...", "INFO")
        
        # Update GUI state
        if hasattr(security_tab, 'daemon_status'):
            security_tab.daemon_status.setText("Status: Stopped")
            security_tab.daemon_status.setStyleSheet("color: #dc3545; font-weight: bold;")
            
        # Update buttons
        if hasattr(security_tab, 'start_daemon_btn'):
            security_tab.start_daemon_btn.setEnabled(True)
            security_tab.start_daemon_btn.setText("Start Security Daemon")
            
        if hasattr(security_tab, 'stop_daemon_btn'):
            security_tab.stop_daemon_btn.setEnabled(False)
            
    # Attach the callback methods
    security_tab.on_dump_complete = on_dump_complete
    security_tab.on_daemon_stopped = on_daemon_stopped
    
    # Override any blocking dialog operations
    if hasattr(security_tab, 'show_unknown_processes_dialog'):
        original_show_dialog = security_tab.show_unknown_processes_dialog
        
        def non_blocking_show_dialog():
            """Non-blocking version of show_unknown_processes_dialog"""
            try:
                # Show dialog without blocking
                result = original_show_dialog()
                
                # If dialog has blocking operations, make them non-blocking
                if hasattr(result, 'refresh_timer') and result.refresh_timer:
                    # Ensure timer operations don't block GUI
                    result.refresh_timer.timeout.connect(
                        lambda: security_tab.add_console_message("üîÑ Refreshing process list...", "DEBUG")
                    )
                    
                return result
                
            except Exception as e:
                security_tab.add_console_message(f"Error showing dialog: {str(e)}", "ERROR")
                return None
                
        security_tab.show_unknown_processes_dialog = non_blocking_show_dialog

def patch_countdown_dump_handler():
    """Patch CountdownDumpHandler to use threading"""
    try:
        import countdown_dump_handler
        
        # Get the CountdownDumpHandler class
        handler_class = countdown_dump_handler.CountdownDumpHandler
        
        # Override the start_memory_dump_process method
        original_start_dump = handler_class.start_memory_dump_process
        
        def threaded_start_memory_dump_process(self):
            """Threaded version of start_memory_dump_process"""
            try:
                self.status_update.emit("üöÄ Starting threaded memory dump process...")
                
                # Get the parent (should be UnknownProcessDialog)
                if hasattr(self, 'parent') and hasattr(self.parent, 'parent'):
                    security_tab = self.parent.parent
                    
                    if hasattr(security_tab, 'threaded_memory_dump'):
                        # Use threaded dump
                        worker = security_tab.threaded_memory_dump("full")
                        
                        # Connect worker signals to countdown handler
                        if worker:
                            worker.progress_update.connect(self.status_update.emit)
                            worker.dump_complete.connect(
                                lambda file, success: self.dump_complete.emit(file) if success else None
                            )
                            
                        return
                        
                # Fallback to original method if threading not available
                original_start_dump(self)
                
            except Exception as e:
                self.status_update.emit(f"Error in threaded dump: {str(e)}")
                # Fallback to original
                original_start_dump(self)
                
        # Apply the patch
        handler_class.start_memory_dump_process = threaded_start_memory_dump_process
        
        print("[THREADING-FIX] ‚úÖ CountdownDumpHandler patched for threading")
        
    except Exception as e:
        print(f"[THREADING-FIX] ‚ö†Ô∏è Could not patch CountdownDumpHandler: {str(e)}")

def setup_emergency_gui_recovery():
    """Set up emergency GUI recovery in case of freezing"""
    
    from PyQt5.QtCore import QTimer
    from PyQt5.QtWidgets import QApplication
    
    def check_gui_responsiveness():
        """Check if GUI is still responsive"""
        try:
            app = QApplication.instance()
            if app:
                # Process any pending events to keep GUI responsive
                app.processEvents()
                
        except Exception as e:
            print(f"[GUI-RECOVERY] Error in responsiveness check: {str(e)}")
            
    # Set up a timer to periodically check GUI responsiveness
    recovery_timer = QTimer()
    recovery_timer.timeout.connect(check_gui_responsiveness)
    recovery_timer.start(1000)  # Check every second
    
    print("[GUI-RECOVERY] ‚úÖ Emergency GUI recovery system activated")
    
    return recovery_timer

# Main integration function
def initialize_threading_system():
    """Initialize the complete threading system"""
    
    print("[THREADING-INIT] üöÄ Initializing threading system...")
    
    try:
        # Apply threading fixes to GUI
        apply_threading_fixes_to_gui()
        
        # Patch countdown dump handler
        patch_countdown_dump_handler()
        
        # Set up emergency recovery
        recovery_timer = setup_emergency_gui_recovery()
        
        print("[THREADING-INIT] ‚úÖ Threading system initialized successfully")
        
        return True
        
    except Exception as e:
        print(f"[THREADING-INIT] ‚ùå Error initializing threading system: {str(e)}")
        return False

# Auto-initialization when module is imported
if __name__ == "__main__":
    initialize_threading_system()
else:
    # Auto-initialize when imported
    from PyQt5.QtCore import QTimer
    
    def delayed_init():
        """Initialize threading system after a short delay"""
        initialize_threading_system()
        
    # Initialize after 1 second to ensure GUI is ready
    QTimer.singleShot(1000, delayed_init)
