#!/usr/bin/env python3
"""
üîç Workflow Integration Test
Tests the exact integration points where the system gets stuck.
"""

import sys
import json
from pathlib import Path
from datetime import datetime

def test_volatility_trigger_chain():
    """Test the complete trigger chain from volatility completion to termination"""
    print("="*70)
    print("üîç TESTING COMPLETE VOLATILITY ‚Üí TERMINATION TRIGGER CHAIN")
    print("="*70)
    
    # Test 1: Can we find the SecurityTab class and trigger method?
    print("\nüìã TEST 1: SecurityTab Trigger Method Access")
    try:
        # Import the main GUI module
        sys.path.append(str(Path(__file__).parent))
        from process_manager_gui import SecurityTab
        
        print("‚úÖ Successfully imported SecurityTab")
        
        # Check if the trigger method exists
        if hasattr(SecurityTab, 'trigger_post_analysis_process_termination'):
            print("‚úÖ trigger_post_analysis_process_termination method exists")
        else:
            print("‚ùå trigger_post_analysis_process_termination method NOT found")
            return False
            
    except ImportError as e:
        print(f"‚ùå Import error: {e}")
        return False
    except Exception as e:
        print(f"‚ùå Unexpected error: {e}")
        return False
    
    # Test 2: Can we find UnknownProcessDialog and its methods?
    print("\nüìã TEST 2: UnknownProcessDialog Method Access")
    try:
        from process_manager_gui import UnknownProcessDialog
        
        print("‚úÖ Successfully imported UnknownProcessDialog")
        
        # Check critical methods
        methods_to_check = [
            'on_volatility_analysis_complete',
            'terminate_suspicious_processes_after_analysis',
            'extract_dangerous_processes_from_volatility_results',
            'terminate_volatility_identified_processes'
        ]
        
        for method_name in methods_to_check:
            if hasattr(UnknownProcessDialog, method_name):
                print(f"‚úÖ {method_name} method exists")
            else:
                print(f"‚ùå {method_name} method NOT found")
                return False
                
    except ImportError as e:
        print(f"‚ùå Import error: {e}")
        return False
    except Exception as e:
        print(f"‚ùå Unexpected error: {e}")
        return False
    
    # Test 3: Test the JSON extraction directly using class method
    print("\nüìã TEST 3: Direct JSON Extraction via Class Method")
    try:
        # Create a minimal instance for testing (without GUI)
        class MinimalDialog:
            def extract_dangerous_processes_from_volatility_results(self):
                """Copy of the actual method for testing"""
                import json
                from pathlib import Path
                
                print("[WORKFLOW-TEST] üîç Testing JSON extraction...")
                
                try:
                    # Look in the correct directory where volatility results are saved
                    script_dir = Path(__file__).parent.parent  # Go up to MalwareAnalysis directory
                    volatility_dir = script_dir / "Logs" / "RapidVolatility"
                    
                    print(f"[WORKFLOW-TEST] üìÅ Looking in: {volatility_dir}")
                    
                    if not volatility_dir.exists():
                        print("[WORKFLOW-TEST] ‚ö†Ô∏è Volatility logs directory not found")
                        return []
                    
                    # Look for JSON data export files directly
                    json_files = list(volatility_dir.glob("*data_export.json"))
                    
                    if not json_files:
                        print("[WORKFLOW-TEST] ‚ö†Ô∏è No JSON data export files found")
                        return []
                    
                    json_file = json_files[0]
                    print(f"[WORKFLOW-TEST] üìä Loading: {json_file.name}")
                    
                    # Load and parse JSON data
                    with open(json_file, 'r', encoding='utf-8') as f:
                        volatility_data = json.load(f)
                    
                    dangerous_processes = []
                    
                    # Extract process information from volatility data  
                    if 'threats_detected' in volatility_data:
                        processes = volatility_data['threats_detected']
                        
                        print(f"[WORKFLOW-TEST] üîç Analyzing {len(processes)} threats from volatility results...")
                        
                        for proc in processes:
                            try:
                                risk_level = proc.get('risk_level', proc.get('severity', 'LOW'))
                                classification = proc.get('classification', proc.get('type', 'SAFE'))
                                
                                # Extract dangerous and suspicious processes
                                if (risk_level in ['HIGH', 'CRITICAL'] or 
                                    classification in ['DANGEROUS', 'SUSPICIOUS', 'MALICIOUS']):
                                    
                                    dangerous_proc = {
                                        'PID': proc.get('pid'),
                                        'Name': proc.get('name', 'Unknown'),
                                        'Path': proc.get('path', ''),
                                        'Risk': risk_level,
                                        'Classification': classification,
                                        'Indicators': proc.get('indicators', []),
                                        'Source': 'Volatility Analysis'
                                    }
                                    
                                    dangerous_processes.append(dangerous_proc)
                                    print(f"[WORKFLOW-TEST] üö® Found threat: {dangerous_proc['Name']} (PID: {dangerous_proc['PID']}) - {risk_level}")
                            
                            except Exception as e:
                                print(f"[WORKFLOW-TEST] ‚ö†Ô∏è Error processing process data: {e}")
                                continue
                    
                    print(f"[WORKFLOW-TEST] ‚úÖ Extracted {len(dangerous_processes)} dangerous/suspicious processes")
                    return dangerous_processes
                    
                except Exception as e:
                    print(f"[WORKFLOW-TEST] ‚ùå Error extracting volatility results: {e}")
                    return []
        
        test_dialog = MinimalDialog()
        dangerous_processes = test_dialog.extract_dangerous_processes_from_volatility_results()
        
        if dangerous_processes:
            print(f"‚úÖ JSON extraction successful: Found {len(dangerous_processes)} threats")
            for proc in dangerous_processes[:3]:  # Show first 3
                print(f"   üö® {proc['Name']} - {proc['Risk']}")
        else:
            print("‚ö†Ô∏è No dangerous processes found in JSON")
            
    except Exception as e:
        print(f"‚ùå JSON extraction test failed: {e}")
        return False
    
    # Test 4: Check QTimer functionality (common GUI threading issue)
    print("\nüìã TEST 4: QTimer and Threading Check")
    try:
        from PyQt5.QtCore import QTimer, QThread
        print("‚úÖ PyQt5 QTimer and QThread imported successfully")
        
        # Test if we can create a timer (this often fails in headless environments)
        try:
            from PyQt5.QtWidgets import QApplication
            if QApplication.instance() is None:
                print("‚ö†Ô∏è No QApplication instance - GUI timers may not work")
                print("   This could be why QTimer.singleShot(2000, ...) isn't firing")
            else:
                print("‚úÖ QApplication instance exists")
        except Exception as e:
            print(f"‚ö†Ô∏è QApplication check failed: {e}")
            
    except ImportError as e:
        print(f"‚ùå PyQt5 import error: {e}")
        return False
    
    print("\nüìä WORKFLOW INTEGRATION TEST SUMMARY")
    print("="*70)
    print("‚úÖ All method imports successful")
    print("‚úÖ JSON extraction works")
    print("‚ö†Ô∏è Potential issue: GUI timer/threading in headless environment")
    
    return True

def test_direct_method_call():
    """Test calling the termination method directly"""
    print("\nüöÄ DIRECT METHOD CALL TEST")
    print("="*70)
    
    try:
        # This would simulate what should happen after volatility analysis
        print("üîç Simulating post-volatility-analysis trigger...")
        
        # In the real system, this should be:
        # 1. SecurityTab.volatility_analysis_finished() calls
        # 2. SecurityTab.trigger_post_analysis_process_termination() which calls  
        # 3. UnknownProcessDialog.on_volatility_analysis_complete() which schedules
        # 4. UnknownProcessDialog.terminate_suspicious_processes_after_analysis()
        
        print("üìã Expected workflow:")
        print("   1. volatility_analysis_finished() ‚úÖ")
        print("   2. trigger_post_analysis_process_termination() ‚ùì")
        print("   3. on_volatility_analysis_complete() ‚ùì")
        print("   4. QTimer.singleShot(2000, terminate_suspicious_processes_after_analysis) ‚ùì")
        print("   5. terminate_suspicious_processes_after_analysis() ‚ùì")
        
        print("\nüéØ LIKELY ISSUE: Step 2 or 4 is failing")
        print("   - Step 2: Dialog reference may be None or invalid")
        print("   - Step 4: QTimer may not work without proper QApplication")
        
        return True
        
    except Exception as e:
        print(f"‚ùå Direct method test failed: {e}")
        return False

def main():
    """Run all workflow integration tests"""
    print("üöÄ VOLATILITY WORKFLOW INTEGRATION TESTING")
    print(f"üìÖ Test time: {datetime.now()}")
    print("="*80)
    
    # Run all tests
    success = True
    success &= test_volatility_trigger_chain()
    success &= test_direct_method_call()
    
    print("\n" + "="*80)
    print("üèÅ FINAL DIAGNOSIS")
    print("="*80)
    
    if success:
        print("üéØ MOST LIKELY ROOT CAUSE:")
        print("   The issue is probably in the GUI workflow integration:")
        print("   1. Dialog reference is None/invalid in trigger_post_analysis_process_termination()")
        print("   2. QTimer.singleShot() doesn't work without proper QApplication context")
        print("   3. Exception somewhere in the chain that's being silently caught")
        
        print("\nüí° RECOMMENDED FIXES:")
        print("   1. Add direct console output in trigger_post_analysis_process_termination()")
        print("   2. Replace QTimer.singleShot with direct method call for testing")
        print("   3. Add try-catch with print statements around all GUI calls")
        
    else:
        print("‚ùå Critical component failures detected")
        print("   Fix the import and method access issues first")

if __name__ == "__main__":
    main()
