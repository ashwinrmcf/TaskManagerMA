#!/usr/bin/env python3
"""
Fortress Protection System - Multi-layered defense against ALL malware escape attempts
No process can survive this comprehensive protection matrix
"""

import os
import sys
import time
import psutil
import threading
import subprocess
import ctypes
import winreg
import socket
from pathlib import Path
from ctypes import wintypes, windll
from PyQt5.QtCore import QThread, pyqtSignal, QTimer

class KernelLevelMonitor(QThread):
    """Kernel-level process monitoring using Windows API hooks"""
    
    process_created = pyqtSignal(int, str)  # pid, name
    
    def __init__(self):
        super().__init__()
        self.running = True
        self.kernel32 = ctypes.windll.kernel32
        self.ntdll = ctypes.windll.ntdll
        self.advapi32 = ctypes.windll.advapi32
        
    def run(self):
        """Monitor process creation at kernel level"""
        print("[KERNEL-MONITOR] Starting kernel-level process monitoring...")
        
        while self.running:
            try:
                # Monitor process creation using WMI events
                self.monitor_wmi_process_events()
                time.sleep(0.01)  # 10ms scan interval
                
            except Exception as e:
                print(f"[KERNEL-MONITOR] Error: {e}")
                time.sleep(0.1)
    
    def monitor_wmi_process_events(self):
        """Monitor WMI process creation events"""
        try:
            import wmi
            c = wmi.WMI()
            
            # Monitor for new process creation
            for process in c.Win32_Process():
                if hasattr(process, 'ProcessId') and hasattr(process, 'Name'):
                    self.process_created.emit(process.ProcessId, process.Name)
                    
        except Exception as e:
            # Fallback to psutil if WMI fails
            for proc in psutil.process_iter(['pid', 'name']):
                try:
                    self.process_created.emit(proc.info['pid'], proc.info['name'])
                except:
                    pass
    
    def stop_monitoring(self):
        """Stop kernel monitoring"""
        self.running = False

class FileSystemGuard(QThread):
    """Real-time file system monitoring to block encryption attempts"""
    
    encryption_attempt = pyqtSignal(str, str)  # file_path, process_name
    
    def __init__(self):
        super().__init__()
        self.running = True
        self.monitored_extensions = {
            '.txt', '.doc', '.docx', '.pdf', '.jpg', '.jpeg', '.png', '.mp4', 
            '.mp3', '.xlsx', '.ppt', '.pptx', '.zip', '.rar', '.sql', '.db'
        }
        self.encryption_patterns = {
            '.encrypted', '.locked', '.crypto', '.satan', '.nasan', '.ryuk'
        }
        
    def run(self):
        """Monitor file system for encryption attempts"""
        print("[FILE-GUARD] Starting real-time file system monitoring...")
        
        while self.running:
            try:
                self.scan_for_encryption_activity()
                time.sleep(0.05)  # 50ms scan interval
                
            except Exception as e:
                print(f"[FILE-GUARD] Error: {e}")
                time.sleep(0.5)
    
    def scan_for_encryption_activity(self):
        """Scan for active file encryption"""
        try:
            # Monitor recent file changes
            for proc in psutil.process_iter(['pid', 'name', 'open_files']):
                try:
                    if proc.info['open_files']:
                        for file_info in proc.info['open_files']:
                            file_path = file_info.path.lower()
                            
                            # Check for encryption patterns
                            for pattern in self.encryption_patterns:
                                if pattern in file_path:
                                    self.encryption_attempt.emit(file_path, proc.info['name'])
                                    return
                            
                            # Check for mass file operations on important files
                            if any(ext in file_path for ext in self.monitored_extensions):
                                # Additional checks for suspicious activity
                                if self.is_suspicious_file_activity(proc.info):
                                    self.encryption_attempt.emit(file_path, proc.info['name'])
                                    
                except (psutil.AccessDenied, psutil.NoSuchProcess):
                    continue
                    
        except Exception as e:
            pass
    
    def is_suspicious_file_activity(self, proc_info):
        """Check if file activity is suspicious"""
        try:
            proc = psutil.Process(proc_info['pid'])
            
            # High CPU usage + many open files = potential encryption
            if proc.cpu_percent() > 30 and len(proc_info.get('open_files', [])) > 20:
                return True
                
            return False
            
        except:
            return False
    
    def stop_monitoring(self):
        """Stop file system monitoring"""
        self.running = False

class NetworkIsolator(QThread):
    """Network isolation to prevent C&C communication"""
    
    malicious_connection = pyqtSignal(str, str, int)  # ip, process_name, pid
    
    def __init__(self):
        super().__init__()
        self.running = True
        self.blocked_ips = set()
        self.suspicious_ports = {4444, 6666, 8080, 9999, 1337, 31337, 443, 80}
        
    def run(self):
        """Monitor and block malicious network connections"""
        print("[NETWORK-ISOLATOR] Starting network isolation monitoring...")
        
        while self.running:
            try:
                self.monitor_network_connections()
                time.sleep(0.1)  # 100ms scan interval
                
            except Exception as e:
                print(f"[NETWORK-ISOLATOR] Error: {e}")
                time.sleep(1)
    
    def monitor_network_connections(self):
        """Monitor for malicious network connections"""
        try:
            for conn in psutil.net_connections(kind='inet'):
                if conn.status == 'ESTABLISHED' and conn.raddr:
                    # Check for suspicious connections
                    if self.is_suspicious_connection(conn):
                        try:
                            proc = psutil.Process(conn.pid) if conn.pid else None
                            proc_name = proc.name() if proc else "Unknown"
                            
                            self.malicious_connection.emit(
                                conn.raddr.ip, proc_name, conn.pid or 0
                            )
                            
                            # Block the IP immediately
                            self.block_ip(conn.raddr.ip)
                            
                        except:
                            pass
                            
        except Exception as e:
            pass
    
    def is_suspicious_connection(self, conn):
        """Check if network connection is suspicious"""
        if not conn.raddr:
            return False
            
        # Check for suspicious ports
        if conn.raddr.port in self.suspicious_ports:
            return True
            
        # Check for non-standard ports with external IPs
        if not self.is_local_ip(conn.raddr.ip) and conn.raddr.port > 10000:
            return True
            
        return False
    
    def is_local_ip(self, ip):
        """Check if IP is local/private"""
        return (ip.startswith('192.168.') or 
                ip.startswith('10.') or 
                ip.startswith('172.') or 
                ip.startswith('127.'))
    
    def block_ip(self, ip):
        """Block IP address using Windows firewall"""
        if ip in self.blocked_ips:
            return
            
        try:
            # Add firewall rule to block IP
            cmd = [
                'netsh', 'advfirewall', 'firewall', 'add', 'rule',
                f'name=Block_Malware_{ip}',
                'dir=out', 'action=block',
                f'remoteip={ip}'
            ]
            
            subprocess.run(cmd, capture_output=True, timeout=5)
            self.blocked_ips.add(ip)
            print(f"[NETWORK-ISOLATOR] ‚úÖ Blocked malicious IP: {ip}")
            
        except Exception as e:
            print(f"[NETWORK-ISOLATOR] Failed to block IP {ip}: {e}")
    
    def stop_monitoring(self):
        """Stop network monitoring"""
        self.running = False

class RegistryProtector(QThread):
    """Registry protection against persistence mechanisms"""
    
    registry_attack = pyqtSignal(str, str)  # key_path, value_name
    
    def __init__(self):
        super().__init__()
        self.running = True
        self.protected_keys = [
            r"SOFTWARE\Microsoft\Windows\CurrentVersion\Run",
            r"SOFTWARE\Microsoft\Windows\CurrentVersion\RunOnce",
            r"SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon",
            r"SYSTEM\CurrentControlSet\Services"
        ]
        self.baseline_values = {}
        self.capture_baseline()
        
    def capture_baseline(self):
        """Capture baseline registry values"""
        print("[REGISTRY-PROTECTOR] Capturing registry baseline...")
        
        for key_path in self.protected_keys:
            try:
                with winreg.OpenKey(winreg.HKEY_LOCAL_MACHINE, key_path) as key:
                    values = {}
                    i = 0
                    while True:
                        try:
                            name, value, _ = winreg.EnumValue(key, i)
                            values[name] = value
                            i += 1
                        except WindowsError:
                            break
                    
                    self.baseline_values[key_path] = values
                    
            except Exception as e:
                print(f"[REGISTRY-PROTECTOR] Error reading {key_path}: {e}")
    
    def run(self):
        """Monitor registry for malicious changes"""
        print("[REGISTRY-PROTECTOR] Starting registry protection...")
        
        while self.running:
            try:
                self.check_registry_changes()
                time.sleep(1)  # 1 second scan interval
                
            except Exception as e:
                print(f"[REGISTRY-PROTECTOR] Error: {e}")
                time.sleep(5)
    
    def check_registry_changes(self):
        """Check for unauthorized registry changes"""
        for key_path in self.protected_keys:
            try:
                with winreg.OpenKey(winreg.HKEY_LOCAL_MACHINE, key_path) as key:
                    current_values = {}
                    i = 0
                    while True:
                        try:
                            name, value, _ = winreg.EnumValue(key, i)
                            current_values[name] = value
                            i += 1
                        except WindowsError:
                            break
                    
                    # Compare with baseline
                    baseline = self.baseline_values.get(key_path, {})
                    
                    # Check for new malicious entries
                    for name, value in current_values.items():
                        if name not in baseline:
                            if self.is_malicious_registry_entry(name, value):
                                self.registry_attack.emit(key_path, name)
                                self.remove_malicious_entry(key_path, name)
                                
            except Exception as e:
                pass
    
    def is_malicious_registry_entry(self, name, value):
        """Check if registry entry is malicious"""
        if not isinstance(value, str):
            return False
            
        value_lower = value.lower()
        suspicious_patterns = [
            'temp', 'tmp', 'appdata', 'programdata', 'downloads',
            'encrypt', 'crypto', 'ransom', 'satan', 'nasan'
        ]
        
        return any(pattern in value_lower for pattern in suspicious_patterns)
    
    def remove_malicious_entry(self, key_path, value_name):
        """Remove malicious registry entry"""
        try:
            with winreg.OpenKey(winreg.HKEY_LOCAL_MACHINE, key_path, 0, winreg.KEY_SET_VALUE) as key:
                winreg.DeleteValue(key, value_name)
                print(f"[REGISTRY-PROTECTOR] ‚úÖ Removed malicious entry: {key_path}\\{value_name}")
                
        except Exception as e:
            print(f"[REGISTRY-PROTECTOR] Failed to remove {key_path}\\{value_name}: {e}")
    
    def stop_monitoring(self):
        """Stop registry monitoring"""
        self.running = False

class FortressProtectionSystem:
    """Master protection system coordinating all defense layers"""
    
    def __init__(self):
        self.kernel_monitor = KernelLevelMonitor()
        self.file_guard = FileSystemGuard()
        self.network_isolator = NetworkIsolator()
        self.registry_protector = RegistryProtector()
        
        # Enhanced immediate terminator
        self.immediate_terminator = None
        
        # Protection statistics
        self.threats_terminated = 0
        self.files_protected = 0
        self.connections_blocked = 0
        self.registry_attacks_blocked = 0
        
    def start_fortress_protection(self):
        """Start all protection layers"""
        print("üè∞ FORTRESS PROTECTION SYSTEM ACTIVATING")
        print("="*60)
        
        # Start kernel-level monitoring
        self.kernel_monitor.process_created.connect(self.on_process_created)
        self.kernel_monitor.start()
        
        # Start file system guard
        self.file_guard.encryption_attempt.connect(self.on_encryption_attempt)
        self.file_guard.start()
        
        # Start network isolator
        self.network_isolator.malicious_connection.connect(self.on_malicious_connection)
        self.network_isolator.start()
        
        # Start registry protector
        self.registry_protector.registry_attack.connect(self.on_registry_attack)
        self.registry_protector.start()
        
        # Start enhanced immediate terminator
        self.start_enhanced_terminator()
        
        # Start memory protection layer
        self.start_memory_protection_layer()
        
        # Start system hardening engine
        self.start_system_hardening()
        
        # Start self-protection system
        self.start_self_protection()
        
        # Start proactive defense system
        self.start_proactive_defense()
        
        print("üè∞ ALL PROTECTION LAYERS ACTIVE - FORTRESS MODE ENGAGED")
        print("üö® NO MALWARE CAN ESCAPE THIS PROTECTION MATRIX")
        print("üõ°Ô∏è MEMORY INJECTION PROTECTION ACTIVE")
        print("üîí REGISTRY PROTECTION ACTIVE") 
        print("üåê NETWORK ISOLATION ACTIVE")
        print("üìÅ FILE SYSTEM GUARD ACTIVE")
        print("üîß SYSTEM HARDENING ACTIVE")
        print("üõ°Ô∏è SELF-PROTECTION ACTIVE")
        print("‚ö° PROACTIVE DEFENSE ACTIVE")
        
    def start_enhanced_terminator(self):
        """Start enhanced immediate terminator with 10ms response time"""
        try:
            from immediate_threat_terminator import ImmediateThreatTerminator
            
            # Override scan interval to 10ms for maximum responsiveness
            class EnhancedTerminator(ImmediateThreatTerminator):
                def run(self):
                    print("[ENHANCED-TERMINATOR] üö® MAXIMUM PROTECTION MODE - 10ms SCAN INTERVAL")
                    while self.running:
                        try:
                            self.scan_and_terminate_threats()
                            time.sleep(0.01)  # 10ms scan interval - MAXIMUM RESPONSIVENESS
                        except Exception as e:
                            print(f"[ENHANCED-TERMINATOR] Error: {e}")
                            time.sleep(0.05)
            
            self.immediate_terminator = EnhancedTerminator()
            self.immediate_terminator.start()
            
        except Exception as e:
            print(f"[FORTRESS] Error starting enhanced terminator: {e}")
    
    def start_memory_protection_layer(self):
        """Start memory protection layer"""
        try:
            from memory_protection_layer import start_memory_protection
            
            self.memory_protection = start_memory_protection()
            print("[FORTRESS] üõ°Ô∏è MEMORY PROTECTION LAYER ACTIVE")
            
        except Exception as e:
            print(f"[FORTRESS] Error starting memory protection: {e}")
    
    def start_system_hardening(self):
        """Start system hardening engine"""
        try:
            from system_hardening_engine import start_system_hardening
            
            self.system_hardening = start_system_hardening()
            print("[FORTRESS] üîß SYSTEM HARDENING ENGINE ACTIVE")
            
        except Exception as e:
            print(f"[FORTRESS] Error starting system hardening: {e}")
    
    def start_self_protection(self):
        """Start self-protection system"""
        try:
            from self_protection_system import start_self_protection
            
            self.self_protection = start_self_protection()
            print("[FORTRESS] üõ°Ô∏è SELF-PROTECTION SYSTEM ACTIVE")
            
        except Exception as e:
            print(f"[FORTRESS] Error starting self-protection: {e}")
    
    def start_proactive_defense(self):
        """Start proactive defense system"""
        try:
            from proactive_defense_system import start_proactive_defense
            
            self.proactive_defense = start_proactive_defense()
            print("[FORTRESS] ‚ö° PROACTIVE DEFENSE SYSTEM ACTIVE")
            
        except Exception as e:
            print(f"[FORTRESS] Error starting proactive defense: {e}")
    
    def on_process_created(self, pid, name):
        """Handle new process creation at kernel level"""
        # Immediate threat assessment
        if self.is_immediate_threat(pid, name):
            self.terminate_process_immediately(pid, name, "KERNEL_DETECTION")
    
    def on_encryption_attempt(self, file_path, process_name):
        """Handle file encryption attempt"""
        print(f"üö® ENCRYPTION ATTEMPT BLOCKED: {process_name} -> {file_path}")
        
        # Find and kill the encrypting process
        for proc in psutil.process_iter(['pid', 'name']):
            try:
                if proc.info['name'].lower() == process_name.lower():
                    self.terminate_process_immediately(proc.info['pid'], process_name, "FILE_ENCRYPTION")
                    self.files_protected += 1
                    break
            except:
                continue
    
    def on_malicious_connection(self, ip, process_name, pid):
        """Handle malicious network connection"""
        print(f"üö® MALICIOUS CONNECTION BLOCKED: {process_name} -> {ip}")
        
        if pid > 0:
            self.terminate_process_immediately(pid, process_name, "NETWORK_COMMUNICATION")
        
        self.connections_blocked += 1
    
    def on_registry_attack(self, key_path, value_name):
        """Handle registry attack"""
        print(f"üö® REGISTRY ATTACK BLOCKED: {key_path}\\{value_name}")
        self.registry_attacks_blocked += 1
    
    def is_immediate_threat(self, pid, name):
        """Enhanced threat detection at kernel level"""
        if not name:
            return False
            
        name_lower = name.lower()
        
        # Known malware signatures
        threat_signatures = [
            'ransomware', 'encrypt', 'crypto', 'locker', 'satan', 'nasan',
            'wannacry', 'petya', 'ryuk', 'maze', 'conti', 'revil', 'lockbit',
            'blackmatter', 'darkside', 'sodinokibi', 'gandcrab'
        ]
        
        return any(sig in name_lower for sig in threat_signatures)
    
    def terminate_process_immediately(self, pid, name, detection_method):
        """Terminate process with maximum force using all available methods"""
        print(f"üö® FORTRESS KILL: {name} (PID: {pid}) - Method: {detection_method}")
        
        success = False
        
        # Method 1: Direct psutil kill
        try:
            proc = psutil.Process(pid)
            proc.kill()
            success = True
            print(f"‚úÖ PSUTIL KILL SUCCESS: {name}")
        except:
            pass
        
        # Method 2: Windows API TerminateProcess
        if not success:
            try:
                handle = ctypes.windll.kernel32.OpenProcess(1, False, pid)
                if handle:
                    ctypes.windll.kernel32.TerminateProcess(handle, 1)
                    ctypes.windll.kernel32.CloseHandle(handle)
                    success = True
                    print(f"‚úÖ API KILL SUCCESS: {name}")
            except:
                pass
        
        # Method 3: System taskkill
        if not success:
            try:
                subprocess.run(['taskkill', '/F', '/PID', str(pid)], 
                             capture_output=True, timeout=1)
                success = True
                print(f"‚úÖ TASKKILL SUCCESS: {name}")
            except:
                pass
        
        # Method 4: NtTerminateProcess (kernel-level)
        if not success:
            try:
                ntdll = ctypes.windll.ntdll
                handle = ctypes.windll.kernel32.OpenProcess(0x1F0FFF, False, pid)
                if handle:
                    ntdll.NtTerminateProcess(handle, 1)
                    ctypes.windll.kernel32.CloseHandle(handle)
                    success = True
                    print(f"‚úÖ NT KILL SUCCESS: {name}")
            except:
                pass
        
        if success:
            self.threats_terminated += 1
        else:
            print(f"‚ùå KILL FAILED: {name} (PID: {pid}) - ESCALATING TO SYSTEM LEVEL")
            self.escalate_termination(pid, name)
    
    def escalate_termination(self, pid, name):
        """Escalate to system-level termination"""
        try:
            # Use wmic to force terminate
            subprocess.run([
                'wmic', 'process', 'where', f'ProcessId={pid}', 'delete'
            ], capture_output=True, timeout=2)
            print(f"‚úÖ WMIC KILL SUCCESS: {name}")
            
        except Exception as e:
            print(f"‚ùå FINAL KILL ATTEMPT FAILED: {name} - {e}")
    
    def get_protection_stats(self):
        """Get protection statistics"""
        return {
            'threats_terminated': self.threats_terminated,
            'files_protected': self.files_protected,
            'connections_blocked': self.connections_blocked,
            'registry_attacks_blocked': self.registry_attacks_blocked
        }
    
    def stop_fortress_protection(self):
        """Stop all protection layers"""
        print("üè∞ STOPPING FORTRESS PROTECTION SYSTEM...")
        
        if self.kernel_monitor:
            self.kernel_monitor.stop_monitoring()
            self.kernel_monitor.quit()
            self.kernel_monitor.wait(2000)
        
        if self.file_guard:
            self.file_guard.stop_monitoring()
            self.file_guard.quit()
            self.file_guard.wait(2000)
        
        if self.network_isolator:
            self.network_isolator.stop_monitoring()
            self.network_isolator.quit()
            self.network_isolator.wait(2000)
        
        if self.registry_protector:
            self.registry_protector.stop_monitoring()
            self.registry_protector.quit()
            self.registry_protector.wait(2000)
        
        if self.immediate_terminator:
            self.immediate_terminator.stop_terminator()
            self.immediate_terminator.quit()
            self.immediate_terminator.wait(2000)
        
        # Stop memory protection
        if hasattr(self, 'memory_protection') and self.memory_protection:
            try:
                from memory_protection_layer import stop_memory_protection
                stop_memory_protection()
            except Exception as e:
                print(f"[FORTRESS] Error stopping memory protection: {e}")
        
        # Stop system hardening
        if hasattr(self, 'system_hardening') and self.system_hardening:
            try:
                from system_hardening_engine import stop_system_hardening
                stop_system_hardening()
            except Exception as e:
                print(f"[FORTRESS] Error stopping system hardening: {e}")
        
        # Stop self-protection
        if hasattr(self, 'self_protection') and self.self_protection:
            try:
                from self_protection_system import stop_self_protection
                stop_self_protection()
            except Exception as e:
                print(f"[FORTRESS] Error stopping self-protection: {e}")
        
        # Stop proactive defense
        if hasattr(self, 'proactive_defense') and self.proactive_defense:
            try:
                from proactive_defense_system import stop_proactive_defense
                stop_proactive_defense()
            except Exception as e:
                print(f"[FORTRESS] Error stopping proactive defense: {e}")
        
        stats = self.get_protection_stats()
        print(f"üè∞ FORTRESS PROTECTION STOPPED")
        print(f"üìä FINAL STATS: {stats['threats_terminated']} threats terminated, "
              f"{stats['files_protected']} files protected, "
              f"{stats['connections_blocked']} connections blocked, "
              f"{stats['registry_attacks_blocked']} registry attacks blocked")

# Global fortress instance
fortress_system = None

def start_fortress_protection():
    """Start the fortress protection system"""
    global fortress_system
    fortress_system = FortressProtectionSystem()
    fortress_system.start_fortress_protection()
    return fortress_system

def stop_fortress_protection():
    """Stop the fortress protection system"""
    global fortress_system
    if fortress_system:
        fortress_system.stop_fortress_protection()
        fortress_system = None

if __name__ == "__main__":
    # Test the fortress system
    fortress = start_fortress_protection()
    
    try:
        while True:
            time.sleep(1)
    except KeyboardInterrupt:
        stop_fortress_protection()
