import os
import sys
import json
import time
import signal
import subprocess
from pathlib import Path
from datetime import datetime
from typing import Dict, List, Optional, Tuple, Union

class VolatilityTester:
    """Robust Volatility testing with comprehensive error handling and fallback."""
    
    def __init__(self, dump_file: str):
        """Initialize the tester with paths and configurations."""
        self.dump_file = Path(dump_file).resolve()
        self.results = {
            'timestamp': datetime.now().isoformat(),
            'dump_file': str(self.dump_file),
            'file_size_gb': self.dump_file.stat().st_size / (1024**3) if self.dump_file.exists() else 0,
            'vol3_available': False,
            'vol2_available': False,
            'analysis': {},
            'errors': [],
            'warnings': []
        }
        
        # Configure paths
        self.vol3_path = Path("F:/MalwareAnalysis/Tools/volatility3/vol.py")
        self.vol2_path = Path("F:/MalwareAnalysis/Tools/volatility2/volatility-master/vol.py")
        self.python2_path = Path("C:/Python27/python.exe")
        
        # Set timeout for commands (in seconds)
        self.timeout = 300  # 5 minutes
        
        # Define reliable commands for each version
        self.vol3_commands = [
            'windows.info',
            'windows.pslist',
            'windows.pstree',
            'windows.dlllist',
            'windows.netscan',
            'windows.handles',
            'windows.malfind'
        ]
        
        self.vol2_commands = [
            'imageinfo',
            'pslist',
            'pstree',
            'dlllist',
            'netscan',
            'handles',
            'malfind'
        ]
    
    def log_error(self, message: str, exc_info=None):
        """Log an error message."""
        error = {'message': message, 'time': datetime.now().isoformat()}
        if exc_info:
            error['exception'] = str(exc_info)
        self.results['errors'].append(error)
        print(f"❌ {message}")
    
    def log_warning(self, message: str):
        """Log a warning message."""
        warning = {'message': message, 'time': datetime.now().isoformat()}
        self.results['warnings'].append(warning)
        print(f"⚠️ {message}")
    
    def log_info(self, message: str):
        """Log an informational message."""
        print(f"ℹ️ {message}")
    
    def run_command(self, cmd: List[str], timeout: int = None) -> Dict:
        """Run a command with timeout and capture output."""
        if timeout is None:
            timeout = self.timeout
            
        try:
            self.log_info(f"Running: {' '.join(cmd)}")
            
            # Start the process
            process = subprocess.Popen(
                cmd,
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                text=True,
                encoding='utf-8',
                errors='replace'
            )
            
            # Wait for the process to complete with timeout
            try:
                stdout, stderr = process.communicate(timeout=timeout)
            except subprocess.TimeoutExpired:
                # Try to terminate gracefully first
                process.terminate()
                try:
                    stdout, stderr = process.communicate(timeout=5)
                except subprocess.TimeoutExpired:
                    # Force kill if still not responding
                    process.kill()
                    stdout, stderr = process.communicate()
                
                error_msg = f"Command timed out after {timeout} seconds"
                self.log_warning(error_msg)
                return {
                    'success': False,
                    'error': error_msg,
                    'returncode': -1,
                    'stdout': stdout,
                    'stderr': stderr
                }
            
            # Check if command was successful
            success = process.returncode == 0
            
            if not success:
                self.log_warning(f"Command failed with return code {process.returncode}")
                if stderr:
                    self.log_warning(f"Error output: {stderr.strip()}")
            
            return {
                'success': success,
                'returncode': process.returncode,
                'stdout': stdout,
                'stderr': stderr
            }
            
        except Exception as e:
            error_msg = f"Error executing command: {str(e)}"
            self.log_error(error_msg, e)
            return {
                'success': False,
                'error': error_msg,
                'returncode': -1,
                'stdout': '',
                'stderr': str(e)
            }
    
    def check_vol3_available(self) -> bool:
        """Check if Volatility 3 is available and working."""
        self.log_info("Checking Volatility 3 availability...")
        
        if not self.vol3_path.exists():
            self.log_warning(f"Volatility 3 not found at {self.vol3_path}")
            return False
        
        # Try to get version
        cmd = [sys.executable, str(self.vol3_path), "--version"]
        result = self.run_command(cmd, timeout=30)
        
        if result['success']:
            version = result['stdout'].strip()
            self.log_info(f"Found Volatility 3: {version}")
            self.results['vol3_version'] = version
            return True
        else:
            self.log_warning("Volatility 3 check failed")
            return False
    
    def check_vol2_available(self) -> bool:
        """Check if Volatility 2 is available and working."""
        self.log_info("Checking Volatility 2 availability...")
        
        if not self.python2_path.exists():
            self.log_warning(f"Python 2.7 not found at {self.python2_path}")
            return False
            
        if not self.vol2_path.exists():
            self.log_warning(f"Volatility 2 not found at {self.vol2_path}")
            return False
        
        # Try to get help
        cmd = [str(self.python2_path), str(self.vol2_path), "--help"]
        result = self.run_command(cmd, timeout=30)
        
        if result['success']:
            self.log_info("Volatility 2 is available")
            return True
        else:
            self.log_warning("Volatility 2 check failed")
            return False
    
    def run_vol3_command(self, command: str) -> Dict:
        """Run a single Volatility 3 command."""
        cmd = [sys.executable, str(self.vol3_path), "-f", str(self.dump_file), command]
        return self.run_command(cmd)
    
    def run_vol2_command(self, command: str, profile: str = None) -> Dict:
        """Run a single Volatility 2 command."""
        cmd = [str(self.python2_path), str(self.vol2_path)]
        
        if profile:
            cmd.extend(["--profile", profile])
        
        cmd.extend(["-f", str(self.dump_file), command])
        return self.run_command(cmd)
    
    def detect_vol2_profile(self) -> Optional[str]:
        """Detect the profile for Volatility 2."""
        self.log_info("Detecting Volatility 2 profile...")
        
        # First try imageinfo
        result = self.run_vol2_command("imageinfo")
        
        if not result['success']:
            self.log_warning("Failed to detect profile using imageinfo")
            return None
        
        # Try to extract profile from output
        output = result['stdout']
        
        # Look for suggested profiles
        import re
        match = re.search(r'Suggested Profile\(s\) : (.*?)(?:\r?\n|$)', output)
        if match:
            profiles = [p.strip() for p in match.group(1).split(',')]
            if profiles:
                profile = profiles[0]  # Use the first suggested profile
                self.log_info(f"Detected profile: {profile}")
                return profile
        
        self.log_warning("Could not detect profile from imageinfo output")
        return None
    
    def analyze_with_vol3(self) -> bool:
        """Run analysis using Volatility 3."""
        self.log_info("Starting Volatility 3 analysis...")
        
        if not self.check_vol3_available():
            self.log_warning("Volatility 3 is not available")
            return False
        
        self.results['vol3_available'] = True
        self.results['vol3_analysis'] = {}
        
        # Run each command
        for command in self.vol3_commands:
            self.log_info(f"Running Volatility 3 command: {command}")
            result = self.run_vol3_command(command)
            
            # Store results
            self.results['vol3_analysis'][command] = {
                'success': result['success'],
                'returncode': result['returncode']
            }
            
            if result['success']:
                # Store first 1000 chars of output for reference
                self.results['vol3_analysis'][command]['output_sample'] = result['stdout'][:1000]
                
                # Check if output looks reasonable
                if len(result['stdout']) < 50:
                    self.log_warning(f"Command '{command}' produced very little output")
                    self.results['vol3_analysis'][command]['warning'] = "Minimal output"
            else:
                self.log_warning(f"Command '{command}' failed")
                self.results['vol3_analysis'][command]['error'] = result['stderr']
        
        return any(cmd['success'] for cmd in self.results['vol3_analysis'].values())
    
    def analyze_with_vol2(self) -> bool:
        """Run analysis using Volatility 2 as fallback."""
        self.log_info("Starting Volatility 2 analysis...")
        
        if not self.check_vol2_available():
            self.log_warning("Volatility 2 is not available")
            return False
        
        # Detect profile first
        profile = self.detect_vol2_profile()
        if not profile:
            self.log_warning("Could not detect profile for Volatility 2")
            return False
        
        self.results['vol2_available'] = True
        self.results['vol2_profile'] = profile
        self.results['vol2_analysis'] = {}
        
        # Run each command with the detected profile
        for command in self.vol2_commands:
            self.log_info(f"Running Volatility 2 command: {command}")
            result = self.run_vol2_command(command, profile)
            
            # Store results
            self.results['vol2_analysis'][command] = {
                'success': result['success'],
                'returncode': result['returncode']
            }
            
            if result['success']:
                # Store first 1000 chars of output for reference
                self.results['vol2_analysis'][command]['output_sample'] = result['stdout'][:1000]
                
                # Check if output looks reasonable
                if len(result['stdout']) < 50:
                    self.log_warning(f"Command '{command}' produced very little output")
                    self.results['vol2_analysis'][command]['warning'] = "Minimal output"
            else:
                self.log_warning(f"Command '{command}' failed")
                self.results['vol2_analysis'][command]['error'] = result['stderr']
        
        return any(cmd['success'] for cmd in self.results['vol2_analysis'].values())
    
    def save_results(self, output_file: str = None) -> str:
        """Save analysis results to a JSON file."""
        if output_file is None:
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            output_file = f"volatility_analysis_{timestamp}.json"
        
        with open(output_file, 'w') as f:
            json.dump(self.results, f, indent=2)
        
        self.log_info(f"Analysis results saved to {output_file}")
        return output_file
    
    def run_analysis(self) -> bool:
        """Run the complete analysis with fallback."""
        self.log_info(f"Starting analysis of {self.dump_file}")
        self.log_info(f"File size: {self.results['file_size_gb']:.2f} GB")
        
        # Try Volatility 3 first
        vol3_success = self.analyze_with_vol3()
        
        # Fall back to Volatility 2 if needed
        vol2_success = False
        if not vol3_success:
            self.log_info("Falling back to Volatility 2...")
            vol2_success = self.analyze_with_vol2()
        
        # Save results
        output_file = self.save_results()
        
        # Print summary
        self.log_info("\n=== ANALYSIS SUMMARY ===")
        self.log_info(f"Volatility 3: {'SUCCESS' if vol3_success else 'FAILED'}")
        if not vol3_success:
            self.log_info(f"Volatility 2: {'SUCCESS' if vol2_success else 'FAILED'}")
        
        if not (vol3_success or vol2_success):
            self.log_error("Analysis failed with all available tools")
            return False
        
        self.log_info(f"\nAnalysis complete. Results saved to: {output_file}")
        return True

if __name__ == "__main__":
    if len(sys.argv) < 2:
        print("Usage: python test_volatility_robust.py <path_to_memory_dump> [output_file]")
        sys.exit(1)
    
    dump_file = sys.argv[1]
    output_file = sys.argv[2] if len(sys.argv) > 2 else None
    
    if not os.path.exists(dump_file):
        print(f"Error: File not found: {dump_file}")
        sys.exit(1)
    
    tester = VolatilityTester(dump_file)
    success = tester.run_analysis()
    
    if not success:
        print("\n❌ Analysis completed with errors. Check the output for details.")
        sys.exit(1)
