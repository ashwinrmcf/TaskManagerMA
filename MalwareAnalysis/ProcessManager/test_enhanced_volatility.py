#!/usr/bin/env python3
"""
Enhanced Volatility 3 Kernel Detection Test Script
Tests the comprehensive kernel detection and symbol resolution fixes.
"""

import sys
import subprocess
from pathlib import Path
import time

def test_enhanced_kernel_detection():
    """Test enhanced kernel detection approaches for Volatility 3."""
    
    # Paths
    vol3_path = Path("F:/MalwareAnalysis/Tools/volatility3/vol.py")
    dump_file = Path("F:/MalwareAnalysis/MemDump/DumpSession_20250725_155506/FullDiskDump/FullSystemDump_20250725_155506.raw")
    symbols_dir = vol3_path.parent / "symbols"
    
    print("ğŸ” Enhanced Volatility 3 Kernel Detection Test")
    print("=" * 50)
    print(f"Vol3 Path: {vol3_path}")
    print(f"Dump File: {dump_file}")
    print(f"Symbols Dir: {symbols_dir}")
    print()
    
    # Create symbols directory
    symbols_dir.mkdir(exist_ok=True)
    (symbols_dir / "windows").mkdir(exist_ok=True)
    
    # Test approaches for kernel detection
    approaches = [
        {
            'name': 'Basic Enhanced Detection',
            'cmd': [sys.executable, str(vol3_path), 
                   "--symbol-dirs", str(symbols_dir),
                   "--automagic", "LayerStacker,KernelPDBScanner,SymbolFinder,KernelModule",
                   "-vv", "-f", str(dump_file), "windows.info"],
            'timeout': 300
        },
        {
            'name': 'Forced Kernel Scanning',
            'cmd': [sys.executable, str(vol3_path), 
                   "--symbol-dirs", str(symbols_dir),
                   "--automagic", "LayerStacker,KernelPDBScanner",
                   "-vv", "-f", str(dump_file), "windows.info"],
            'timeout': 300
        },
        {
            'name': 'Memory Map Analysis',
            'cmd': [sys.executable, str(vol3_path), 
                   "--symbol-dirs", str(symbols_dir),
                   "-vv", "-f", str(dump_file), "windows.memmap"],
            'timeout': 180
        },
        {
            'name': 'Banner Detection',
            'cmd': [sys.executable, str(vol3_path), 
                   "--symbol-dirs", str(symbols_dir),
                   "-vv", "-f", str(dump_file), "banners.Banners"],
            'timeout': 120
        },
        {
            'name': 'Layer Writer Test',
            'cmd': [sys.executable, str(vol3_path), 
                   "--symbol-dirs", str(symbols_dir),
                   "-vv", "-f", str(dump_file), "layerwriter.LayerWriter"],
            'timeout': 120
        }
    ]
    
    successful_approaches = []
    
    for i, approach in enumerate(approaches, 1):
        print(f"ğŸ”§ Test {i}/{len(approaches)}: {approach['name']}")
        print(f"Command: {' '.join(approach['cmd'])}")
        print()
        
        try:
            start_time = time.time()
            result = subprocess.run(
                approach['cmd'],
                capture_output=True,
                text=True,
                timeout=approach['timeout']
            )
            end_time = time.time()
            
            print(f"â±ï¸ Execution time: {end_time - start_time:.2f} seconds")
            print(f"Return code: {result.returncode}")
            
            if result.returncode == 0:
                print("âœ… SUCCESS!")
                successful_approaches.append(approach['name'])
                
                # Check for kernel detection indicators
                output_lower = result.stdout.lower()
                if 'kernel' in output_lower:
                    print("ğŸ¯ Kernel information detected in output!")
                if 'symbol' in output_lower:
                    print("ğŸ¯ Symbol information detected in output!")
                if 'layer' in output_lower:
                    print("ğŸ¯ Layer information detected in output!")
                
                # Show first few lines of output
                lines = result.stdout.split('\n')[:10]
                print("ğŸ“„ Output preview:")
                for line in lines:
                    if line.strip():
                        print(f"   {line}")
                
            else:
                print("âŒ FAILED")
                
                # Check for specific error patterns
                error_output = result.stderr + result.stdout
                if 'Unable to validate plugin requirements' in error_output:
                    print("ğŸ” Plugin validation error detected")
                if 'No suitable kernels found' in error_output:
                    print("ğŸ” Kernel detection failure detected")
                if 'symbol' in error_output.lower():
                    print("ğŸ” Symbol-related error detected")
                
                # Show error details
                if result.stderr:
                    print("ğŸ“„ Error output:")
                    error_lines = result.stderr.split('\n')[:5]
                    for line in error_lines:
                        if line.strip():
                            print(f"   {line}")
            
        except subprocess.TimeoutExpired:
            print("â° TIMEOUT - Command took too long")
        except Exception as e:
            print(f"ğŸ’¥ EXCEPTION: {str(e)}")
        
        print("-" * 50)
        print()
    
    # Summary
    print("ğŸ“Š SUMMARY")
    print("=" * 50)
    print(f"Total approaches tested: {len(approaches)}")
    print(f"Successful approaches: {len(successful_approaches)}")
    print(f"Success rate: {len(successful_approaches)/len(approaches)*100:.1f}%")
    
    if successful_approaches:
        print("\nâœ… Successful approaches:")
        for approach in successful_approaches:
            print(f"   â€¢ {approach}")
        print("\nğŸ‰ Enhanced kernel detection is working!")
        return True
    else:
        print("\nâŒ No approaches succeeded")
        print("ğŸ”§ Further investigation needed for kernel detection issues")
        return False

if __name__ == "__main__":
    success = test_enhanced_kernel_detection()
    sys.exit(0 if success else 1)
