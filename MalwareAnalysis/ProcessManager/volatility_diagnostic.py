import sys
import os
import json
import subprocess
import re
import time
from pathlib import Path
from datetime import datetime

class VolatilityDiagnostic:
    def __init__(self, dump_file):
        self.dump_file = Path(dump_file)
        self.vol3_path = Path("F:\\MalwareAnalysis\\Tools\\volatility3\\vol.py")
        self.vol2_path = Path("F:\\MalwareAnalysis\\Tools\\volatility2\\volatility-master\\vol.py")
        self.python2_path = Path("C:\\Python27\\python.exe")
        self.results = {
            'timestamp': datetime.now().isoformat(),
            'dump_file': str(self.dump_file),
            'file_size_gb': self.dump_file.stat().st_size / (1024**3),
            'volatility_3': {},
            'volatility_2': {},
            'recommendations': []
        }

    def run_command(self, cmd, timeout=300):
        """Run a command with timeout and capture output"""
        try:
            result = subprocess.run(
                cmd,
                capture_output=True,
                text=True,
                encoding='utf-8',
                errors='replace',
                timeout=timeout
            )
            return {
                'success': True,
                'returncode': result.returncode,
                'stdout': result.stdout,
                'stderr': result.stderr
            }
        except subprocess.TimeoutExpired:
            return {
                'success': False,
                'error': f'Command timed out after {timeout} seconds',
                'cmd': ' '.join(cmd)
            }
        except Exception as e:
            return {
                'success': False,
                'error': str(e),
                'cmd': ' '.join(cmd)
            }

    def check_vol3_installation(self):
        """Check if Volatility 3 is properly installed"""
        print("ðŸ” Checking Volatility 3 installation...")
        cmd = [sys.executable, str(self.vol3_path), "--version"]
        result = self.run_command(cmd, timeout=30)
        
        if result.get('success') and result.get('returncode') == 0:
            version = result['stdout'].strip()
            print(f"âœ… Volatility 3 found: {version}")
            self.results['volatility_3']['version'] = version
            return True
        else:
            print("âŒ Volatility 3 not found or not working:")
            print(f"   Error: {result.get('error', 'Unknown error')}")
            self.results['volatility_3']['error'] = result.get('error', 'Installation check failed')
            return False

    def check_vol2_installation(self):
        """Check if Volatility 2 is properly installed"""
        print("\nðŸ” Checking Volatility 2 installation...")
        if not self.python2_path.exists():
            print("âŒ Python 2.7 not found at", self.python2_path)
            self.results['volatility_2']['error'] = 'Python 2.7 not found'
            return False
            
        cmd = [str(self.python2_path), str(self.vol2_path), "--info"]
        result = self.run_command(cmd, timeout=30)
        
        if result.get('success') and result.get('returncode') == 0:
            print("âœ… Volatility 2 found and working")
            self.results['volatility_2']['status'] = 'working'
            return True
        else:
            print("âŒ Volatility 2 not working:")
            print(f"   Error: {result.get('error', 'Unknown error')}")
            self.results['volatility_2']['error'] = result.get('error', 'Installation check failed')
            return False

    def analyze_dump(self):
        """Run analysis on the memory dump"""
        print(f"\nðŸ” Analyzing memory dump: {self.dump_file}")
        print(f"   Size: {self.results['file_size_gb']:.2f} GB")
        
        # Try Volatility 3 first
        if self.check_vol3_installation():
            self.run_vol3_analysis()
        
        # Fall back to Volatility 2 if available
        if not self.results['volatility_3'].get('success') and self.check_vol2_installation():
            self.run_vol2_analysis()
        
        self.generate_recommendations()
        self.save_results()

    def run_vol3_analysis(self):
        """Run Volatility 3 analysis"""
        print("\nðŸš€ Running Volatility 3 analysis...")
        
        # Try to get basic system info first
        cmd = [sys.executable, str(self.vol3_path), "-f", str(self.dump_file), "windows.info"]
        result = self.run_command(cmd, timeout=300)
        
        if result['success'] and result['returncode'] == 0:
            print("âœ… Volatility 3 analysis successful")
            self.results['volatility_3']['success'] = True
            self.results['volatility_3']['info'] = result['stdout']
            
            # If basic info works, try more commands
            self.run_vol3_plugins()
        else:
            print("âŒ Volatility 3 analysis failed:")
            print(result.get('stderr', ''))
            self.results['volatility_3']['error'] = result.get('stderr', 'Unknown error')
    
    def run_vol3_plugins(self):
        """Run additional Volatility 3 plugins"""
        plugins = [
            "windows.pslist",
            "windows.pstree",
            "windows.dlllist",
            "windows.netscan",
            "windows.handles"
        ]
        
        self.results['volatility_3']['plugins'] = {}
        
        for plugin in plugins:
            print(f"\nðŸ” Running {plugin}...")
            cmd = [sys.executable, str(self.vol3_path), "-f", str(self.dump_file), plugin]
            result = self.run_command(cmd, timeout=300)
            
            if result['success'] and result['returncode'] == 0:
                print(f"âœ… {plugin} completed successfully")
                self.results['volatility_3']['plugins'][plugin] = {
                    'status': 'success',
                    'output': result['stdout']
                }
            else:
                print(f"âš ï¸ {plugin} failed")
                self.results['volatility_3']['plugins'][plugin] = {
                    'status': 'failed',
                    'error': result.get('stderr', 'Unknown error')
                }
    
    def run_vol2_analysis(self):
        """Run Volatility 2 analysis"""
        print("\nðŸš€ Running Volatility 2 analysis...")
        
        # First try to detect the profile
        cmd = [str(self.python2_path), str(self.vol2_path), "-f", str(self.dump_file), "imageinfo"]
        result = self.run_command(cmd, timeout=300)
        
        if result['success'] and result['returncode'] == 0:
            print("âœ… Volatility 2 profile detection successful")
            self.results['volatility_2']['profile'] = self.extract_profile(result['stdout'])
            
            # Run additional plugins with the detected profile
            self.run_vol2_plugins()
        else:
            print("âŒ Volatility 2 profile detection failed")
            self.results['volatility_2']['error'] = 'Profile detection failed'
    
    def extract_profile(self, output):
        """Extract profile from imageinfo output"""
        match = re.search(r'Suggested Profile\(s\) : (.*?)(?:\r?\n|$)', output)
        if match:
            return match.group(1).strip()
        return 'Unknown'
    
    def run_vol2_plugins(self):
        """Run additional Volatility 2 plugins"""
        plugins = [
            "pslist",
            "pstree",
            "dlllist",
            "netscan",
            "handles"
        ]
        
        self.results['volatility_2']['plugins'] = {}
        profile = self.results['volatility_2'].get('profile', '')
        
        for plugin in plugins:
            print(f"\nðŸ” Running {plugin}...")
            cmd = [str(self.python2_path), str(self.vol2_path), "-f", str(self.dump_file), f"--profile={profile}", plugin]
            result = self.run_command(cmd, timeout=300)
            
            if result['success'] and result['returncode'] == 0:
                print(f"âœ… {plugin} completed successfully")
                self.results['volatility_2']['plugins'][plugin] = {
                    'status': 'success',
                    'output': result['stdout']
                }
            else:
                print(f"âš ï¸ {plugin} failed")
                self.results['volatility_2']['plugins'][plugin] = {
                    'status': 'failed',
                    'error': result.get('stderr', 'Unknown error')
                }
    
    def generate_recommendations(self):
        """Generate recommendations based on analysis results"""
        recommendations = []
        
        # Check file size
        if self.results['file_size_gb'] > 8:
            recommendations.append(
                f"The memory dump is large ({self.results['file_size_gb']:.2f} GB). Consider using a machine with more RAM for analysis."
            )
        
        # Check Volatility 3 status
        if not self.results['volatility_3'].get('success'):
            recommendations.append(
                "Volatility 3 analysis failed. Check if the memory dump is valid and complete."
            )
        
        # Check Volatility 2 status
        if 'volatility_2' in self.results and 'error' in self.results['volatility_2']:
            recommendations.append(
                f"Volatility 2 error: {self.results['volatility_2']['error']}"
            )
        
        self.results['recommendations'] = recommendations
    
    def save_results(self):
        """Save results to a JSON file"""
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        output_file = f"volatility_analysis_{timestamp}.json"
        
        with open(output_file, 'w') as f:
            json.dump(self.results, f, indent=2)
        
        print(f"\nâœ… Analysis complete. Results saved to {output_file}")
        print("\nðŸ“‹ Recommendations:")
        for rec in self.results['recommendations']:
            print(f"- {rec}")

if __name__ == "__main__":
    if len(sys.argv) < 2:
        print("Usage: python volatility_diagnostic.py <path_to_memory_dump>")
        sys.exit(1)
    
    dump_file = sys.argv[1]
    if not os.path.exists(dump_file):
        print(f"Error: File not found: {dump_file}")
        sys.exit(1)
    
    diagnostic = VolatilityDiagnostic(dump_file)
    diagnostic.analyze_dump()
