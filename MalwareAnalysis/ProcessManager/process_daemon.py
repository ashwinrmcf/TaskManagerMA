import os
import sys
import time
import signal
import logging
import psutil
import subprocess
from datetime import datetime
from pathlib import Path

# --- Import kill1 and use its functions ---
sys.path.append(r"F:\MalwareAnalysis\ProcessManager")
import kill1


def setup_logging():
    """Configure logging for the daemon"""
    log_dir = Path(r"F:\MalwareAnalysis\Logs\ProcessMonitor")
    log_dir.mkdir(parents=True, exist_ok=True)
    
    logging.basicConfig(
        level=logging.INFO,
        format='%(asctime)s - %(levelname)s - %(message)s',
        handlers=[
            logging.FileHandler(log_dir / 'process_daemon.log'),
            logging.StreamHandler()
        ]
    )

# Use kill1.is_admin instead of local is_admin


# Use kill1.capture_memory_dump instead of local capture_memory_dump


# Use kill1.analyze_memory_dump instead of local analyze_memory_dump


class ProcessMonitorDaemon:
    def __init__(self, interval=300, max_dumps=5):
        self.interval = interval  # seconds between checks
        self.max_dumps = max_dumps
        self.running = False
        self.dump_dir = Path("C:/MemoryDumps")
        self.dump_dir.mkdir(parents=True, exist_ok=True)
        self.dump_count = 0
        
    def signal_handler(self, signum, frame):
        """Handle termination signals"""
        logging.info("Received shutdown signal, cleaning up...")
        self.running = False
        
    def monitor_processes(self):
        """Monitor running processes"""
        try:
            for proc in psutil.process_iter(['pid', 'name', 'username']):
                try:
                    # Add your process monitoring logic here
                    pass
                except (psutil.NoSuchProcess, psutil.AccessDenied):
                    continue
        except Exception as e:
            logging.error(f"Error monitoring processes: {str(e)}")
    
    def run(self):
        """Main daemon loop"""
        # Set up signal handlers
        signal.signal(signal.SIGTERM, self.signal_handler)
        signal.signal(signal.SIGINT, self.signal_handler)
        
        logging.info("Starting process monitoring daemon")
        self.running = True
        
        try:
            while self.running:
                # Monitor processes
                self.monitor_processes()
                
                # Capture and analyze memory dump at intervals
                if self.dump_count < self.max_dumps:
                    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
                    dump_path = self.dump_dir / f"memory_dump_{timestamp}.raw"
                    
                    if kill1.capture_memory_dump(str(dump_path)):
                        self.dump_count += 1
                        kill1.analyze_memory_dump(str(dump_path))
                
                # Sleep until next interval
                for _ in range(self.interval):
                    if not self.running:
                        break
                    time.sleep(1)
                
        except Exception as e:
            logging.critical(f"Daemon error: {str(e)}", exc_info=True)
        finally:
            logging.info("Process monitoring daemon stopped")

def main():
    import ctypes
    
    # Check for admin privileges
    if not kill1.is_admin():
        if '--elevated' not in sys.argv:
            # Only try to elevate once
            params = ' '.join([*sys.argv, '--elevated'])
            ctypes.windll.shell32.ShellExecuteW(
                None, 'runas', sys.executable, params, None, 1)
        else:
            print("[ERROR] Could not obtain admin rights. Exiting.")
        return
    
    # Set up logging
    setup_logging()
    
    # Create and start the daemon
    daemon = ProcessMonitorDaemon(
        interval=300,  # 5 minutes between checks
        max_dumps=10   # Maximum number of dumps to keep
    )
    
    try:
        daemon.run()
    except KeyboardInterrupt:
        logging.info("Daemon stopped by user")
    except Exception as e:
        logging.critical(f"Fatal error: {str(e)}", exc_info=True)
    
    logging.info("Shutdown complete")

if __name__ == "__main__":
    # For Windows service compatibility
    if len(sys.argv) == 2:
        if sys.argv[1] == 'install':
            # Code to install as a Windows service would go here
            print("Service installation not implemented")
        elif sys.argv[1] == 'uninstall':
            # Code to uninstall the Windows service would go here
            print("Service uninstallation not implemented")
        else:
            print(f"Unknown command: {sys.argv[1]}")
            sys.exit(1)
    else:
        main()
