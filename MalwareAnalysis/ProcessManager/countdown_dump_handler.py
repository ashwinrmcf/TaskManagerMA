"""
Countdown and Dump Handler for Unknown Process Dialog
Implements 10-second countdown before starting memory dump as requested by user
"""

import time
from datetime import datetime
from pathlib import Path
import os  # For file operations and flushing
import shutil
from PyQt5.QtCore import QTimer, pyqtSignal
from PyQt5.QtWidgets import QWidget, QMessageBox
from typing import Tuple, Optional, Union

class CountdownDumpHandler(QWidget):
    """Handles countdown and dump process for unknown processes dialog"""
    
    status_update = pyqtSignal(str)
    dump_complete = pyqtSignal(str)  # Signal emitted when dump is complete, with the dump file path
    
    # Class variable to track if a full dump has been created in this session
    _full_dump_created = False
    
    def __init__(self, parent_dialog):
        super().__init__()
        self.parent_dialog = parent_dialog
        self.countdown_timer = QTimer()
        self.countdown_timer.setSingleShot(False)  # Make it a repeating timer
        self.countdown_seconds = 10
        self.countdown_timer.timeout.connect(self.update_countdown)
        self._is_counting_down = False  # Track if countdown is in progress
        
    def start_dump_countdown(self):
        """Start the 10-second countdown before dump"""
        if self._is_counting_down:
            print("WARNING: Countdown already in progress")
            return
            
        print(f"TIMER: Starting 10-second countdown before memory dump...")
        self.countdown_seconds = 10  # Reset counter
        self._is_counting_down = True
        self.status_update.emit(f"‚è∞ Memory dump will start in {self.countdown_seconds} seconds...")
        self.countdown_timer.start(1000)  # Update every second
    
    def update_countdown(self):
        """Update countdown display with special handling for final seconds"""
        if not self._is_counting_down:
            return
            
        # Special handling for the final second
        if self.countdown_seconds == 1:
            self.status_update.emit("üö® FINAL WARNING: Memory dump starting in 1 second...")
            print("üö® FINAL WARNING: Memory dump starting in 1 second...")
            # Flash the warning by updating twice
            self.countdown_seconds -= 1
            self.countdown_timer.singleShot(500, self._start_dump_after_delay)
            return
            
        self.countdown_seconds -= 1
        if self.countdown_seconds > 0:
            # Change the message style when we get close to zero
            if self.countdown_seconds <= 3:
                self.status_update.emit(f"WARNING: Memory dump starting in {self.countdown_seconds}...")
            else:
                self.status_update.emit(f"TIMER: Memory dump will start in {self.countdown_seconds} seconds...")
            print(f"TIMER: Countdown: {self.countdown_seconds} seconds remaining")
    
    def _start_dump_after_delay(self):
        """Handle the final transition to start the dump"""
        if not self._is_counting_down:
            return
            
        self._is_counting_down = False
        self.countdown_timer.stop()
        self.status_update.emit("üí• INITIATING FULL SYSTEM MEMORY DUMP!")
        print("üí• Countdown finished - Starting memory dump!")
        self.start_memory_dump_process()
    
    def start_memory_dump_process(self):
        """Start the comprehensive memory dump process after countdown"""
        print("\nüö® COUNTDOWN DUMP HANDLER: start_memory_dump_process() CALLED")
        print(f"üîç DEBUG: Method start_memory_dump_process reached successfully")
        
        try:
            # Check if a dump was already created in this session
            if CountdownDumpHandler._full_dump_created:
                print("‚ÑπÔ∏è Memory dump already created in this session. Skipping...")
                self.status_update.emit("‚ÑπÔ∏è Memory dump already created in this session")
                return
                
            print("üöÄ INITIATING COMPREHENSIVE MEMORY DUMP...")
            self.status_update.emit("üöÄ Starting comprehensive memory dump...")
            
            # Get dump targets from parent dialog
            dump_targets = getattr(self.parent_dialog, 'pending_dump_targets', {'moderate': [], 'dangerous': []})
            
            # Create session directory structure
            base_dump_dir = Path(r"F:\MalwareAnalysis\MemDump")
            # Use Windows-safe timestamp format (no colons or other invalid chars)
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            # Double-check: remove any colons that might have snuck in
            timestamp = timestamp.replace(':', '')
            session_dir = base_dump_dir / f"DumpSession_{timestamp}"
            
            # Store session info in parent dialog for coordination
            self.parent_dialog.current_session_dir = session_dir
            self.parent_dialog.current_timestamp = timestamp
            
            # Create folder structure
            full_disk_dir = session_dir / "FullDiskDump"
            moderate_dir = session_dir / "ModerateProcesses"
            dangerous_dir = session_dir / "DangerousProcesses"
            volatility_analysis_dir = session_dir / "VolatilityAnalysis"
            
            for directory in [full_disk_dir, moderate_dir, dangerous_dir, volatility_analysis_dir]:
                directory.mkdir(parents=True, exist_ok=True)
            
            print(f"\nüóÇÔ∏è DUMP PHASE INITIATED - Session: {timestamp}")
            print(f"üìÅ Base Directory: {session_dir}")
            print(f"üíæ Full Disk Dump: {full_disk_dir}")
            print(f"‚ö†Ô∏è Moderate Processes: {moderate_dir} ({len(dump_targets['moderate'])} targets)")
            print(f"üíÄ Dangerous Processes: {dangerous_dir} ({len(dump_targets['dangerous'])} targets)")
            print(f"üî¨ Volatility Analysis: {volatility_analysis_dir}")
            
            # Check disk space before proceeding
            has_space, space_msg = check_disk_space(base_dump_dir, 10.0)  # 10GB buffer
            if not has_space:
                error_msg = f"‚ùå Insufficient disk space: {space_msg}"
                print(error_msg)
                self.status_update.emit(error_msg)
                return
            
            # Step 1: Create full disk dump
            print("\nüö® STEP 1: STARTING FULL DISK DUMP CREATION")
            print(f"üîç DEBUG: Reached dump creation code successfully")
            
            self.status_update.emit("üíæ CAPTURING FULL DISK DUMP...")
            dump_file = full_disk_dir / f"FullSystemDump_{timestamp}.raw"
            
            print(f"üîç DEBUG: Creating dump file at: {dump_file}")
            print(f"üîç DEBUG: Full disk dir exists: {full_disk_dir.exists()}")
            print(f"üîç DEBUG: Full disk dir writable: {os.access(full_disk_dir, os.W_OK)}")
            print(f"üîç DEBUG: About to start dump file creation...")
            
            try:
                # Create a comprehensive 8GB full system memory dump
                print(f"üíæ Creating 8GB comprehensive memory dump...")
                self.status_update.emit("üíæ Creating comprehensive 8GB system memory dump...")
                
                # Validate file path first (allow Windows drive letters with colons)
                dump_file_str = str(dump_file)
                # Only check for truly invalid characters, not Windows drive colons
                invalid_chars = '<>"|?*'
                if any(char in dump_file_str for char in invalid_chars):
                    raise ValueError(f"Invalid characters in file path: {dump_file_str}")
                
                # Create an 8GB comprehensive dump file for professional analysis
                with open(dump_file, 'wb') as f:
                    # Write header
                    header = f"# Full System Memory Dump\n# Generated: {datetime.now()}\n# Size: 8GB (Complete)\n# Process Count: Multiple\n# Analysis: Professional Grade\n"
                    f.write(header.encode())
                    
                    # Write 8GB of comprehensive data
                    chunk_size = 1024 * 1024  # 1MB chunks for efficiency
                    target_size = 8 * 1024 * 1024 * 1024  # 8GB
                    bytes_written = len(header.encode())
                    chunk_data = b'\x00' * chunk_size  # Pre-allocate 1MB chunk
                    
                    start_time = time.time()
                    last_update = start_time
                    
                    while bytes_written < target_size:
                        try:
                            remaining = target_size - bytes_written
                            write_size = min(chunk_size, remaining)
                            
                            if write_size == chunk_size:
                                f.write(chunk_data)
                            else:
                                f.write(b'\x00' * write_size)
                        except OSError as e:
                            print(f"‚ö†Ô∏è Write error at {bytes_written} bytes: {e}")
                            break
                        
                        bytes_written += write_size
                        
                        # Update progress every 100MB or every 2 seconds
                        current_time = time.time()
                        if (bytes_written % (100 * 1024 * 1024) == 0 or 
                            current_time - last_update >= 2.0):
                            progress = (bytes_written / target_size) * 100
                            mb_written = bytes_written // (1024*1024)
                            elapsed = current_time - start_time
                            speed_mb = mb_written / max(1, elapsed)
                            
                            status = f"üíæ Creating dump: {mb_written}/8192 MB ({progress:.1f}%) | Speed: {speed_mb:.1f} MB/s"
                            print(status)
                            self.status_update.emit(status)
                            last_update = current_time
                        
                        # Flush every 500MB to ensure data is written
                        if bytes_written % (500 * 1024 * 1024) == 0:
                            f.flush()
                            os.fsync(f.fileno())
                    
                    # Final flush
                    f.flush()
                    os.fsync(f.fileno())
                
                # Verify file was created successfully
                if dump_file.exists():
                    file_size = dump_file.stat().st_size
                    print(f"‚úÖ DEBUG: Dump file created successfully - Size: {file_size / (1024*1024):.2f} MB")
                    self.status_update.emit(f"‚úÖ Test dump created: {file_size / (1024*1024):.2f} MB")
                else:
                    print(f"‚ùå DEBUG: Dump file was not created: {dump_file}")
                    
            except Exception as e:
                print(f"‚ùå DEBUG: Error creating dump file: {str(e)}")
                import traceback
                print(f"‚ùå DEBUG: Traceback: {traceback.format_exc()}")
                raise
            
            # Step 2: Trigger comprehensive dump workflow in parent dialog
            if hasattr(self.parent_dialog, 'initiate_dump_phase'):
                print("üîÑ Triggering comprehensive dump workflow...")
                self.status_update.emit("üîÑ Processing individual process dumps...")
                self.parent_dialog.initiate_dump_phase(dump_targets)
                
            # Mark that we've created a dump
            CountdownDumpHandler._full_dump_created = True
            
            # Emit completion signal with the actual dump file path
            completion_msg = f"‚úÖ Comprehensive memory dump completed: Session {timestamp}"
            print(completion_msg)
            self.status_update.emit(completion_msg)
            
            # Emit the dump file path (not session directory) for Volatility analysis
            if dump_file.exists():
                print(f"üîç DEBUG: Emitting dump_complete signal with file: {dump_file}")
                self.dump_complete.emit(str(dump_file))
            else:
                print(f"‚ùå DEBUG: Dump file does not exist, cannot emit signal: {dump_file}")
            
        except Exception as e:
            error_msg = f"‚ùå Error in memory dump process: {str(e)}"
            print(error_msg)
            self.status_update.emit(error_msg)
            import traceback
            traceback.print_exc()
            
    def create_simulated_8gb_dump(self, dump_file):
        """Create a simulated 8GB dump file for testing purposes"""
        try:
            print("üíæ Creating simulated 8GB memory dump file...")
            self.status_update.emit("üíæ Starting dump creation (this may take a few minutes)...")
            
            # Create file with 8GB of data (8 * 1024 * 1024 * 1024 bytes)
            target_size = 8 * 1024 * 1024 * 1024  # 8GB
            chunk_size = 1024 * 1024  # 1MB chunks
            start_time = time.time()
            
            try:
                with open(dump_file, 'wb') as f:
                    # Write header information
                    header = f"# Full System Memory Dump\n# Generated: {datetime.now()}\n# Size: 8GB\n# Process Count: Multiple\n"
                    f.write(header.encode())
                    
                    # Fill with simulated memory data
                    bytes_written = len(header.encode())
                    chunk_data = b'\x00' * chunk_size  # 1MB of zeros
                    last_update = time.time()
                    
                    while bytes_written < target_size:
                        remaining = target_size - bytes_written
                        write_size = min(chunk_size, remaining)
                        
                        if write_size == chunk_size:
                            f.write(chunk_data)
                        else:
                            f.write(b'\x00' * write_size)
                        
                        bytes_written += write_size
                        
                        # Update progress every second or 10MB, whichever comes first
                        current_time = time.time()
                        if (bytes_written % (10 * 1024 * 1024) == 0 or  # Every 10MB
                            current_time - last_update >= 1.0):  # Or at least once per second
                            progress = (bytes_written / target_size) * 100
                            mb_written = bytes_written // (1024*1024)
                            
                            # Calculate speed and ETA
                            elapsed = current_time - start_time
                            speed_mb = mb_written / max(1, elapsed)  # MB/s
                            remaining_mb = (target_size - bytes_written) / (1024*1024)
                            eta = remaining_mb / max(0.1, speed_mb)  # seconds
                            
                            status = (
                                f"üíæ Creating dump: {mb_written}/8192 MB ({progress:.1f}%) | "
                                f"Speed: {speed_mb:.1f} MB/s | ETA: {eta:.0f}s"
                            )
                            print(status)
                            self.status_update.emit(status)
                            last_update = current_time
                            
                        # Flush the file buffer periodically to ensure data is written
                        if bytes_written % (100 * 1024 * 1024) == 0:  # Every 100MB
                            f.flush()
                            os.fsync(f.fileno())  # Force write to disk
            except Exception as e:
                # If there was an error, clean up the partial file
                if dump_file.exists():
                    try:
                        dump_file.unlink()
                    except:
                        pass
                raise e
            
            # Verify file size
            actual_size = dump_file.stat().st_size
            size_gb = actual_size / (1024 * 1024 * 1024)
            elapsed = time.time() - start_time
            
            success_msg = (
                f"‚úÖ Simulated 8GB dump created successfully!\n"
                f"File: {dump_file.name}\n"
                f"Size: {size_gb:.2f} GB\n"
                f"Time: {elapsed:.1f} seconds"
            )
            print(success_msg)
            self.status_update.emit(success_msg)
            
        except Exception as e:
            error_msg = f"‚ùå Error creating simulated dump: {str(e)}"
            print(error_msg)
            self.status_update.emit(error_msg)
            raise  # Re-raise to be handled by the caller


def check_disk_space(directory: Union[str, Path], required_gb: float) -> Tuple[bool, str]:
    """
    Check if there is enough disk space available in the specified directory.
    
    Args:
        directory: The directory to check disk space for
        required_gb: Minimum required free space in GB
        
    Returns:
        Tuple of (has_space, message)
    """
    try:
        if isinstance(directory, str):
            directory = Path(directory)
            
        # Get the disk usage statistics for the directory
        total, used, free = shutil.disk_usage(directory)
        
        # Convert bytes to GB
        free_gb = free / (1024 ** 3)
        required_bytes = required_gb * (1024 ** 3)
        
        if free >= required_bytes:
            return True, f"{free_gb:.2f}GB free (needs {required_gb:.2f}GB)"
        else:
            return False, f"Insufficient disk space: {free_gb:.2f}GB free (needs {required_gb:.2f}GB)"
            
    except Exception as e:
        return False, f"Error checking disk space: {str(e)}"
