#!/usr/bin/env python3
"""
Standalone Volatility Log Cleaner
Removes all progress messages from Volatility analysis log files and keeps only the actual forensic results.

Usage:
    python clean_volatility_logs.py [log_file_path]
    
If no path is provided, it will clean the default volatility_analysis.log file.
"""

import sys
import re
from pathlib import Path


def clean_volatility_log_file(log_file_path):
    """
    Clean a Volatility log file by removing all progress messages and keeping only results.
    
    Args:
        log_file_path (Path): Path to the log file to clean
        
    Returns:
        tuple: (success, original_lines, cleaned_lines, removed_lines)
    """
    try:
        if not log_file_path.exists():
            print(f"âŒ Log file not found: {log_file_path}")
            return False, 0, 0, 0
        
        print(f"ğŸ§¹ Cleaning log file: {log_file_path}")
        
        # Read the current log file
        with open(log_file_path, 'r', encoding='utf-8', errors='replace') as f:
            lines = f.readlines()
        
        original_count = len(lines)
        print(f"ğŸ“„ Original file has {original_count} lines")
        
        # Filter out progress and verbose messages
        cleaned_lines = []
        skip_patterns = [
            'Progress:',
            'progress:',
            'Scanning memory_layer using',
            'Scanning FileLayer using',
            'Scanning layer_name using',
            'BytesScanner',
            'PageMapScanner',
            'PdbSignatureScanner',
            'Stacking attempts finished',
            'PDB scanning finished',
            'using BytesScanner',
            'using PageMapScanner',
            'using PdbSignatureScanner',
            'Scanner',
            '\tScanning',
            'Processing',
            'Completed',
            'finished'
        ]
        
        # Regex patterns for progress indicators
        progress_regex_patterns = [
            r'Progress:\s*\d+\.\d+',
            r'\d+\.\d+\s*%',
            r'\d+\.\d+\s+\w+',  # e.g., "23.33    Scanning"
            r'^\d+\.\d+\s*$',   # Just numbers
            r'Progress:\s*\d+\.\d+\s+.*Scanner',
            r'\d+\.\d+\s+Scanning.*using.*Scanner'
        ]
        
        # Keywords that indicate actual forensic results
        result_keywords = [
            'Variable', 'Value', 'Kernel', 'Base', 'DTB', 'Symbols', 'Is64Bit', 'IsPAE',
            'layer_name', 'memory_layer', 'KdVersionBlock', 'Major/Minor', 'MachineType',
            'KeNumberProcessors', 'SystemTime', 'NtSystemRoot', 'NtProductType',
            'NtMajorVersion', 'NtMinorVersion', 'PE MajorOperatingSystemVersion',
            'PE MinorOperatingSystemVersion', 'PE Machine', 'PE TimeDateStamp',
            'PID', 'PPID', 'Name', 'Offset', 'Threads', 'Handles', 'SessionId',
            'Wow64', 'CreateTime', 'ExitTime', 'ImageFileName', 'CommandLine',
            'Base', 'Size', 'Path', 'Command', 'User', 'Time', 'Handle', 'Address',
            'Type', 'Data', 'Registry', 'Network', 'Connection', 'Socket', 'File',
            'Module', 'DLL', 'Driver', 'Service', 'Process', 'Thread', 'Memory',
            'Heap', 'Stack', 'VAD', 'EPROCESS', 'ETHREAD', 'System', 'Windows',
            'NTDLL', 'kernel32', 'ntoskrnl', 'hal.dll', 'win32k', 'csrss',
            'winlogon', 'explorer', 'svchost', 'lsass', 'smss', 'wininit',
            'services', 'spoolsv', 'dwm', 'taskhost', 'RuntimeBroker', 'conhost',
            'dllhost', 'rundll32', 'cmd.exe', 'powershell', 'python', 'java',
            'chrome', 'firefox', 'edge', 'notepad', 'calc', 'mspaint', 'winword',
            'excel', 'outlook', 'skype', 'discord', 'steam', 'malware', 'virus',
            'trojan', 'backdoor', 'rootkit', 'keylogger', 'ransomware', 'spyware',
            'adware', 'suspicious', 'anomaly', 'injection', 'hollowing', 'hook',
            'patch', 'modification', 'hidden', 'encrypted', 'packed', 'obfuscated',
            'shellcode', 'payload', 'exploit', 'vulnerability', 'CVE-', 'MITRE',
            'ATT&CK', 'Volatility', 'Framework'
        ]
        
        for line in lines:
            line_stripped = line.strip()
            
            # Skip empty lines
            if not line_stripped:
                continue
            
            # Check for skip patterns
            should_skip = False
            for pattern in skip_patterns:
                if pattern.lower() in line_stripped.lower():
                    should_skip = True
                    break
            
            # Check regex patterns
            if not should_skip:
                for regex_pattern in progress_regex_patterns:
                    if re.search(regex_pattern, line_stripped):
                        should_skip = True
                        break
            
            # Keep lines that contain actual results
            if not should_skip:
                # Check if line contains forensic data indicators
                contains_result_data = (
                    len(line_stripped) > 3 and
                    not line_stripped.isspace() and
                    (
                        '=' in line_stripped or 
                        '\t' in line_stripped or
                        any(keyword in line_stripped for keyword in result_keywords) or
                        line_stripped.startswith('===') or
                        line_stripped.startswith('---') or
                        line_stripped.startswith('[') or
                        line_stripped.startswith('ğŸ”') or
                        line_stripped.startswith('âš ï¸') or
                        line_stripped.startswith('âŒ') or
                        line_stripped.startswith('âœ…') or
                        line_stripped.startswith('ğŸ”„') or
                        line_stripped.startswith('ğŸ“Š') or
                        line_stripped.startswith('ğŸ‰') or
                        line_stripped.startswith('ğŸ’¡') or
                        line_stripped.startswith('ğŸ›¡ï¸') or
                        line_stripped.startswith('ğŸ”¬') or
                        line_stripped.startswith('ğŸš¨') or
                        line_stripped.startswith('ğŸ§¹')
                    )
                )
                
                if contains_result_data:
                    cleaned_lines.append(line)
        
        # Write the cleaned log back
        with open(log_file_path, 'w', encoding='utf-8', errors='replace') as f:
            f.writelines(cleaned_lines)
        
        cleaned_count = len(cleaned_lines)
        removed_count = original_count - cleaned_count
        
        print(f"âœ… Cleaning completed:")
        print(f"   ğŸ“„ Original lines: {original_count}")
        print(f"   âœ… Kept lines: {cleaned_count}")
        print(f"   ğŸ—‘ï¸ Removed lines: {removed_count}")
        print(f"   ğŸ“Š Reduction: {(removed_count/original_count)*100:.1f}%")
        
        return True, original_count, cleaned_count, removed_count
        
    except Exception as e:
        print(f"âŒ Error cleaning log file: {str(e)}")
        return False, 0, 0, 0


def main():
    """Main function to run the log cleaner"""
    print("ğŸ§¹ Volatility Log Cleaner")
    print("=" * 50)
    
    # Determine log file path
    if len(sys.argv) > 1:
        log_file_path = Path(sys.argv[1])
    else:
        # Use default path
        log_file_path = Path(r"F:\MalwareAnalysis\Logs\Volatility\volatility_analysis.log")
    
    print(f"Target log file: {log_file_path}")
    
    # Clean the log file
    success, original, cleaned, removed = clean_volatility_log_file(log_file_path)
    
    if success and removed > 0:
        print(f"\nğŸ‰ Successfully cleaned the log file!")
        print(f"Your log now contains only the actual forensic analysis results.")
    elif success and removed == 0:
        print(f"\nâœ… Log file was already clean (no progress messages found).")
    else:
        print(f"\nâŒ Failed to clean the log file.")
        sys.exit(1)


if __name__ == "__main__":
    main()
