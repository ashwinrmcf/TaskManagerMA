import os
import sys
import ctypes
import psutil
import subprocess
import time
import threading
import re

def is_admin():
    if ctypes.windll.shell32.IsUserAnAdmin():
        print("Is_admin")
    else:
        ctypes.windll.shell32.ShellExecuteW(None, 'runas', sys.executable, r"F:\MalwareAnalysis\ProcessManager\kill1.py", None, 1)

def capture_memory_dump(dump_path=None):
    """Captures a memory dump to the specified path."""
    try:
        # Set default path if none provided
        if dump_path is None:
            base_dir = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'MemDump')
            os.makedirs(base_dir, exist_ok=True)
            dump_path = os.path.join(base_dir, 'memory_dump.raw')
        
        # Ensure the directory exists
        dump_dir = os.path.dirname(os.path.abspath(dump_path))
        os.makedirs(dump_dir, exist_ok=True)
        
        print(f"[DEBUG] Attempting to capture memory dump to: {dump_path}")
        print(f"[DEBUG] Current working directory: {os.getcwd()}")
        
        # Check if winpmem_mini.exe exists in the current directory
        winpmem_path = os.path.join(os.getcwd(), "winpmem_mini.exe")
        if not os.path.isfile(winpmem_path):
            print(f"[ERROR] winpmem_mini.exe not found at: {winpmem_path}")
            return False
        
        print(f"[DEBUG] winpmem_mini.exe found at: {winpmem_path}")
        
        # Run the memory capture with admin privileges
        try:
            result = subprocess.run(
                [winpmem_path, dump_path], 
                capture_output=True, 
                text=True,
                cwd=os.getcwd(),  # Run from current directory
                shell=True,  # Required for admin privileges
                check=False  # Don't raise exception on non-zero exit code
            )
            
            print(f"[DEBUG] winpmem_mini.exe exit code: {result.returncode}")
            print(f"[DEBUG] winpmem_mini.exe output: {result.stdout}")
            
            # WinPMem often returns non-zero even on success, so we'll check if the file was created instead
            if result.returncode != 0 and not os.path.exists(dump_path):
                print(f"[ERROR] winpmem_mini.exe failed with exit code {result.returncode}")
                print(f"[ERROR] stderr: {result.stderr}")
                return False
                
        except Exception as e:
            print(f"[ERROR] Error running winpmem_mini.exe: {str(e)}")
            if not os.path.exists(dump_path):
                return False
        
        # Verify the dump file was created
        if not os.path.isfile(dump_path):
            print(f"[ERROR] Memory dump file not found at: {dump_path}")
            print("[DEBUG] Directory contents:")
            for f in os.listdir(dump_dir):
                print(f"  - {f}")
            return False
            
        print(f"[SUCCESS] Memory dump created at: {dump_path}")
        print(f"[DEBUG] Dump file size: {os.path.getsize(dump_path) / (1024*1024):.2f} MB")
        return True
        
    except Exception as e:
        print(f"[EXCEPTION] Error in capture_memory_dump: {str(e)}")
        import traceback
        traceback.print_exc()
        return False

def analyze_memory_dump(dump_path=r"F:\MalwareAnalysis\MemDump\memory_dump.raw", output_file='123.txt'):
    """Analyzes the memory dump for malicious processes using Volatility."""
    
    if not os.path.isfile(dump_path):
        print(f"Error: The specified dump path does not exist: {dump_path}")
        return

    print(f"Analyzing memory dump {dump_path} for malicious processes...")
    volatility_script = r"F:\MalwareAnalysis\Tools\volatility3\vol.py"

    result = subprocess.run(
        ["python", volatility_script, "-f", dump_path, "windows.malfind"],
        stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True
    )

    if result.returncode != 0:
        print("Error during analysis:")
        print(result.stderr)
        return
    
    with open(output_file, 'w') as file:
        file.write(result.stdout)

    print(f"Analysis complete. Results saved to {output_file}")

essential_processes = {
    'System Idle Process','OneDriveSetup.exe','PhotosApp.exe','SystemSettings.exe','UserOOBEBroker.exe','WerFault.exe','WindowsPackageManagerServer.exe','winpmem_mini.exe','UserOOBEBroker.exe','SystemSettings.exe', 'System', 'Registry', 'smss.exe', 'csrss.exe', 'wininit.exe',
    'winlogon.exe', 'services.exe', 'lsass.exe', 'svchost.exe', 'fontdrvhost.exe','PhotosService.exe','msedgewebview2.exe',
    'spoolsv.exe','rundll32.exe','wuauclt.exe','MoUsoCoreWorker.exe' ,'MpDefenderCoreService.exe', 'MsMpEng.exe', 'SearchIndexer.exe',
    'explorer.exe','DeviceCensus.exe','MpCmdRun.exe','sppsvc.exe', 'RuntimeBroker.exe', 'SecurityHealthService.exe', 'notepad.exe',
    'Taskmgr.exe', 'dwm.exe','dllhost.exe','sihost.exe','NisSrv.exe','taskhostw.exe','FileCoAuth.exe','SearchApp.exe','ctfmon.exe','audiodg.exe','StartMenuExperienceHost.exe','smartscreen.exe','SecurityHealthSystray.exe','ApplicationFrameHost.exe','TextInputHost.exe' ,'cmd.exe', 'conhost.exe', 'makecab.exe', 'TrustedInstaller.exe',
    'TiWorker.exe', 'python.exe','py.exe', 'msedge.exe', 'SgrmBroker.exe', 'ShellExperienceHost.exe',
    'OneDrive.exe', 'MicrosoftEdgeUpdate.exe', 'backgroundTaskHost.exe', 'HxTsr.exe',
    'OneDriveStandaloneUpdater.exe', 'SearchProtocolHost.exe', 'SearchFilterHost.exe',
    'WmiPrvSE.exe','WinRAR.exe','MemCompression', 'Microsoft.SharePoint.exe', 'PhoneExperienceHost.exe'
}


critical_users = {'SYSTEM', 'LOCAL SERVICE', 'NETWORK SERVICE'}

def should_monitor_process(proc):
    """Determines if a process should be monitored (non-essential, non-system critical)."""
    try:
        if proc.username() in critical_users or proc.name() in essential_processes:
            return False
        return True
    except (psutil.AccessDenied, psutil.ZombieProcess, psutil.NoSuchProcess):
        return False

def extract_malicious_pids(filename):
    """Extracts PIDs from a file using regex."""
    pids_list = []
    with open(filename, 'r') as file:
        for line in file:
            match = re.match(r'^\s*(\d+)', line)
            if match:
                pids_list.append(int(match.group(1)))

    print(f"Extracted PIDs: {pids_list}")
    return pids_list

def kill_malicious_processes():
    """Captures a memory dump, analyzes it, and kills malicious processes."""
    dump_path = r"F:\MalwareAnalysis\MemDump\memory_dump.raw"
    capture_memory_dump(dump_path)
    analyze_memory_dump(dump_path)
    malicious_pids = extract_malicious_pids('123.txt')

    killed_processes = []
    for pid in malicious_pids:
        try:
            proc = psutil.Process(pid)
            proc_name = proc.name()
            proc.kill()
            killed_processes.append((pid, proc_name))
            print(f"Killed malicious process {proc_name} (PID: {pid})")
        except (psutil.NoSuchProcess, psutil.AccessDenied, psutil.ZombieProcess, PermissionError) as e:
            print(f"Could not terminate process {pid}: {e}")
        except Exception as e:
            print(f"An error occurred with PID {pid}: {e}")

    print("\nList of processes killed:")
    for pid, proc_name in killed_processes:
        print(f"Process: {proc_name}, PID: {pid}")

def p_kill(monitor_interval=90):
    """Background process that continuously checks for malware and handles it."""
    while True:
        try:
            kill_malicious_processes()
            time.sleep(monitor_interval)
        except Exception as e:
            print(f"Error in monitoring loop: {e}")
            time.sleep(monitor_interval)

def start_background_monitoring():
    """Starts the p_kill process in a separate thread."""
    
    monitoring_thread = threading.Thread(target=p_kill, args=(30,), daemon=True)
    monitoring_thread.start()

if __name__ == "__main__":
    is_admin() 	
    start_background_monitoring()

    try:
        while True:
            time.sleep(60)  # Main program running without blocking the monitoring thread
    except KeyboardInterrupt:
        print("Monitoring stopped.")
