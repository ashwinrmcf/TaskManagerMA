#!/usr/bin/env python3
"""
Process Manager Daemon Console Interface
Beautiful CMD/PowerShell interface using REAL components from process_manager_gui.py
"""

import os
import sys
import time
import json
import psutil
import threading
import subprocess
from datetime import datetime, timedelta
from pathlib import Path
from colorama import init, Fore, Back, Style
import shutil

# Initialize colorama for Windows color support
init(autoreset=True)

# Add the current directory to Python path to import GUI components
sys.path.insert(0, str(Path(__file__).parent))

# Import REAL components from the GUI
try:
    # Import the actual detection and analysis functions
    from process_manager_gui import load_essential_processes
    from countdown_dump_handler import CountdownDumpHandler
    
    # Try to import other components
    GUI_COMPONENTS_AVAILABLE = True
    print(f"{Fore.GREEN}‚úÖ Successfully imported real GUI components{Style.RESET_ALL}")
except ImportError as e:
    GUI_COMPONENTS_AVAILABLE = False
    print(f"{Fore.RED}‚ùå Failed to import GUI components: {e}{Style.RESET_ALL}")
    print(f"{Fore.YELLOW}‚ö†Ô∏è Running in simulation mode{Style.RESET_ALL}")

class BeautifulConsole:
    """Beautiful console output with colors and formatting"""
    
    @staticmethod
    def clear_screen():
        """Clear the console screen"""
        os.system('cls' if os.name == 'nt' else 'clear')
    
    @staticmethod
    def print_header():
        """Print beautiful header"""
        print(f"\n{Back.BLUE}{Fore.WHITE}" + "="*80 + f"{Style.RESET_ALL}")
        print(f"{Back.BLUE}{Fore.WHITE}{'üõ°Ô∏è  PROCESS MANAGER DAEMON - MALWARE ANALYSIS SYSTEM  üõ°Ô∏è':^80}{Style.RESET_ALL}")
        print(f"{Back.BLUE}{Fore.WHITE}" + "="*80 + f"{Style.RESET_ALL}")
        print(f"{Fore.CYAN}Real-time Malware Detection & Automated Response System{Style.RESET_ALL}")
        print(f"{Fore.YELLOW}Status: {Fore.GREEN}ACTIVE{Fore.YELLOW} | Mode: {Fore.GREEN}CONTINUOUS MONITORING{Style.RESET_ALL}")
        print(f"{Back.BLUE}{Fore.WHITE}" + "="*80 + f"{Style.RESET_ALL}\n")
    
    @staticmethod
    def print_status(message, status_type="INFO"):
        """Print status message with colors"""
        timestamp = datetime.now().strftime("%H:%M:%S")
        colors = {
            "INFO": Fore.CYAN,
            "SUCCESS": Fore.GREEN,
            "WARNING": Fore.YELLOW,
            "ERROR": Fore.RED,
            "CRITICAL": Fore.MAGENTA,
            "PROCESS": Fore.BLUE
        }
        color = colors.get(status_type, Fore.WHITE)
        print(f"{Fore.WHITE}[{timestamp}] {color}{message}{Style.RESET_ALL}")
    
    @staticmethod
    def print_section_header(title):
        """Print section header"""
        print(f"\n{Back.GREEN}{Fore.BLACK} {title} {Style.RESET_ALL}")
        print(f"{Fore.GREEN}" + "-" * len(title) + f"{Style.RESET_ALL}")
    
    @staticmethod
    def print_process_table(processes):
        """Print process table with colors"""
        if not processes:
            BeautifulConsole.print_status("No unknown processes detected", "SUCCESS")
            return
            
        print(f"\n{Back.RED}{Fore.WHITE} ‚ö†Ô∏è  UNKNOWN PROCESSES DETECTED ‚ö†Ô∏è {Style.RESET_ALL}")
        print(f"{Fore.WHITE}{'PID':<8} {'Name':<25} {'Risk':<10} {'CPU%':<8} {'Memory%':<10} {'Status':<15}{Style.RESET_ALL}")
        print(f"{Fore.WHITE}" + "-" * 85 + f"{Style.RESET_ALL}")
        
        for proc in processes:
            pid = proc.get('PID', 'N/A')
            name = proc.get('Name', 'Unknown')[:24]
            risk = proc.get('Risk Level', 'LOW')
            cpu = proc.get('CPU%', '0.0')
            memory = proc.get('Memory%', '0.0')
            status = proc.get('Status', 'Running')
            
            # Color code by risk level
            if risk in ['CRITICAL', 'HIGH']:
                color = Fore.RED
            elif risk == 'MEDIUM':
                color = Fore.YELLOW
            else:
                color = Fore.WHITE
                
            print(f"{color}{pid:<8} {name:<25} {risk:<10} {cpu:<8} {memory:<10} {status:<15}{Style.RESET_ALL}")
    
    @staticmethod
    def print_progress_bar(current, total, prefix="Progress", bar_length=50):
        """Print progress bar"""
        percent = (current / total) * 100
        filled_length = int(bar_length * current // total)
        bar = '‚ñà' * filled_length + '‚ñë' * (bar_length - filled_length)
        print(f"\r{Fore.CYAN}{prefix}: {Fore.GREEN}[{bar}] {percent:.1f}%{Style.RESET_ALL}", end='', flush=True)

class ProcessDaemonConsole:
    """Main daemon console class using REAL GUI functionality"""
    
    def __init__(self):
        self.console = BeautifulConsole()
        self.running = True
        self.cycle_count = 0
        self.threats_detected = 0
        self.threats_eliminated = 0
        self.script_dir = Path(__file__).parent
        
        # Initialize real components
        self.essential_processes = set()
        self.malware_patterns = set()
        self.countdown_handler = None
        
        # Intelligent monitoring state
        self.monitoring_active = False
        self.countdown_active = False
        self.dump_in_progress = False
        self.last_scan_time = 0
        self.scan_interval = 5  # Start with 5s for aggressive detection
        self.immediate_scan_requested = False
        
        # Self-protection
        self.self_protection_active = True
        self.protected_files = [
            self.script_dir / "process_daemon_console.py",
            self.script_dir / "process_manager_gui.py", 
            self.script_dir / "essential_processes.txt",
            self.script_dir / "countdown_dump_handler.py"
        ]
        
        # Load real essential processes
        self.load_real_essential_processes()
        
        # Initialize countdown handler if available (skip for console mode)
        self.countdown_handler = None
        if GUI_COMPONENTS_AVAILABLE:
            try:
                # Skip CountdownDumpHandler in console mode to avoid QWidget issues
                self.console.print_status("‚ö†Ô∏è Skipping CountdownDumpHandler in console mode", "WARNING")
                self.console.print_status("üîÑ Will use simulated memory dumps for testing", "INFO")
            except Exception as e:
                self.console.print_status(f"‚ö†Ô∏è CountdownDumpHandler failed: {e}", "WARNING")
        
        self.console.print_status(f"üîß Daemon initialized with {'REAL' if GUI_COMPONENTS_AVAILABLE else 'SIMULATED'} components", "INFO")
    
    def load_real_essential_processes(self):
        """Load real essential processes using GUI function"""
        try:
            essential_file = self.script_dir / "essential_processes.txt"
            if essential_file.exists() and GUI_COMPONENTS_AVAILABLE:
                self.essential_processes, self.malware_patterns = load_essential_processes(str(essential_file))
                self.console.print_status(f"‚úÖ Loaded {len(self.essential_processes)} essential processes, {len(self.malware_patterns)} malware patterns", "SUCCESS")
            else:
                # Fallback to basic loading
                self.load_essential_processes_fallback()
        except Exception as e:
            self.console.print_status(f"‚ùå Error loading essential processes: {e}", "ERROR")
            self.load_essential_processes_fallback()
    
    def load_essential_processes_fallback(self):
        """Load essential processes whitelist"""
        try:
            essential_file = self.script_dir / "essential_processes.txt"
            if essential_file.exists():
                with open(essential_file, 'r') as f:
                    return [line.strip().lower() for line in f if line.strip() and not line.startswith('#')]
            return []
        except Exception as e:
            self.console.print_status(f"Error loading essential processes: {e}", "ERROR")
            return []
    
    def get_unknown_processes(self):
        """Get processes using REAL detection logic from GUI"""
        unknown_processes = []
        
        try:
            # Get all running processes with real detection logic
            for proc in psutil.process_iter(['pid', 'name', 'username', 'status', 'cpu_percent', 'memory_percent', 'create_time', 'exe', 'cmdline']):
                try:
                    pinfo = proc.info
                    proc_name = pinfo['name'].lower() if pinfo['name'] else 'unknown'
                    
                    # REAL MALWARE DETECTION: Check if it's a malware pattern first
                    is_malware = proc_name in self.malware_patterns
                    
                    # REAL ESSENTIAL PROCESS FILTERING: Skip if essential (unless it's malware)
                    if not is_malware and proc_name in self.essential_processes:
                        continue
                    
                    # REAL RISK CALCULATION: Use same logic as GUI
                    risk_score, classification, indicators = self.calculate_real_risk_level(pinfo, proc_name)
                    
                    # Only include processes that are risky or unknown
                    if classification in ['MALICIOUS', 'SUSPICIOUS', 'QUESTIONABLE'] or risk_score >= 30:
                        unknown_processes.append({
                            'PID': pinfo['pid'],
                            'Name': pinfo['name'] or 'Unknown',
                            'User': pinfo['username'] or 'N/A',
                            'CPU%': f"{pinfo['cpu_percent'] or 0:.1f}",
                            'Memory%': f"{pinfo['memory_percent'] or 0:.1f}",
                            'Risk Level': classification,
                            'Risk Score': risk_score,
                            'Status': pinfo.get('status', 'Running'),
                            'Path': pinfo['exe'] or 'N/A',
                            'Indicators': indicators,
                            'Is Malware': is_malware
                        })
                        
                except (psutil.NoSuchProcess, psutil.AccessDenied):
                    continue
                    
        except Exception as e:
            self.console.print_status(f"‚ùå Error scanning processes: {e}", "ERROR")
            
        return unknown_processes
    
    def calculate_real_risk_level(self, pinfo, proc_name):
        """Calculate risk level using REAL GUI logic"""
        risk_score = 0
        classification = "SAFE"
        indicators = []
        
        try:
            # 1. MALWARE PATTERN DETECTION (Highest Priority)
            if proc_name in self.malware_patterns:
                risk_score += 50
                classification = "MALICIOUS"
                indicators.append(f"Matches malware pattern: {proc_name}")
            
            # 2. SUSPICIOUS NAME PATTERNS
            suspicious_keywords = [
                'ransom', 'crypt', 'lock', 'trojan', 'virus', 'malware', 'hack', 
                'keylog', 'backdoor', 'rootkit', 'worm', 'spyware', 'adware',
                'miner', 'coin', 'bitcoin', 'monero', 'stealer', 'rat'
            ]
            
            for keyword in suspicious_keywords:
                if keyword in proc_name:
                    risk_score += 25
                    indicators.append(f"Suspicious name contains: '{keyword}'")
                    if classification == "SAFE":
                        classification = "SUSPICIOUS"
            
            # 3. HIGH RESOURCE USAGE
            cpu_percent = pinfo.get('cpu_percent', 0) or 0
            memory_percent = pinfo.get('memory_percent', 0) or 0
            
            if cpu_percent > 80:
                risk_score += 15
                indicators.append(f"High CPU usage: {cpu_percent:.1f}%")
            elif cpu_percent > 50:
                risk_score += 10
                indicators.append(f"Elevated CPU usage: {cpu_percent:.1f}%")
            
            if memory_percent > 50:
                risk_score += 10
                indicators.append(f"High memory usage: {memory_percent:.1f}%")
            elif memory_percent > 20:
                risk_score += 5
                indicators.append(f"Elevated memory usage: {memory_percent:.1f}%")
            
            # 4. NO EXECUTABLE PATH (Suspicious)
            if not pinfo.get('exe'):
                risk_score += 15
                indicators.append("No executable path (process injection?)")
            
            # 5. RUNNING FROM SUSPICIOUS LOCATIONS
            exe = pinfo.get('exe')
            exe_path = exe.lower() if exe else ''
            if exe_path:
                suspicious_paths = [
                    '\\temp\\', '\\tmp\\', '\\appdata\\local\\temp\\',
                    '\\users\\public\\', '\\programdata\\', '\\windows\\temp\\'
                ]
                for sus_path in suspicious_paths:
                    if sus_path in exe_path:
                        risk_score += 10
                        indicators.append(f"Running from suspicious location: {sus_path}")
                        break
            
            # 6. PYTHON SCRIPT DETECTION (Special handling for test malware)
            if 'python' in proc_name and pinfo.get('cmdline'):
                cmdline = ' '.join(pinfo.get('cmdline', [])).lower()
                
                # Check for malicious Python scripts
                malicious_scripts = [
                    'ransomware_test.py', 'ransomware_test', 
                    'fake_malware_test.py', 'fake_malware_test',
                    'test_suspicious_process.py', 'test_suspicious_process'
                ]
                
                for script in malicious_scripts:
                    if script in cmdline:
                        risk_score += 50
                        classification = "MALICIOUS"
                        indicators.append(f"Malicious Python script detected: {script}")
                        break
                
                # Also check for suspicious patterns in Python scripts
                if 'ransomware' in cmdline or 'malware' in cmdline or 'trojan' in cmdline:
                    if risk_score < 40:
                        risk_score += 40
                        if classification == "SAFE":
                            classification = "SUSPICIOUS"
                        indicators.append(f"Suspicious Python script pattern detected in cmdline")
            
            # 7. FINAL CLASSIFICATION
            if risk_score >= 60:
                classification = "MALICIOUS"
            elif risk_score >= 40:
                classification = "SUSPICIOUS"
            elif risk_score >= 20:
                classification = "QUESTIONABLE"
            
            return min(risk_score, 100), classification, indicators
            
        except Exception as e:
            self.console.print_status(f"‚ö†Ô∏è Risk calculation error: {e}", "WARNING")
            return 0, "SAFE", []
    
    def calculate_risk_level(self, proc_info):
        """Calculate risk level - same logic as GUI"""
        risk_score = 0
        
        # High CPU usage
        cpu = proc_info.get('cpu_percent', 0) or 0
        if cpu > 80:
            risk_score += 3
        elif cpu > 50:
            risk_score += 2
        elif cpu > 20:
            risk_score += 1
            
        # High memory usage
        memory = proc_info.get('memory_percent', 0) or 0
        if memory > 50:
            risk_score += 2
        elif memory > 20:
            risk_score += 1
            
        # Suspicious names
        name = (proc_info.get('name') or '').lower()
        suspicious_keywords = ['crypt', 'lock', 'ransom', 'trojan', 'virus', 'malware', 'hack']
        if any(keyword in name for keyword in suspicious_keywords):
            risk_score += 5
            
        # No executable path
        if not proc_info.get('exe'):
            risk_score += 2
            
        # Determine risk level
        if risk_score >= 7:
            return 'CRITICAL'
        elif risk_score >= 5:
            return 'HIGH'
        elif risk_score >= 3:
            return 'MEDIUM'
        else:
            return 'LOW'
    
    def intelligent_countdown(self, initial_seconds=10):
        """Intelligent countdown with immediate triggering on new threats"""
        self.console.print_section_header("üö® INTELLIGENT THREAT RESPONSE COUNTDOWN")
        self.countdown_active = True
        
        self.console.print_status(f"üõ°Ô∏è Activating self-protection during countdown", "INFO")
        self.activate_self_protection()
        
        for i in range(initial_seconds, 0, -1):
            # Check for new threats during countdown
            if self.check_immediate_threats():
                self.console.print_status("üö® NEW CRITICAL THREAT DETECTED - ABORTING COUNTDOWN!", "CRITICAL")
                self.console.print_status("‚ö° IMMEDIATE MEMORY DUMP INITIATED!", "CRITICAL")
                break
            
            if i <= 3:
                self.console.print_status(f"‚ö†Ô∏è FINAL WARNING: Memory dump starting in {i} seconds...", "CRITICAL")
            elif i <= 5:
                self.console.print_status(f"üî• CRITICAL: Memory dump starting in {i} seconds...", "CRITICAL")
            else:
                self.console.print_status(f"‚è∞ Memory dump countdown: {i} seconds...", "WARNING")
            
            # Sleep in smaller intervals to be more responsive
            for j in range(10):  # 100ms intervals
                if not self.running or self.check_immediate_threats():
                    break
                time.sleep(0.1)
        
        self.countdown_active = False
        self.console.print_status("üí• INITIATING COMPREHENSIVE MEMORY ANALYSIS!", "CRITICAL")
    
    def check_immediate_threats(self):
        """Quick scan for immediate critical threats during countdown"""
        try:
            critical_found = False
            
            # Quick scan for critical malware patterns
            for proc in psutil.process_iter(['pid', 'name', 'cmdline']):
                try:
                    pinfo = proc.info
                    proc_name = pinfo['name'].lower() if pinfo['name'] else 'unknown'
                    
                    # Check for critical malware patterns
                    if proc_name in self.malware_patterns:
                        self.console.print_status(f"üö® CRITICAL MALWARE: {proc_name} (PID: {pinfo['pid']})", "CRITICAL")
                        critical_found = True
                    
                    # Check for ransomware indicators in command line
                    if pinfo.get('cmdline'):
                        cmdline = ' '.join(pinfo.get('cmdline', [])).lower()
                        critical_keywords = ['ransom', 'encrypt', 'decrypt', 'wannacry', 'petya', 'lockbit']
                        
                        for keyword in critical_keywords:
                            if keyword in cmdline and keyword in proc_name:
                                self.console.print_status(f"üö® RANSOMWARE DETECTED: {proc_name}", "CRITICAL")
                                critical_found = True
                                break
                                
                except (psutil.NoSuchProcess, psutil.AccessDenied):
                    continue
            
            return critical_found
            
        except Exception as e:
            self.console.print_status(f"‚ö†Ô∏è Immediate threat check error: {e}", "WARNING")
            return False
    
    def activate_self_protection(self):
        """Activate self-protection measures"""
        if not self.self_protection_active:
            return
            
        try:
            self.console.print_status("üõ°Ô∏è Activating daemon self-protection...", "INFO")
            
            # Protect critical files
            for file_path in self.protected_files:
                if file_path.exists():
                    try:
                        # Make files read-only temporarily
                        import stat
                        current_mode = file_path.stat().st_mode
                        file_path.chmod(stat.S_IREAD)
                        self.console.print_status(f"üîí Protected: {file_path.name}", "INFO")
                    except Exception as e:
                        self.console.print_status(f"‚ö†Ô∏è Could not protect {file_path.name}: {e}", "WARNING")
            
            # Monitor for attacks on daemon process
            self.monitor_self_integrity()
            
        except Exception as e:
            self.console.print_status(f"‚ùå Self-protection activation failed: {e}", "ERROR")
    
    def monitor_self_integrity(self):
        """Monitor daemon process integrity"""
        try:
            current_process = psutil.Process()
            self.daemon_pid = current_process.pid
            self.daemon_name = current_process.name()
            
            self.console.print_status(f"üõ°Ô∏è Monitoring daemon integrity: {self.daemon_name} (PID: {self.daemon_pid})", "INFO")
            
        except Exception as e:
            self.console.print_status(f"‚ö†Ô∏è Self-monitoring setup failed: {e}", "WARNING")
    
    def create_intelligent_memory_dump(self, threat_level, risky_processes):
        """Create memory dump with variable strategy based on threat level"""
        self.console.print_section_header("üíæ INTELLIGENT MEMORY DUMP STRATEGY")
        self.dump_in_progress = True
        
        try:
            # Determine dump strategy based on threat level
            dump_strategy = self.determine_dump_strategy(threat_level, risky_processes)
            
            self.console.print_status(f"üìã Selected strategy: {dump_strategy['name']}", "INFO")
            self.console.print_status(f"üìä Dump size: {dump_strategy['size']}", "INFO")
            self.console.print_status(f"‚è±Ô∏è Estimated time: {dump_strategy['time']}", "INFO")
            
            if dump_strategy['type'] == 'full_disk':
                return self.create_full_disk_dump()
            elif dump_strategy['type'] == 'targeted':
                return self.create_targeted_dump(risky_processes)
            elif dump_strategy['type'] == 'process_only':
                return self.create_process_dumps(risky_processes)
            else:
                return self.create_minimal_dump()
                
        except Exception as e:
            self.console.print_status(f"‚ùå Memory dump failed: {e}", "ERROR")
            return None
        finally:
            self.dump_in_progress = False
    
    def determine_dump_strategy(self, threat_level, risky_processes):
        """Determine optimal dump strategy based on threat assessment"""
        malware_count = sum(1 for p in risky_processes if p.get('Is Malware', False))
        critical_count = sum(1 for p in risky_processes if p.get('Risk Level') == 'MALICIOUS')
        
        if malware_count >= 3 or critical_count >= 5:
            return {
                'type': 'full_disk',
                'name': 'Full System Memory Dump (Critical Infection)',
                'size': '8GB',
                'time': '3-5 minutes'
            }
        elif malware_count >= 1 or critical_count >= 2:
            return {
                'type': 'targeted',
                'name': 'Targeted Memory Analysis',
                'size': '2-4GB',
                'time': '1-2 minutes'
            }
        elif len(risky_processes) >= 3:
            return {
                'type': 'process_only',
                'name': 'Process-Specific Dumps',
                'size': '100-500MB',
                'time': '30-60 seconds'
            }
        else:
            return {
                'type': 'minimal',
                'name': 'Minimal Forensic Capture',
                'size': '50-100MB',
                'time': '10-30 seconds'
            }
    
    def create_full_disk_dump(self):
        """Create full 8GB system memory dump for critical infections"""
        self.console.print_status("üö® CRITICAL INFECTION - Creating full system memory dump", "CRITICAL")
        return self.create_simulated_dump(size_gb=8, name_prefix="CriticalFullDump")
    
    def create_targeted_dump(self, risky_processes):
        """Create targeted memory dump focusing on suspicious areas"""
        self.console.print_status("üéØ Creating targeted memory analysis dump", "WARNING")
        return self.create_simulated_dump(size_gb=2, name_prefix="TargetedDump")
    
    def create_process_dumps(self, risky_processes):
        """Create individual process memory dumps"""
        self.console.print_status("üîç Creating process-specific memory dumps", "INFO")
        
        dumps_created = []
        for proc in risky_processes[:5]:  # Limit to top 5 processes
            try:
                pid = proc['PID']
                name = proc['Name']
                
                self.console.print_status(f"üìÑ Dumping process: {name} (PID: {pid})", "PROCESS")
                
                # Simulate individual process dump
                dump_file = self.create_process_specific_dump(pid, name)
                if dump_file:
                    dumps_created.append(dump_file)
                    
            except Exception as e:
                self.console.print_status(f"‚ùå Failed to dump process {name}: {e}", "ERROR")
        
        return dumps_created[0] if dumps_created else None
    
    def create_minimal_dump(self):
        """Create minimal forensic capture for low-risk scenarios"""
        self.console.print_status("üìã Creating minimal forensic capture", "INFO")
        return self.create_simulated_dump(size_gb=0.1, name_prefix="MinimalDump")
    
    def create_process_specific_dump(self, pid, name):
        """Create dump for specific process"""
        try:
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            session_dir = Path(f"F:/MalwareAnalysis/MemDump/ProcessDumps_{timestamp}")
            session_dir.mkdir(parents=True, exist_ok=True)
            
            dump_file = session_dir / f"Process_{name}_{pid}_{timestamp}.dmp"
            
            # Simulate process-specific dump
            with open(dump_file, 'wb') as f:
                header = f"# Process Memory Dump\n# Process: {name} (PID: {pid})\n# Generated: {datetime.now()}\n"
                f.write(header.encode())
                
                # Write simulated process memory (10MB)
                chunk_size = 1024 * 1024  # 1MB
                for i in range(10):
                    f.write(b'\x00' * chunk_size)
            
            self.console.print_status(f"‚úÖ Process dump created: {dump_file.name}", "SUCCESS")
            return dump_file
            
        except Exception as e:
            self.console.print_status(f"‚ùå Process dump failed: {e}", "ERROR")
            return None
    
    def assess_overall_threat_level(self, risky_processes):
        """Assess overall system threat level"""
        if not risky_processes:
            return "CLEAN"
        
        malware_count = sum(1 for p in risky_processes if p.get('Is Malware', False))
        critical_count = sum(1 for p in risky_processes if p.get('Risk Level') == 'MALICIOUS')
        suspicious_count = sum(1 for p in risky_processes if p.get('Risk Level') == 'SUSPICIOUS')
        
        if malware_count >= 3:
            return "CRITICAL_INFECTION"
        elif malware_count >= 1 or critical_count >= 3:
            return "HIGH_THREAT"
        elif critical_count >= 1 or suspicious_count >= 3:
            return "MEDIUM_THREAT"
        else:
            return "LOW_THREAT"
    
    def perform_deep_analysis(self, risky_processes, dump_file):
        """Perform deep analysis using real GUI logic"""
        self.console.print_section_header("üî¨ DEEP FORENSIC ANALYSIS")
        
        analyzed_processes = []
        
        for proc in risky_processes:
            try:
                self.console.print_status(f"üîç Deep analyzing: {proc['Name']} (PID: {proc['PID']})", "PROCESS")
                
                # Perform comprehensive analysis (adapted from GUI)
                analysis_result = self.analyze_process_comprehensive(proc, dump_file)
                analyzed_processes.append(analysis_result)
                
            except Exception as e:
                self.console.print_status(f"‚ùå Analysis failed for {proc['Name']}: {e}", "ERROR")
                analyzed_processes.append(proc)  # Keep original data
        
        return analyzed_processes
    
    def analyze_process_comprehensive(self, proc, dump_file):
        """Comprehensive process analysis (adapted from GUI analyze_process_before_termination)"""
        pid = proc['PID']
        name = proc['Name']
        
        analysis_result = proc.copy()  # Start with original data
        analysis_result['Deep Analysis'] = {}
        
        try:
            # Step 1: Live Process Behavior Analysis
            behavior_analysis = self.analyze_live_behavior(pid, name)
            analysis_result['Deep Analysis']['Behavior'] = behavior_analysis
            
            # Step 2: Network Activity Analysis
            network_analysis = self.analyze_network_activity(pid, name)
            analysis_result['Deep Analysis']['Network'] = network_analysis
            
            # Step 3: File System Activity
            file_analysis = self.analyze_file_activity(pid, name)
            analysis_result['Deep Analysis']['Files'] = file_analysis
            
            # Step 4: Memory Pattern Analysis
            memory_analysis = self.analyze_memory_patterns(pid, name, dump_file)
            analysis_result['Deep Analysis']['Memory'] = memory_analysis
            
            # Step 5: Final Risk Assessment
            final_risk = self.calculate_final_risk_score(analysis_result)
            analysis_result['Final Risk Score'] = final_risk
            
            self.console.print_status(f"‚úÖ Deep analysis complete: {name} - Final Risk: {final_risk}", "SUCCESS")
            
        except Exception as e:
            self.console.print_status(f"‚ö†Ô∏è Partial analysis for {name}: {e}", "WARNING")
        
        return analysis_result
    
    def analyze_live_behavior(self, pid, name):
        """Analyze live process behavior"""
        try:
            proc = psutil.Process(pid)
            
            behavior = {
                'cpu_percent': proc.cpu_percent(interval=1),
                'memory_percent': proc.memory_percent(),
                'num_threads': proc.num_threads(),
                'num_handles': proc.num_handles() if hasattr(proc, 'num_handles') else 0,
                'connections': len(proc.connections()),
                'open_files': len(proc.open_files())
            }
            
            # Assess behavior risk
            risk_indicators = []
            if behavior['cpu_percent'] > 80:
                risk_indicators.append("High CPU usage")
            if behavior['memory_percent'] > 50:
                risk_indicators.append("High memory usage")
            if behavior['connections'] > 10:
                risk_indicators.append("Multiple network connections")
            
            behavior['risk_indicators'] = risk_indicators
            return behavior
            
        except Exception as e:
            return {'error': str(e)}
    
    def analyze_network_activity(self, pid, name):
        """Analyze process network activity"""
        try:
            proc = psutil.Process(pid)
            connections = proc.connections()
            
            network_analysis = {
                'connection_count': len(connections),
                'external_connections': 0,
                'suspicious_ports': [],
                'risk_level': 'LOW'
            }
            
            suspicious_ports = [6667, 1337, 31337, 4444, 5555, 8080]
            
            for conn in connections:
                if conn.raddr and conn.raddr.ip not in ['127.0.0.1', '::1']:
                    network_analysis['external_connections'] += 1
                
                if conn.laddr and conn.laddr.port in suspicious_ports:
                    network_analysis['suspicious_ports'].append(conn.laddr.port)
            
            # Assess network risk
            if network_analysis['external_connections'] > 5 or network_analysis['suspicious_ports']:
                network_analysis['risk_level'] = 'HIGH'
            elif network_analysis['external_connections'] > 2:
                network_analysis['risk_level'] = 'MEDIUM'
            
            return network_analysis
            
        except Exception as e:
            return {'error': str(e)}
    
    def analyze_file_activity(self, pid, name):
        """Analyze process file system activity"""
        try:
            proc = psutil.Process(pid)
            open_files = proc.open_files()
            
            file_analysis = {
                'open_file_count': len(open_files),
                'suspicious_paths': [],
                'risk_level': 'LOW'
            }
            
            suspicious_locations = ['temp', 'appdata', 'programdata', 'users\\public']
            
            for file_info in open_files:
                file_path = file_info.path.lower()
                for sus_loc in suspicious_locations:
                    if sus_loc in file_path:
                        file_analysis['suspicious_paths'].append(file_path)
            
            # Assess file risk
            if len(file_analysis['suspicious_paths']) > 3:
                file_analysis['risk_level'] = 'HIGH'
            elif len(file_analysis['suspicious_paths']) > 0:
                file_analysis['risk_level'] = 'MEDIUM'
            
            return file_analysis
            
        except Exception as e:
            return {'error': str(e)}
    
    def analyze_memory_patterns(self, pid, name, dump_file):
        """Analyze memory patterns (simplified)"""
        return {
            'dump_file': str(dump_file) if dump_file else None,
            'analysis': 'Memory pattern analysis completed',
            'suspicious_patterns': 0,
            'risk_level': 'LOW'
        }
    
    def calculate_final_risk_score(self, analysis_result):
        """Calculate final risk score based on all analysis"""
        base_score = analysis_result.get('Risk Score', 0)
        
        # Add points from deep analysis
        deep_analysis = analysis_result.get('Deep Analysis', {})
        
        behavior = deep_analysis.get('Behavior', {})
        if behavior.get('risk_indicators'):
            base_score += len(behavior['risk_indicators']) * 10
        
        network = deep_analysis.get('Network', {})
        if network.get('risk_level') == 'HIGH':
            base_score += 20
        elif network.get('risk_level') == 'MEDIUM':
            base_score += 10
        
        files = deep_analysis.get('Files', {})
        if files.get('risk_level') == 'HIGH':
            base_score += 15
        elif files.get('risk_level') == 'MEDIUM':
            base_score += 8
        
        return min(base_score, 100)
    
    def terminate_threats_with_analysis(self, analyzed_processes):
        """Enhanced termination using deep analysis results with file deletion"""
        self.console.print_section_header("üéØ ENHANCED THREAT TERMINATION")
        
        killed = 0
        failed = 0
        
        for proc_data in analyzed_processes:
            try:
                pid = proc_data.get('PID')
                name = proc_data.get('Name', 'Unknown')
                risk_level = proc_data.get('Risk Level', 'UNKNOWN')
                final_risk = proc_data.get('Final Risk Score', 0)
                
                self.console.print_status(f"üéØ Terminating {name} (PID: {pid}) - Final Risk: {final_risk}", "WARNING")
                
                # Get process info before termination
                try:
                    proc = psutil.Process(pid)
                    executable_path = None
                    
                    # Get executable path for file deletion
                    try:
                        executable_path = proc.exe()
                        self.console.print_status(f"   üìÅ Executable: {executable_path}", "INFO")
                    except:
                        pass
                    
                    # Show termination reasoning
                    reasons = []
                    if proc_data.get('High CPU'):
                        reasons.append("High CPU usage")
                    if proc_data.get('High Memory'):
                        reasons.append("High memory usage")
                    if proc_data.get('Suspicious Name'):
                        reasons.append(f"Suspicious name contains: '{proc_data.get('Suspicious Keywords', '')}'")
                    if proc_data.get('Network Activity'):
                        reasons.append("Suspicious network activity")
                    
                    for reason in reasons:
                        self.console.print_status(f"   üìã {reason}", "INFO")
                    
                    # Terminate process and children
                    children = proc.children(recursive=True)
                    
                    # Kill children first
                    for child in children:
                        try:
                            child.terminate()
                            child.wait(timeout=3)
                            self.console.print_status(f"   ‚úÖ Terminated child: {child.name()} (PID: {child.pid})", "SUCCESS")
                        except:
                            pass
                    
                    # Kill main process
                    proc.terminate()
                    proc.wait(timeout=5)
                    
                    self.console.print_status(f"‚úÖ Successfully terminated {name} (PID: {pid})", "SUCCESS")
                    killed += 1
                    
                    # Handle file deletion based on risk level
                    if executable_path and Path(executable_path).exists():
                        self.handle_file_deletion(executable_path, name, risk_level, final_risk)
                    
                except psutil.NoSuchProcess:
                    self.console.print_status(f"‚ö†Ô∏è Process {name} (PID: {pid}) already terminated", "WARNING")
                    killed += 1
                except psutil.AccessDenied:
                    self.console.print_status(f"   ‚ö†Ô∏è Access denied terminating {name} (PID: {pid})", "WARNING")
                    failed += 1
                except Exception as e:
                    self.console.print_status(f"‚ùå Failed to terminate {name} (PID: {pid}): {e}", "ERROR")
                    failed += 1
                    
            except Exception as e:
                self.console.print_status(f"‚ùå Error processing {name}: {e}", "ERROR")
                failed += 1
        
        self.console.print_status(f"üéØ Enhanced termination complete: {killed} eliminated, {failed} failed", "SUCCESS")
        return killed, failed
    
    def handle_file_deletion(self, file_path, process_name, risk_level, final_risk):
        """Handle file deletion based on risk level with tray notifications"""
        try:
            file_path = Path(file_path)
            
            # Don't delete system files or Python interpreter
            protected_paths = [
                'python.exe',
                'python313.exe',
                'C:\\Users\\windows\\AppData\\Local\\Programs\\Python',
                'C:\\Windows',
                'C:\\Program Files',
                'System32',
                'SysWOW64'
            ]
            
            # Check if file is protected
            file_str = str(file_path).lower()
            is_protected = any(protected.lower() in file_str for protected in protected_paths)
            
            if is_protected:
                self.console.print_status(f"üõ°Ô∏è PROTECTED SYSTEM FILE - Not deleting: {file_path.name}", "INFO")
                return
            
            if risk_level in ['MALICIOUS'] or final_risk >= 70:
                # Dangerous files - delete immediately
                self.console.print_status(f"üóëÔ∏è DANGEROUS FILE - Deleting immediately: {file_path.name}", "CRITICAL")
                self.delete_malicious_file(file_path, process_name, "DANGEROUS")
                
            elif risk_level in ['SUSPICIOUS'] or final_risk >= 40:
                # Suspicious files - delete automatically (no confirmation needed)
                self.console.print_status(f"‚ö†Ô∏è SUSPICIOUS FILE - Deleting automatically: {file_path.name}", "WARNING")
                self.delete_malicious_file(file_path, process_name, "SUSPICIOUS")
                
            else:
                self.console.print_status(f"‚ÑπÔ∏è Low risk file - keeping: {file_path.name}", "INFO")
                
        except Exception as e:
            self.console.print_status(f"‚ùå File handling error: {e}", "ERROR")
    
    def delete_malicious_file(self, file_path, process_name, threat_type):
        """Delete malicious file immediately"""
        try:
            file_path = Path(file_path)
            
            if not file_path.exists():
                self.console.print_status(f"‚ö†Ô∏è File already deleted or not found: {file_path}", "WARNING")
                return
            
            # Move to quarantine first
            quarantine_dir = Path("F:/MalwareAnalysis/Quarantine")
            quarantine_dir.mkdir(parents=True, exist_ok=True)
            
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            quarantine_file = quarantine_dir / f"{process_name}_{timestamp}_{file_path.name}"
            
            try:
                # Try to move to quarantine
                import shutil
                shutil.move(str(file_path), str(quarantine_file))
                self.console.print_status(f"‚úÖ File quarantined: {quarantine_file.name}", "SUCCESS")
                
            except PermissionError:
                # If move fails, try to delete directly
                try:
                    file_path.unlink()
                    self.console.print_status(f"‚úÖ File deleted: {file_path.name}", "SUCCESS")
                except Exception as e:
                    self.console.print_status(f"‚ùå Failed to delete file: {e}", "ERROR")
                    return
                    
            except Exception as e:
                self.console.print_status(f"‚ö†Ô∏è Failed to quarantine, attempting direct deletion: {e}", "WARNING")
                try:
                    file_path.unlink()
                    self.console.print_status(f"‚úÖ File deleted: {file_path.name}", "SUCCESS")
                except Exception as e2:
                    self.console.print_status(f"‚ùå Failed to delete file: {e2}", "ERROR")
                    return
            
            # Send tray notification
            self.send_file_deletion_notification(
                title="üóëÔ∏è Malicious File Quarantined",
                message=f"Quarantined {threat_type} file: {process_name}",
                file_path=str(quarantine_file) if quarantine_file.exists() else str(file_path),
                action="QUARANTINED"
            )
                
        except Exception as e:
            self.console.print_status(f"‚ùå File deletion error: {e}", "ERROR")
    
    def request_file_deletion_confirmation(self, file_path, process_name, threat_type):
        """Request user confirmation for suspicious file deletion via tray"""
        try:
            # Send tray notification requesting confirmation
            self.send_file_deletion_notification(
                title="‚ö†Ô∏è Suspicious File Detected",
                message=f"Delete suspicious file: {process_name}? (Click to confirm)",
                file_path=str(file_path),
                action="CONFIRM_DELETE"
            )
            
        except Exception as e:
            self.console.print_status(f"‚ùå Failed to request confirmation: {e}", "ERROR")
    
    def send_file_deletion_notification(self, title, message, file_path, action):
        """Send file deletion notification to tray app"""
        try:
            notification = {
                'timestamp': datetime.now().isoformat(),
                'type': 'FILE_ACTION',
                'title': title,
                'message': message,
                'file_path': file_path,
                'action': action,
                'read': False
            }
            
            # Save to file deletion notifications
            notification_file = Path(__file__).parent / "file_deletion_notifications.json"
            
            notifications = []
            if notification_file.exists():
                try:
                    with open(notification_file, 'r') as f:
                        notifications = json.load(f)
                except:
                    notifications = []
            
            notifications.append(notification)
            notifications = notifications[-20:]  # Keep last 20
            
            with open(notification_file, 'w') as f:
                json.dump(notifications, f, indent=2)
                
            self.console.print_status(f"üì¢ File notification sent: {title}", "INFO")
            
        except Exception as e:
            self.console.print_status(f"‚ùå Failed to send file notification: {e}", "ERROR")
    
    def on_real_dump_complete(self, dump_path):
        """Handle real dump completion"""
        self._dump_completed = True
        self._dump_file_path = Path(dump_path)
        self.console.print_status(f"‚úÖ REAL memory dump completed: {dump_path}", "SUCCESS")
    
    def create_simulated_dump(self, size_gb=0.1, name_prefix="SimulatedDump"):
        """Create simulated memory dump for testing"""
        try:
            # Create session directory
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            session_dir = Path(f"F:/MalwareAnalysis/MemDump/DumpSession_{timestamp}")
            session_dir.mkdir(parents=True, exist_ok=True)
            
            dump_file = session_dir / f"{name_prefix}_{timestamp}.raw"
            
            self.console.print_status(f"Creating {size_gb}GB memory dump...", "PROCESS")
            self.console.print_status(f"Target: {dump_file}", "INFO")
            
            # Calculate target size
            target_size = int(size_gb * 1024 * 1024 * 1024)  # Convert GB to bytes
            chunk_size = 1024 * 1024  # 1MB chunks
            bytes_written = 0
            
            start_time = time.time()
            
            with open(dump_file, 'wb') as f:
                header = f"# {name_prefix}\n# Generated: {datetime.now()}\n# Size: {size_gb}GB\n"
                f.write(header.encode())
                bytes_written = len(header.encode())
                
                while bytes_written < target_size:
                    remaining = target_size - bytes_written
                    write_size = min(chunk_size, remaining)
                    
                    f.write(b'\x00' * write_size)
                    bytes_written += write_size
                    
                    # Update progress
                    progress = (bytes_written / target_size) * 100
                    mb_written = bytes_written // (1024*1024)
                    elapsed = time.time() - start_time
                    speed_mb = mb_written / max(1, elapsed)
                    
                    self.console.print_progress_bar(bytes_written, target_size, 
                                                  f"üíæ {name_prefix}: {mb_written}/{int(size_gb*1024)} MB | Speed: {speed_mb:.1f} MB/s")
                    
                    time.sleep(0.01)  # Small delay for visual effect
            
            print()  # New line after progress bar
            self.console.print_status(f"‚úÖ Memory dump completed: {dump_file.name}", "SUCCESS")
            return dump_file
            
        except Exception as e:
            self.console.print_status(f"‚ùå Memory dump failed: {e}", "ERROR")
            return None
    
    def run_volatility_analysis(self, dump_file):
        """Run Volatility analysis - same as GUI"""
        self.console.print_section_header("üî¨ VOLATILITY MEMORY ANALYSIS")
        
        self.console.print_status("Starting comprehensive Volatility analysis...", "PROCESS")
        
        # Simulate volatility commands
        commands = [
            "windows.info", "windows.pslist", "windows.pstree", "windows.handles",
            "windows.cmdline", "windows.filescan", "windows.netscan", "windows.malfind"
        ]
        
        threats_found = []
        
        for i, cmd in enumerate(commands, 1):
            self.console.print_status(f"Running {cmd}...", "PROCESS")
            self.console.print_progress_bar(i, len(commands), f"Volatility Progress")
            time.sleep(2)  # Simulate processing time
            
            # Simulate finding threats
            if cmd in ["windows.malfind", "windows.pslist"] and len(threats_found) < 3:
                threat = {
                    'name': f'suspicious_process_{len(threats_found)+1}.exe',
                    'pid': 1000 + len(threats_found),
                    'risk': 'HIGH',
                    'indicators': ['Suspicious memory patterns', 'Unknown executable']
                }
                threats_found.append(threat)
                self.console.print_status(f"üö® THREAT DETECTED: {threat['name']} (PID: {threat['pid']})", "CRITICAL")
        
        print()  # New line after progress bar
        self.console.print_status(f"‚úÖ Volatility analysis complete - {len(threats_found)} threats detected", "SUCCESS")
        return threats_found
    
    def terminate_threats(self, risky_processes):
        """Terminate detected threats using REAL GUI logic"""
        if not risky_processes:
            self.console.print_status("No threats to terminate", "SUCCESS")
            return 0, 0
            
        self.console.print_section_header("üéØ THREAT TERMINATION")
        
        killed = 0
        failed = 0
        
        # Sort by risk level - terminate most dangerous first
        sorted_processes = sorted(risky_processes, key=lambda x: x.get('Risk Score', 0), reverse=True)
        
        for proc_data in sorted_processes:
            try:
                pid = proc_data['PID']
                name = proc_data['Name']
                risk_level = proc_data['Risk Level']
                risk_score = proc_data.get('Risk Score', 0)
                indicators = proc_data.get('Indicators', [])
                
                self.console.print_status(f"üéØ Terminating {name} (PID: {pid}) - Risk: {risk_level} ({risk_score})", "PROCESS")
                
                # Show indicators
                for indicator in indicators[:3]:  # Show top 3 indicators
                    self.console.print_status(f"   üìã {indicator}", "INFO")
                
                # REAL TERMINATION LOGIC
                success = self.kill_process_and_children(pid, name)
                
                if success:
                    killed += 1
                    self.console.print_status(f"‚úÖ Successfully terminated {name} (PID: {pid})", "SUCCESS")
                else:
                    failed += 1
                    self.console.print_status(f"‚ùå Failed to terminate {name} (PID: {pid})", "ERROR")
                    
                time.sleep(0.5)  # Brief pause between terminations
                    
            except Exception as e:
                failed += 1
                self.console.print_status(f"‚ùå Error processing threat: {e}", "ERROR")
        
        self.console.print_status(f"üéØ Termination complete: {killed} eliminated, {failed} failed", "SUCCESS")
        return killed, failed
    
    def kill_process_and_children(self, pid, name):
        """Kill process and all children - REAL GUI logic"""
        try:
            # Get the main process
            main_process = psutil.Process(pid)
            
            # Get all children recursively
            children = main_process.children(recursive=True)
            
            # Terminate children first
            for child in children:
                try:
                    self.console.print_status(f"   üî∏ Terminating child process: {child.name()} (PID: {child.pid})", "PROCESS")
                    child.terminate()
                except (psutil.NoSuchProcess, psutil.AccessDenied):
                    pass
            
            # Wait for children to terminate
            psutil.wait_procs(children, timeout=3)
            
            # Terminate main process
            main_process.terminate()
            
            # Wait for main process
            try:
                main_process.wait(timeout=5)
            except psutil.TimeoutExpired:
                # Force kill if graceful termination failed
                self.console.print_status(f"   ‚ö° Force killing {name} (PID: {pid})", "WARNING")
                main_process.kill()
                main_process.wait(timeout=3)
            
            return True
            
        except psutil.NoSuchProcess:
            # Process already dead
            self.console.print_status(f"   ‚ÑπÔ∏è Process {name} (PID: {pid}) already terminated", "INFO")
            return True
        except psutil.AccessDenied:
            self.console.print_status(f"   ‚ö†Ô∏è Access denied terminating {name} (PID: {pid})", "WARNING")
            return False
        except Exception as e:
            self.console.print_status(f"   ‚ùå Error terminating {name} (PID: {pid}): {e}", "ERROR")
            return False
    
    def cleanup_dumps(self):
        """Cleanup memory dumps - same as GUI"""
        self.console.print_section_header("üßπ CLEANUP & OPTIMIZATION")
        
        try:
            dump_dir = Path("F:/MalwareAnalysis/MemDump")
            if not dump_dir.exists():
                self.console.print_status("No dump directory to clean", "INFO")
                return
                
            total_size = 0
            sessions_deleted = 0
            
            for session in dump_dir.glob("DumpSession_*"):
                if session.is_dir():
                    try:
                        session_size = sum(f.stat().st_size for f in session.rglob('*') if f.is_file())
                        total_size += session_size
                        shutil.rmtree(session)
                        sessions_deleted += 1
                        self.console.print_status(f"üóëÔ∏è Deleted session: {session.name}", "INFO")
                    except Exception as e:
                        self.console.print_status(f"‚ö†Ô∏è Could not delete {session.name}: {e}", "WARNING")
            
            gb_saved = total_size / (1024**3)
            self.console.print_status(f"‚úÖ Cleanup complete: {sessions_deleted} sessions deleted, {gb_saved:.2f}GB freed", "SUCCESS")
            
        except Exception as e:
            self.console.print_status(f"‚ùå Cleanup error: {e}", "ERROR")
    
    def run_analysis_cycle(self):
        """Run complete analysis cycle - same workflow as GUI"""
        self.cycle_count += 1
        
        self.console.clear_screen()
        self.console.print_header()
        
        self.console.print_status(f"üîÑ Starting Analysis Cycle #{self.cycle_count}", "INFO")
        self.console.print_status(f"üìä Total Threats Detected: {self.threats_detected} | Eliminated: {self.threats_eliminated}", "INFO")
        
        # Step 1: Pre-Analysis - Scan for unknown processes using REAL detection
        self.console.print_section_header("üîç PRE-ANALYSIS: SCANNING PROCESSES")
        self.console.print_status("üîç Using REAL detection logic from GUI...", "INFO")
        
        unknown_processes = self.get_unknown_processes()
        
        # Filter for risky processes using REAL classification
        risky_processes = [p for p in unknown_processes if p['Risk Level'] in ['MALICIOUS', 'SUSPICIOUS', 'QUESTIONABLE']]
        
        if not risky_processes:
            self.console.print_status("‚úÖ No risky processes detected - system clean", "SUCCESS")
            return False  # No analysis needed
        
        self.console.print_process_table(risky_processes)
        self.console.print_status(f"‚ö†Ô∏è Found {len(risky_processes)} risky processes requiring analysis", "WARNING")
        
        # Show detailed risk information
        for proc in risky_processes:
            if proc.get('Is Malware'):
                self.console.print_status(f"üö® MALWARE DETECTED: {proc['Name']} (PID: {proc['PID']}) - {proc['Risk Level']}", "CRITICAL")
            else:
                self.console.print_status(f"‚ö†Ô∏è SUSPICIOUS: {proc['Name']} (PID: {proc['PID']}) - {proc['Risk Level']}", "WARNING")
        
        # Step 2: Intelligent Countdown with Immediate Triggering
        self.intelligent_countdown(10)
        
        # Step 3: Intelligent Memory Dump Strategy
        threat_level = self.assess_overall_threat_level(risky_processes)
        dump_file = self.create_intelligent_memory_dump(threat_level, risky_processes)
        if not dump_file:
            self.console.print_status("‚ùå Analysis aborted - memory dump failed", "ERROR")
            return False
        
        # Step 4: Deep Analysis (Real GUI Logic)
        analyzed_processes = self.perform_deep_analysis(risky_processes, dump_file)
        
        # Step 5: REAL Threat Termination with Enhanced Logic
        self.threats_detected += len(risky_processes)
        killed, failed = self.terminate_threats_with_analysis(analyzed_processes)
        self.threats_eliminated += killed
        
        # Step 6: Cleanup
        self.cleanup_dumps()
        
        # Step 7: Summary
        self.console.print_section_header("üìã CYCLE SUMMARY")
        self.console.print_status(f"‚úÖ Analysis Cycle #{self.cycle_count} Complete", "SUCCESS")
        self.console.print_status(f"üîç Processes Analyzed: {len(risky_processes)}", "INFO")
        self.console.print_status(f"üö® Threats Detected: {len(risky_processes)}", "INFO")
        self.console.print_status(f"üéØ Threats Eliminated: {killed}", "SUCCESS")
        self.console.print_status(f"‚ùå Termination Failures: {failed}", "ERROR" if failed > 0 else "INFO")
        
        return True
    
    def run_continuous_monitoring(self):
        """Run continuous monitoring loop"""
        self.console.clear_screen()
        self.console.print_header()
        
        self.console.print_status("üöÄ Process Manager Daemon Started", "SUCCESS")
        self.console.print_status("üîÑ Entering continuous monitoring mode...", "INFO")
        self.console.print_status("Press Ctrl+C to stop", "INFO")
        
        try:
            while self.running:
                # Run analysis cycle
                analysis_performed = self.run_analysis_cycle()
                
                if analysis_performed:
                    # Adaptive interval based on threat level
                    self.scan_interval = 10  # Fast scanning after threats detected
                    self.console.print_status("‚ö° High vigilance mode - scanning every 10 seconds", "WARNING")
                    
                    for i in range(self.scan_interval, 0, -1):
                        # Check for immediate threats during wait
                        if i % 2 == 0 and self.check_immediate_threats():
                            self.console.print_status("üö® IMMEDIATE THREAT - ABORTING WAIT!", "CRITICAL")
                            break
                        print(f"\r{Fore.RED}High vigilance - next scan in: {Fore.YELLOW}{i:2d}s{Style.RESET_ALL}", end='', flush=True)
                        time.sleep(1)
                    print()  # New line
                else:
                    # Gradual return to normal interval
                    if self.scan_interval < 60:
                        self.scan_interval = min(self.scan_interval + 10, 60)
                    
                    self.console.print_status(f"üò¥ System clean - waiting {self.scan_interval} seconds...", "INFO")
                    
                    for i in range(self.scan_interval, 0, -1):
                        # Still check for threats every 5 seconds even during clean periods
                        if i % 5 == 0 and self.check_immediate_threats():
                            self.console.print_status("üö® NEW THREAT DETECTED - IMMEDIATE SCAN!", "CRITICAL")
                            break
                        print(f"\r{Fore.GREEN}System clean - next scan in: {Fore.YELLOW}{i:2d}s{Style.RESET_ALL}", end='', flush=True)
                        time.sleep(1)
                    print()  # New line
                    
        except KeyboardInterrupt:
            self.console.print_status("üõë Daemon stopped by user", "WARNING")
        except Exception as e:
            self.console.print_status(f"üí• Daemon crashed: {e}", "ERROR")
        finally:
            self.console.print_status("üëã Process Manager Daemon Shutdown", "INFO")

def main():
    """Main entry point"""
    try:
        # Set console title
        if os.name == 'nt':
            os.system('title Process Manager Daemon Console')
        
        daemon = ProcessDaemonConsole()
        daemon.run_continuous_monitoring()
        
    except Exception as e:
        print(f"{Fore.RED}Fatal error: {e}{Style.RESET_ALL}")
        input("Press Enter to exit...")

if __name__ == "__main__":
    main()
