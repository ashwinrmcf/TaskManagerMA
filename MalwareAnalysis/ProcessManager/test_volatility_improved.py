#!/usr/bin/env python3
"""
Improved Volatility Test Script with Better Error Handling and Fallback
This script focuses on running specific Volatility commands that are more likely to succeed.
"""

import os
import sys
import json
import time
import subprocess
import threading
from pathlib import Path
from datetime import datetime

class ImprovedVolatilityTester:
    """Improved Volatility tester with better error handling and reliable commands."""
    
    def __init__(self, dump_file):
        self.dump_file = Path(dump_file)
        self.results = {
            'timestamp': datetime.now().isoformat(),
            'dump_file': str(self.dump_file),
            'file_size_gb': self.dump_file.stat().st_size / (1024**3) if self.dump_file.exists() else 0,
            'vol3_results': {},
            'vol2_results': {},
            'successful_commands': [],
            'failed_commands': [],
            'errors': []
        }
        
        # Configure paths
        self.vol3_path = Path("F:/MalwareAnalysis/Tools/volatility3/vol.py")
        self.vol2_path = Path("F:/MalwareAnalysis/Tools/volatility2/volatility-master/vol.py")
        self.python2_path = Path("C:/Python27/python.exe")
        self.cache_path = Path("F:/MalwareAnalysis/vol_cache")
        self.cache_path.mkdir(exist_ok=True)
        
        # Define reliable commands that are most likely to succeed
        self.vol3_reliable_commands = [
            'windows.info',      # Basic system info - usually works
            'windows.pslist',    # Process list - fundamental command
            'windows.pstree'     # Process tree - lightweight
        ]
        
        self.vol3_secondary_commands = [
            'windows.handles',   # Process handles
            'windows.dlllist',   # DLL information
            'windows.netscan'    # Network connections
        ]
        
        self.vol2_commands = [
            'imageinfo',  # Profile detection
            'pslist',     # Process list
            'pstree'      # Process tree
        ]
        
        # Timeout settings
        self.short_timeout = 120  # 2 minutes for quick commands
        self.long_timeout = 300   # 5 minutes for complex commands
    
    def log(self, message, level="INFO"):
        """Log a message with timestamp."""
        timestamp = datetime.now().strftime("%H:%M:%S")
        prefix = {
            "INFO": "ℹ️",
            "SUCCESS": "✅", 
            "WARNING": "⚠️",
            "ERROR": "❌"
        }.get(level, "ℹ️")
        
        print(f"[{timestamp}] {prefix} {message}")
        
        if level == "ERROR":
            self.results['errors'].append({
                'timestamp': timestamp,
                'message': message
            })
    
    def run_command_safely(self, cmd, timeout=None, description=""):
        """Run a command with proper timeout and error handling."""
        if timeout is None:
            timeout = self.short_timeout
            
        self.log(f"Running {description}: {' '.join(cmd[:3])}... (timeout: {timeout}s)")
        
        try:
            result = subprocess.run(
                cmd,
                capture_output=True,
                text=True,
                encoding='utf-8',
                errors='replace',
                timeout=timeout
            )
            
            success = result.returncode == 0
            
            if success:
                self.log(f"{description} completed successfully", "SUCCESS")
            else:
                self.log(f"{description} failed with return code {result.returncode}", "WARNING")
                if result.stderr:
                    self.log(f"Error output: {result.stderr.strip()}", "WARNING")
            
            return {
                'success': success,
                'returncode': result.returncode,
                'stdout': result.stdout,
                'stderr': result.stderr,
                'timeout': False
            }
            
        except subprocess.TimeoutExpired:
            self.log(f"{description} timed out after {timeout} seconds", "WARNING")
            return {
                'success': False,
                'returncode': -1,
                'stdout': '',
                'stderr': f'Command timed out after {timeout} seconds',
                'timeout': True
            }
        except Exception as e:
            self.log(f"Error running {description}: {str(e)}", "ERROR")
            return {
                'success': False,
                'returncode': -1,
                'stdout': '',
                'stderr': str(e),
                'timeout': False
            }
    
    def check_vol3_available(self):
        """Check if Volatility 3 is available."""
        self.log("Checking Volatility 3 availability...")
        
        if not self.vol3_path.exists():
            self.log(f"Volatility 3 not found at {self.vol3_path}", "WARNING")
            return False
        
        # Try to get help
        cmd = [sys.executable, str(self.vol3_path), "-h"]
        result = self.run_command_safely(cmd, timeout=30, description="Vol3 availability check")
        
        return result['success']
    
    def test_vol3_commands(self):
        """Test Volatility 3 commands in order of reliability."""
        self.log("Testing Volatility 3 commands...")
        
        if not self.check_vol3_available():
            self.log("Volatility 3 not available, skipping tests", "WARNING")
            return False
        
        success_count = 0
        
        # Test reliable commands first
        self.log("Testing reliable Volatility 3 commands...")
        for command in self.vol3_reliable_commands:
            cmd = [
                sys.executable, str(self.vol3_path),
                "--cache-path", str(self.cache_path),
                "-f", str(self.dump_file),
                command
            ]
            
            result = self.run_command_safely(
                cmd, 
                timeout=self.long_timeout,
                description=f"Vol3 {command}"
            )
            
            self.results['vol3_results'][command] = {
                'success': result['success'],
                'returncode': result['returncode'],
                'timeout': result['timeout'],
                'output_length': len(result['stdout']) if result['success'] else 0
            }
            
            if result['success']:
                success_count += 1
                self.results['successful_commands'].append(f"vol3_{command}")
                
                # Save sample output for successful commands
                if len(result['stdout']) > 100:
                    self.results['vol3_results'][command]['sample_output'] = result['stdout'][:500]
            else:
                self.results['failed_commands'].append(f"vol3_{command}")
                self.results['vol3_results'][command]['error'] = result['stderr']
        
        # If basic commands work, try secondary ones
        if success_count > 0:
            self.log("Basic commands succeeded, trying secondary commands...")
            for command in self.vol3_secondary_commands:
                cmd = [
                    sys.executable, str(self.vol3_path),
                    "--cache-path", str(self.cache_path),
                    "-f", str(self.dump_file),
                    command
                ]
                
                result = self.run_command_safely(
                    cmd,
                    timeout=self.long_timeout,
                    description=f"Vol3 {command}"
                )
                
                self.results['vol3_results'][command] = {
                    'success': result['success'],
                    'returncode': result['returncode'],
                    'timeout': result['timeout'],
                    'output_length': len(result['stdout']) if result['success'] else 0
                }
                
                if result['success']:
                    success_count += 1
                    self.results['successful_commands'].append(f"vol3_{command}")
                    
                    if len(result['stdout']) > 100:
                        self.results['vol3_results'][command]['sample_output'] = result['stdout'][:500]
                else:
                    self.results['failed_commands'].append(f"vol3_{command}")
                    self.results['vol3_results'][command]['error'] = result['stderr']
        
        return success_count > 0
    
    def check_vol2_available(self):
        """Check if Volatility 2 is available."""
        self.log("Checking Volatility 2 availability...")
        
        if not self.python2_path.exists():
            self.log(f"Python 2.7 not found at {self.python2_path}", "WARNING")
            return False
            
        if not self.vol2_path.exists():
            self.log(f"Volatility 2 not found at {self.vol2_path}", "WARNING")
            return False
        
        # Try to get help
        cmd = [str(self.python2_path), str(self.vol2_path), "--help"]
        result = self.run_command_safely(cmd, timeout=30, description="Vol2 availability check")
        
        return result['success']
    
    def test_vol2_commands(self):
        """Test Volatility 2 commands as fallback."""
        self.log("Testing Volatility 2 commands as fallback...")
        
        if not self.check_vol2_available():
            self.log("Volatility 2 not available, skipping fallback tests", "WARNING")
            return False
        
        success_count = 0
        profile = None
        
        # First, try to detect profile with imageinfo
        self.log("Attempting profile detection with imageinfo...")
        cmd = [str(self.python2_path), str(self.vol2_path), "-f", str(self.dump_file), "imageinfo"]
        result = self.run_command_safely(cmd, timeout=self.long_timeout, description="Vol2 imageinfo")
        
        self.results['vol2_results']['imageinfo'] = {
            'success': result['success'],
            'returncode': result['returncode'],
            'timeout': result['timeout']
        }
        
        if result['success']:
            success_count += 1
            self.results['successful_commands'].append("vol2_imageinfo")
            
            # Try to extract profile
            import re
            match = re.search(r'Suggested Profile\(s\) : (.*?)(?:\r?\n|$)', result['stdout'])
            if match:
                profiles = [p.strip() for p in match.group(1).split(',')]
                profile = profiles[0] if profiles else None
                self.log(f"Detected profile: {profile}", "SUCCESS")
                self.results['vol2_results']['profile'] = profile
            else:
                self.log("Could not extract profile from imageinfo output", "WARNING")
        else:
            self.results['failed_commands'].append("vol2_imageinfo")
            self.results['vol2_results']['imageinfo']['error'] = result['stderr']
        
        # If we have a profile, try other commands
        if profile:
            for command in self.vol2_commands[1:]:  # Skip imageinfo since we already ran it
                cmd = [
                    str(self.python2_path), str(self.vol2_path),
                    "-f", str(self.dump_file),
                    f"--profile={profile}",
                    command
                ]
                
                result = self.run_command_safely(
                    cmd,
                    timeout=self.long_timeout,
                    description=f"Vol2 {command}"
                )
                
                self.results['vol2_results'][command] = {
                    'success': result['success'],
                    'returncode': result['returncode'],
                    'timeout': result['timeout'],
                    'output_length': len(result['stdout']) if result['success'] else 0
                }
                
                if result['success']:
                    success_count += 1
                    self.results['successful_commands'].append(f"vol2_{command}")
                    
                    if len(result['stdout']) > 100:
                        self.results['vol2_results'][command]['sample_output'] = result['stdout'][:500]
                else:
                    self.results['failed_commands'].append(f"vol2_{command}")
                    self.results['vol2_results'][command]['error'] = result['stderr']
        
        return success_count > 0
    
    def generate_summary(self):
        """Generate and display test summary."""
        self.log("=" * 60)
        self.log("VOLATILITY TEST SUMMARY")
        self.log("=" * 60)
        
        total_commands = len(self.results['successful_commands']) + len(self.results['failed_commands'])
        success_count = len(self.results['successful_commands'])
        
        self.log(f"File: {self.dump_file.name}")
        self.log(f"Size: {self.results['file_size_gb']:.2f} GB")
        self.log(f"Total commands tested: {total_commands}")
        self.log(f"Successful: {success_count}")
        self.log(f"Failed: {len(self.results['failed_commands'])}")
        
        if total_commands > 0:
            success_rate = (success_count / total_commands) * 100
            self.log(f"Success rate: {success_rate:.1f}%")
        
        if self.results['successful_commands']:
            self.log(f"✅ Successful: {', '.join(self.results['successful_commands'])}", "SUCCESS")
        
        if self.results['failed_commands']:
            self.log(f"❌ Failed: {', '.join(self.results['failed_commands'])}", "WARNING")
        
        if self.results['errors']:
            self.log(f"⚠️ Errors encountered: {len(self.results['errors'])}", "WARNING")
        
        self.log("=" * 60)
    
    def save_results(self):
        """Save detailed results to JSON file."""
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        output_file = f"volatility_test_results_{timestamp}.json"
        
        with open(output_file, 'w') as f:
            json.dump(self.results, f, indent=2)
        
        self.log(f"Detailed results saved to: {output_file}", "SUCCESS")
        return output_file
    
    def run_comprehensive_test(self):
        """Run comprehensive Volatility test with fallback."""
        self.log(f"Starting comprehensive Volatility test on {self.dump_file}")
        self.log(f"File size: {self.results['file_size_gb']:.2f} GB")
        
        # Test Volatility 3 first
        vol3_success = self.test_vol3_commands()
        
        # Fall back to Volatility 2 if Vol3 failed completely
        vol2_success = False
        if not vol3_success:
            self.log("Volatility 3 tests failed, trying Volatility 2 fallback...")
            vol2_success = self.test_vol2_commands()
        
        # Generate summary
        self.generate_summary()
        
        # Save results
        output_file = self.save_results()
        
        # Final status
        if vol3_success or vol2_success:
            self.log("Test completed successfully!", "SUCCESS")
            return True
        else:
            self.log("All tests failed - check configuration and dump file", "ERROR")
            return False

if __name__ == "__main__":
    if len(sys.argv) < 2:
        print("Usage: python test_volatility_improved.py <path_to_memory_dump>")
        sys.exit(1)
    
    dump_file = sys.argv[1]
    if not os.path.exists(dump_file):
        print(f"Error: File not found: {dump_file}")
        sys.exit(1)
    
    tester = ImprovedVolatilityTester(dump_file)
    success = tester.run_comprehensive_test()
    
    sys.exit(0 if success else 1)
