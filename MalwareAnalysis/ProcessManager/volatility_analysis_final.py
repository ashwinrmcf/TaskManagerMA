#!/usr/bin/env python3
"""
Enhanced Volatility Analysis Script with Robust Error Handling
Handles both Volatility 3 and Volatility 2 with comprehensive fallback mechanisms.
"""

import os
import sys
import json
import time
import signal
import subprocess
import threading
from pathlib import Path
from datetime import datetime
from typing import Dict, List, Optional, Tuple, Union

class VolatilityAnalyzer:
    """Comprehensive Volatility analysis with robust error handling and fallback."""
    
    def __init__(self, dump_file: str, timeout: int = 600):
        """Initialize the analyzer with paths and configurations."""
        self.dump_file = Path(dump_file).resolve()
        self.timeout = timeout  # 10 minutes default
        self.results = {
            'timestamp': datetime.now().isoformat(),
            'dump_file': str(self.dump_file),
            'file_size_gb': self.dump_file.stat().st_size / (1024**3) if self.dump_file.exists() else 0,
            'analysis_results': {},
            'errors': [],
            'warnings': [],
            'successful_commands': [],
            'failed_commands': []
        }
        
        # Configure paths
        self.vol3_path = Path("F:/MalwareAnalysis/Tools/volatility3/vol.py")
        self.vol2_path = Path("F:/MalwareAnalysis/Tools/volatility2/volatility-master/vol.py")
        self.python2_path = Path("C:/Python27/python.exe")
        self.cache_path = Path("F:/MalwareAnalysis/vol_cache")
        
        # Ensure cache directory exists
        self.cache_path.mkdir(exist_ok=True)
        
        # Define lightweight commands that are more likely to succeed
        self.vol3_quick_commands = [
            'windows.info',
            'windows.pslist',
            'windows.pstree',
            'windows.handles'
        ]
        
        self.vol3_advanced_commands = [
            'windows.dlllist',
            'windows.netscan',
            'windows.malfind',
            'windows.filescan'
        ]
        
        self.vol2_commands = [
            'imageinfo',
            'pslist',
            'pstree',
            'handles'
        ]
    
    def log_message(self, level: str, message: str, exc_info=None):
        """Log a message with timestamp and level."""
        timestamp = datetime.now().isoformat()
        log_entry = {'level': level, 'message': message, 'time': timestamp}
        
        if exc_info:
            log_entry['exception'] = str(exc_info)
        
        if level == 'ERROR':
            self.results['errors'].append(log_entry)
            print(f"❌ {message}")
        elif level == 'WARNING':
            self.results['warnings'].append(log_entry)
            print(f"⚠️ {message}")
        else:
            print(f"ℹ️ {message}")
    
    def run_command_with_timeout(self, cmd: List[str], timeout: int = None) -> Dict:
        """Run a command with timeout and capture output."""
        if timeout is None:
            timeout = self.timeout
            
        try:
            self.log_message('INFO', f"Running: {' '.join(cmd[:3])}... (timeout: {timeout}s)")
            
            # Use a thread to run the command with timeout
            result = {'success': False, 'stdout': '', 'stderr': '', 'returncode': -1}
            
            def run_process():
                try:
                    process = subprocess.run(
                        cmd,
                        capture_output=True,
                        text=True,
                        encoding='utf-8',
                        errors='replace',
                        timeout=timeout
                    )
                    result.update({
                        'success': process.returncode == 0,
                        'returncode': process.returncode,
                        'stdout': process.stdout,
                        'stderr': process.stderr
                    })
                except subprocess.TimeoutExpired:
                    result['error'] = f'Command timed out after {timeout} seconds'
                except Exception as e:
                    result['error'] = str(e)
            
            thread = threading.Thread(target=run_process)
            thread.daemon = True
            thread.start()
            thread.join(timeout + 10)  # Give extra time for cleanup
            
            if thread.is_alive():
                self.log_message('WARNING', f"Command still running after timeout")
                result['error'] = 'Thread timeout'
            
            return result
            
        except Exception as e:
            error_msg = f"Error executing command: {str(e)}"
            self.log_message('ERROR', error_msg, e)
            return {
                'success': False,
                'error': error_msg,
                'returncode': -1,
                'stdout': '',
                'stderr': str(e)
            }
    
    def check_vol3_available(self) -> bool:
        """Check if Volatility 3 is available and working."""
        self.log_message('INFO', "Checking Volatility 3 availability...")
        
        if not self.vol3_path.exists():
            self.log_message('WARNING', f"Volatility 3 not found at {self.vol3_path}")
            return False
        
        # Try to get help (faster than version check)
        cmd = [sys.executable, str(self.vol3_path), "-h"]
        result = self.run_command_with_timeout(cmd, timeout=30)
        
        if result['success']:
            self.log_message('INFO', "Volatility 3 is available")
            return True
        else:
            self.log_message('WARNING', "Volatility 3 check failed")
            return False
    
    def run_vol3_command(self, command: str, use_cache: bool = True) -> Dict:
        """Run a single Volatility 3 command."""
        cmd = [sys.executable, str(self.vol3_path)]
        
        if use_cache:
            cmd.extend(["--cache-path", str(self.cache_path)])
        
        cmd.extend(["-f", str(self.dump_file), command])
        
        return self.run_command_with_timeout(cmd)
    
    def analyze_with_vol3(self) -> bool:
        """Run analysis using Volatility 3."""
        self.log_message('INFO', "Starting Volatility 3 analysis...")
        
        if not self.check_vol3_available():
            return False
        
        success_count = 0
        
        # Try quick commands first
        self.log_message('INFO', "Running quick Volatility 3 commands...")
        for command in self.vol3_quick_commands:
            self.log_message('INFO', f"Executing: {command}")
            result = self.run_vol3_command(command)
            
            command_result = {
                'command': command,
                'success': result['success'],
                'timestamp': datetime.now().isoformat()
            }
            
            if result['success']:
                success_count += 1
                self.results['successful_commands'].append(command)
                command_result['output_length'] = len(result['stdout'])
                command_result['sample_output'] = result['stdout'][:500]  # First 500 chars
                self.log_message('INFO', f"✅ {command} completed successfully")
            else:
                self.results['failed_commands'].append(command)
                command_result['error'] = result.get('error', result.get('stderr', 'Unknown error'))
                self.log_message('WARNING', f"❌ {command} failed: {command_result['error']}")
            
            self.results['analysis_results'][command] = command_result
        
        # If quick commands work, try advanced ones
        if success_count > 0:
            self.log_message('INFO', "Quick commands succeeded, trying advanced commands...")
            for command in self.vol3_advanced_commands:
                self.log_message('INFO', f"Executing: {command}")
                result = self.run_vol3_command(command)
                
                command_result = {
                    'command': command,
                    'success': result['success'],
                    'timestamp': datetime.now().isoformat()
                }
                
                if result['success']:
                    success_count += 1
                    self.results['successful_commands'].append(command)
                    command_result['output_length'] = len(result['stdout'])
                    command_result['sample_output'] = result['stdout'][:500]
                    self.log_message('INFO', f"✅ {command} completed successfully")
                else:
                    self.results['failed_commands'].append(command)
                    command_result['error'] = result.get('error', result.get('stderr', 'Unknown error'))
                    self.log_message('WARNING', f"❌ {command} failed: {command_result['error']}")
                
                self.results['analysis_results'][command] = command_result
        
        return success_count > 0
    
    def check_vol2_available(self) -> bool:
        """Check if Volatility 2 is available and working."""
        self.log_message('INFO', "Checking Volatility 2 availability...")
        
        if not self.python2_path.exists():
            self.log_message('WARNING', f"Python 2.7 not found at {self.python2_path}")
            return False
            
        if not self.vol2_path.exists():
            self.log_message('WARNING', f"Volatility 2 not found at {self.vol2_path}")
            return False
        
        # Try to get help
        cmd = [str(self.python2_path), str(self.vol2_path), "--help"]
        result = self.run_command_with_timeout(cmd, timeout=30)
        
        if result['success']:
            self.log_message('INFO', "Volatility 2 is available")
            return True
        else:
            self.log_message('WARNING', f"Volatility 2 check failed: {result.get('error', 'Unknown error')}")
            return False
    
    def analyze_with_vol2(self) -> bool:
        """Run analysis using Volatility 2 as fallback."""
        self.log_message('INFO', "Starting Volatility 2 fallback analysis...")
        
        if not self.check_vol2_available():
            return False
        
        # Try imageinfo first to detect profile
        self.log_message('INFO', "Detecting profile with imageinfo...")
        cmd = [str(self.python2_path), str(self.vol2_path), "-f", str(self.dump_file), "imageinfo"]
        result = self.run_command_with_timeout(cmd, timeout=300)  # 5 minutes for imageinfo
        
        if not result['success']:
            self.log_message('ERROR', f"Profile detection failed: {result.get('error', 'Unknown error')}")
            return False
        
        # Extract profile from output
        profile = self.extract_vol2_profile(result['stdout'])
        if not profile:
            self.log_message('ERROR', "Could not extract profile from imageinfo output")
            return False
        
        self.log_message('INFO', f"Detected profile: {profile}")
        self.results['vol2_profile'] = profile
        
        # Run other commands with the detected profile
        success_count = 0
        for command in self.vol2_commands[1:]:  # Skip imageinfo since we already ran it
            self.log_message('INFO', f"Executing Vol2: {command}")
            cmd = [str(self.python2_path), str(self.vol2_path), "-f", str(self.dump_file), f"--profile={profile}", command]
            result = self.run_command_with_timeout(cmd)
            
            command_result = {
                'command': f"vol2_{command}",
                'success': result['success'],
                'timestamp': datetime.now().isoformat()
            }
            
            if result['success']:
                success_count += 1
                self.results['successful_commands'].append(f"vol2_{command}")
                command_result['output_length'] = len(result['stdout'])
                command_result['sample_output'] = result['stdout'][:500]
                self.log_message('INFO', f"✅ Vol2 {command} completed successfully")
            else:
                self.results['failed_commands'].append(f"vol2_{command}")
                command_result['error'] = result.get('error', result.get('stderr', 'Unknown error'))
                self.log_message('WARNING', f"❌ Vol2 {command} failed: {command_result['error']}")
            
            self.results['analysis_results'][f"vol2_{command}"] = command_result
        
        return success_count > 0
    
    def extract_vol2_profile(self, output: str) -> Optional[str]:
        """Extract profile from Volatility 2 imageinfo output."""
        import re
        match = re.search(r'Suggested Profile\(s\) : (.*?)(?:\r?\n|$)', output)
        if match:
            profiles = [p.strip() for p in match.group(1).split(',')]
            return profiles[0] if profiles else None
        return None
    
    def save_results(self, output_file: str = None) -> str:
        """Save analysis results to a JSON file."""
        if output_file is None:
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            output_file = f"volatility_final_analysis_{timestamp}.json"
        
        # Add summary statistics
        self.results['summary'] = {
            'total_commands': len(self.results['successful_commands']) + len(self.results['failed_commands']),
            'successful_commands': len(self.results['successful_commands']),
            'failed_commands': len(self.results['failed_commands']),
            'success_rate': len(self.results['successful_commands']) / max(1, len(self.results['successful_commands']) + len(self.results['failed_commands'])) * 100,
            'total_errors': len(self.results['errors']),
            'total_warnings': len(self.results['warnings'])
        }
        
        with open(output_file, 'w') as f:
            json.dump(self.results, f, indent=2)
        
        self.log_message('INFO', f"Analysis results saved to {output_file}")
        return output_file
    
    def run_complete_analysis(self) -> bool:
        """Run the complete analysis with fallback."""
        self.log_message('INFO', f"Starting comprehensive analysis of {self.dump_file}")
        self.log_message('INFO', f"File size: {self.results['file_size_gb']:.2f} GB")
        self.log_message('INFO', f"Timeout per command: {self.timeout} seconds")
        
        # Try Volatility 3 first
        vol3_success = self.analyze_with_vol3()
        
        # Fall back to Volatility 2 if Vol3 failed completely
        vol2_success = False
        if not vol3_success:
            self.log_message('INFO', "Volatility 3 failed, falling back to Volatility 2...")
            vol2_success = self.analyze_with_vol2()
        
        # Save results
        output_file = self.save_results()
        
        # Print summary
        self.log_message('INFO', "\n=== ANALYSIS SUMMARY ===")
        self.log_message('INFO', f"Volatility 3: {'SUCCESS' if vol3_success else 'FAILED'}")
        if not vol3_success:
            self.log_message('INFO', f"Volatility 2: {'SUCCESS' if vol2_success else 'FAILED'}")
        
        summary = self.results['summary']
        self.log_message('INFO', f"Commands executed: {summary['total_commands']}")
        self.log_message('INFO', f"Successful: {summary['successful_commands']}")
        self.log_message('INFO', f"Failed: {summary['failed_commands']}")
        self.log_message('INFO', f"Success rate: {summary['success_rate']:.1f}%")
        
        if not (vol3_success or vol2_success):
            self.log_message('ERROR', "Analysis failed with all available tools")
            return False
        
        self.log_message('INFO', f"\nAnalysis complete. Results saved to: {output_file}")
        return True

if __name__ == "__main__":
    if len(sys.argv) < 2:
        print("Usage: python volatility_analysis_final.py <path_to_memory_dump> [timeout_seconds]")
        sys.exit(1)
    
    dump_file = sys.argv[1]
    timeout = int(sys.argv[2]) if len(sys.argv) > 2 else 600  # 10 minutes default
    
    if not os.path.exists(dump_file):
        print(f"Error: File not found: {dump_file}")
        sys.exit(1)
    
    analyzer = VolatilityAnalyzer(dump_file, timeout)
    success = analyzer.run_complete_analysis()
    
    if not success:
        print("\n❌ Analysis completed with errors. Check the output for details.")
        sys.exit(1)
    else:
        print("\n✅ Analysis completed successfully!")
