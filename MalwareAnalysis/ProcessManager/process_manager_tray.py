#!/usr/bin/env python3
"""
Process Manager System Tray Application
Provides system tray control for the Process Manager Windows Service
"""

import sys
import os
import time
import threading
import subprocess
import json
from pathlib import Path
from datetime import datetime, timedelta
import win32serviceutil
import win32service
import win32gui
import win32con
from PyQt5.QtWidgets import (
    QApplication, QSystemTrayIcon, QMenu, QAction, QMessageBox, 
    QDialog, QVBoxLayout, QHBoxLayout, QLabel, QPushButton, QTextEdit,
    QProgressBar, QGroupBox, QGridLayout
)
from PyQt5.QtCore import QTimer, pyqtSignal, QThread, Qt
from PyQt5.QtGui import QIcon, QPixmap, QPainter, QColor, QFont

# Get the skull icon path
def get_skull_icon_path():
    """Get the path to skull.ico, trying multiple locations"""
    # Try relative to this file
    icon_path = Path(__file__).parent / "Icons" / "skull.ico"
    if icon_path.exists():
        return str(icon_path)
    
    # Try absolute path
    icon_path = Path("F:/MalwareAnalysis/ProcessManager/Icons/skull.ico")
    if icon_path.exists():
        return str(icon_path)
    
    # Try with backslashes
    icon_path = Path("F:\\MalwareAnalysis\\ProcessManager\\Icons\\skull.ico")
    if icon_path.exists():
        return str(icon_path)
    
    return None

class ServiceStatusWorker(QThread):
    """Worker thread to monitor service status"""
    status_updated = pyqtSignal(dict)
    
    def __init__(self):
        super().__init__()
        self.running = True
        self.service_dir = Path(__file__).parent
        
    def run(self):
        while self.running:
            try:
                status = self.get_service_status()
                self.status_updated.emit(status)
                time.sleep(2)  # Update every 2 seconds
            except Exception as e:
                print(f"Error monitoring service status: {e}")
                time.sleep(5)
    
    def stop(self):
        self.running = False
        
    def get_service_status(self):
        """Get comprehensive service status"""
        status = {
            'service_running': False,
            'service_state': 'Unknown',
            'processes_monitored': 0,
            'threats_detected': 0,
            'last_analysis': None,
            'uptime': None,
            'cpu_usage': 0,
            'memory_usage': 0
        }
        
        try:
            # Check Windows service status
            service_status = win32serviceutil.QueryServiceStatus('ProcessManagerService')
            if service_status[1] == win32service.SERVICE_RUNNING:
                status['service_running'] = True
                status['service_state'] = 'Running'
            elif service_status[1] == win32service.SERVICE_STOPPED:
                status['service_state'] = 'Stopped'
            elif service_status[1] == win32service.SERVICE_START_PENDING:
                status['service_state'] = 'Starting'
            elif service_status[1] == win32service.SERVICE_STOP_PENDING:
                status['service_state'] = 'Stopping'
            else:
                status['service_state'] = 'Unknown'
                
        except Exception as e:
            status['service_state'] = f'Error: {str(e)}'
        
        # Read service status file if available
        try:
            status_file = self.service_dir / 'service_status.json'
            if status_file.exists():
                with open(status_file, 'r') as f:
                    file_status = json.load(f)
                    status.update(file_status)
                    
                    # Calculate uptime
                    if file_status.get('uptime_start'):
                        uptime_start = datetime.fromisoformat(file_status['uptime_start'])
                        uptime = datetime.now() - uptime_start
                        status['uptime'] = str(uptime).split('.')[0]  # Remove microseconds
                    
                    # Add automated cycling status
                    status['automated_cycling'] = True
                    status['cycle_interval'] = '5 minutes'
                        
        except Exception as e:
            print(f"Error reading status file: {e}")
        
        return status

class ServiceStatusDialog(QDialog):
    """Dialog showing detailed service status"""
    
    def __init__(self, parent=None):
        super().__init__(parent)
        self.setWindowTitle("Process Manager Service Status")
        self.setFixedSize(500, 400)
        self.setup_ui()
        
    def setup_ui(self):
        layout = QVBoxLayout()
        
        # Service Status Group
        service_group = QGroupBox("Service Status")
        service_layout = QGridLayout()
        
        self.status_label = QLabel("Unknown")
        self.uptime_label = QLabel("N/A")
        self.processes_label = QLabel("0")
        self.threats_label = QLabel("0")
        self.cycling_label = QLabel("Enabled")
        
        service_layout.addWidget(QLabel("Status:"), 0, 0)
        service_layout.addWidget(self.status_label, 0, 1)
        service_layout.addWidget(QLabel("Uptime:"), 1, 0)
        service_layout.addWidget(self.uptime_label, 1, 1)
        service_layout.addWidget(QLabel("Automated Cycling:"), 2, 0)
        service_layout.addWidget(self.cycling_label, 2, 1)
        service_layout.addWidget(QLabel("Processes Monitored:"), 3, 0)
        service_layout.addWidget(self.processes_label, 3, 1)
        service_layout.addWidget(QLabel("Threats Detected:"), 4, 0)
        service_layout.addWidget(self.threats_label, 4, 1)
        
        service_group.setLayout(service_layout)
        layout.addWidget(service_group)
        
        # System Performance Group
        perf_group = QGroupBox("System Performance")
        perf_layout = QVBoxLayout()
        
        self.cpu_progress = QProgressBar()
        self.cpu_progress.setRange(0, 100)
        self.memory_progress = QProgressBar()
        self.memory_progress.setRange(0, 100)
        
        perf_layout.addWidget(QLabel("CPU Usage:"))
        perf_layout.addWidget(self.cpu_progress)
        perf_layout.addWidget(QLabel("Memory Usage:"))
        perf_layout.addWidget(self.memory_progress)
        
        perf_group.setLayout(perf_layout)
        layout.addWidget(perf_group)
        
        # Log Display
        log_group = QGroupBox("Recent Activity")
        log_layout = QVBoxLayout()
        
        self.log_display = QTextEdit()
        self.log_display.setReadOnly(True)
        self.log_display.setMaximumHeight(150)
        
        log_layout.addWidget(self.log_display)
        log_group.setLayout(log_layout)
        layout.addWidget(log_group)
        
        # Control Buttons
        button_layout = QHBoxLayout()
        
        self.refresh_btn = QPushButton("Refresh")
        self.refresh_btn.clicked.connect(self.refresh_status)
        
        self.close_btn = QPushButton("Close")
        self.close_btn.clicked.connect(self.close)
        
        button_layout.addWidget(self.refresh_btn)
        button_layout.addStretch()
        button_layout.addWidget(self.close_btn)
        
        layout.addLayout(button_layout)
        self.setLayout(layout)
    
    def update_status(self, status):
        """Update the dialog with new status information"""
        # Service status
        state = status.get('service_state', 'Unknown')
        if status.get('service_running'):
            self.status_label.setText(f"ðŸŸ¢ {state}")
            self.status_label.setStyleSheet("color: green; font-weight: bold;")
        else:
            self.status_label.setText(f"ðŸ”´ {state}")
            self.status_label.setStyleSheet("color: red; font-weight: bold;")
        
        # Other status info
        self.uptime_label.setText(status.get('uptime', 'N/A'))
        self.processes_label.setText(str(status.get('processes_monitored', 0)))
        self.threats_label.setText(str(status.get('threats_detected', 0)))
        
        # Automated cycling status
        if status.get('automated_cycling'):
            cycle_interval = status.get('cycle_interval', '5 minutes')
            self.cycling_label.setText(f"âœ… Active ({cycle_interval})")
            self.cycling_label.setStyleSheet("color: green; font-weight: bold;")
        else:
            self.cycling_label.setText("âŒ Disabled")
            self.cycling_label.setStyleSheet("color: red; font-weight: bold;")
        
        # Performance
        cpu_usage = status.get('cpu_usage', 0)
        memory_usage = status.get('memory_usage', 0)
        
        self.cpu_progress.setValue(int(cpu_usage))
        self.cpu_progress.setFormat(f"{cpu_usage:.1f}%")
        
        self.memory_progress.setValue(int(memory_usage))
        self.memory_progress.setFormat(f"{memory_usage:.1f}%")
        
        # Add log entry
        timestamp = datetime.now().strftime("%H:%M:%S")
        log_entry = f"[{timestamp}] Status: {state}, Processes: {status.get('processes_monitored', 0)}, Threats: {status.get('threats_detected', 0)}"
        self.log_display.append(log_entry)
        
        # Keep only last 20 lines
        lines = self.log_display.toPlainText().split('\n')
        if len(lines) > 20:
            self.log_display.setPlainText('\n'.join(lines[-20:]))
    
    def refresh_status(self):
        """Manually refresh status"""
        if hasattr(self.parent(), 'status_worker'):
            status = self.parent().status_worker.get_service_status()
            self.update_status(status)

class ProcessManagerTray(QSystemTrayIcon):
    """System tray application for Process Manager service"""
    
    def __init__(self, app):
        super().__init__()
        self.app = app
        self.status_dialog = None
        self.status_worker = None
        
        # Create tray icon
        self.create_icon()
        self.setIcon(self.icon)
        
        # Create context menu
        self.create_menu()
        
        # Set up status monitoring
        self.setup_status_monitoring()
        
        # Show tray icon
        self.show()
        
        # Set tooltip
        self.setToolTip("Process Manager Service")
        
        # Connect signals
        self.activated.connect(self.on_tray_activated)
        
    def create_icon(self):
        """Create system tray icon from skull.ico file"""
        icon_path = get_skull_icon_path()
        if icon_path:
            self.icon = QIcon(icon_path)
            print(f"[TRAY] Loaded skull icon from: {icon_path}")
        else:
            # Fallback to programmatic icon if file not found
            print("[TRAY] Skull icon not found, using fallback shield icon")
            pixmap = QPixmap(16, 16)
            pixmap.fill(QColor(0, 0, 0, 0))  # Transparent background
            
            painter = QPainter(pixmap)
            painter.setRenderHint(QPainter.Antialiasing)
            
            # Draw a shield-like icon
            painter.setBrush(QColor(0, 120, 215))  # Blue color
            painter.setPen(QColor(0, 0, 0))
            
            # Draw shield shape
            points = [
                (8, 2), (12, 4), (12, 10), (8, 14), (4, 10), (4, 4)
            ]
            from PyQt5.QtGui import QPolygon
            from PyQt5.QtCore import QPoint
            polygon = QPolygon([QPoint(x, y) for x, y in points])
            painter.drawPolygon(polygon)
            
            painter.end()
            self.icon = QIcon(pixmap)
    
    def create_menu(self):
        """Create context menu for tray icon"""
        self.menu = QMenu()
        
        # Service control actions
        self.start_action = QAction("Start Service", self)
        self.start_action.triggered.connect(self.start_service)
        
        self.stop_action = QAction("Stop Service", self)
        self.stop_action.triggered.connect(self.stop_service)
        
        self.restart_action = QAction("Restart Service", self)
        self.restart_action.triggered.connect(self.restart_service)
        
        self.menu.addAction(self.start_action)
        self.menu.addAction(self.stop_action)
        self.menu.addAction(self.restart_action)
        self.menu.addSeparator()
        
        # Status and info actions
        self.status_action = QAction("Show Status", self)
        self.status_action.triggered.connect(self.show_status)
        
        daemon_menu = self.menu.addMenu("Process Daemon")
        
        view_daemon_action = QAction("View Daemon Console", self)
        view_daemon_action.triggered.connect(self.open_process_daemon)
        daemon_menu.addAction(view_daemon_action)
        
        daemon_status_action = QAction("Daemon Status", self)
        daemon_status_action.triggered.connect(self.show_daemon_status)
        daemon_menu.addAction(daemon_status_action)
        
        daemon_menu.addSeparator()
        
        start_daemon_service_action = QAction("Start Daemon Service", self)
        start_daemon_service_action.triggered.connect(self.start_daemon_service)
        daemon_menu.addAction(start_daemon_service_action)
        
        stop_daemon_service_action = QAction("Stop Daemon Service", self)
        stop_daemon_service_action.triggered.connect(self.stop_daemon_service)
        daemon_menu.addAction(stop_daemon_service_action)
        
        self.logs_action = QAction("View Logs", self)
        self.logs_action.triggered.connect(self.view_logs)
        
        self.menu.addAction(self.status_action)
        self.menu.addAction(self.logs_action)
        self.menu.addSeparator()
        
        # Settings and exit
        self.settings_action = QAction("Settings", self)
        self.settings_action.triggered.connect(self.show_settings)
        
        self.exit_action = QAction("Exit", self)
        self.exit_action.triggered.connect(self.exit_application)
        
        self.menu.addAction(self.settings_action)
        self.menu.addSeparator()
        self.menu.addAction(self.exit_action)
        
        self.setContextMenu(self.menu)
    
    def setup_status_monitoring(self):
        """Set up background status monitoring"""
        self.status_worker = ServiceStatusWorker()
        self.status_worker.status_updated.connect(self.update_tray_status)
        self.status_worker.start()
        
        # Timer for periodic updates
        self.update_timer = QTimer()
        self.update_timer.timeout.connect(self.update_menu_states)
        self.update_timer.start(5000)  # Update every 5 seconds
        
        # Timer for checking daemon notifications
        self.notification_timer = QTimer()
        self.notification_timer.timeout.connect(self.check_daemon_notifications)
        self.notification_timer.start(2000)  # Check every 2 seconds
    
    def update_tray_status(self, status):
        """Update tray icon based on service status"""
        if status.get('service_running'):
            tooltip = f"Process Manager Service - Running\n"
            tooltip += f"Automated Cycling: {'Active' if status.get('automated_cycling') else 'Disabled'}\n"
            tooltip += f"Processes: {status.get('processes_monitored', 0)}\n"
            tooltip += f"Threats: {status.get('threats_detected', 0)}\n"
            tooltip += f"Uptime: {status.get('uptime', 'N/A')}"
            
            # Change icon color to green when running
            self.create_running_icon()
        else:
            tooltip = f"Process Manager Service - {status.get('service_state', 'Stopped')}"
            # Change icon color to red when stopped
            self.create_stopped_icon()
        
        self.setToolTip(tooltip)
        
        # Update status dialog if open
        if self.status_dialog and self.status_dialog.isVisible():
            self.status_dialog.update_status(status)
    
    def create_running_icon(self):
        """Create green icon for running state (skull with green overlay)"""
        icon_path = get_skull_icon_path()
        if icon_path:
            # Load skull icon and add green tint
            pixmap = QPixmap(icon_path)
            # Create a green overlay using painter
            painter = QPainter(pixmap)
            painter.setCompositionMode(QPainter.CompositionMode_Multiply)
            painter.fillRect(pixmap.rect(), QColor(0, 180, 0))
            painter.end()
            self.setIcon(QIcon(pixmap))
        else:
            # Fallback to green shield
            pixmap = QPixmap(16, 16)
            pixmap.fill(QColor(0, 0, 0, 0))
            painter = QPainter(pixmap)
            painter.setRenderHint(QPainter.Antialiasing)
            painter.setBrush(QColor(0, 180, 0))  # Green
            painter.setPen(QColor(0, 0, 0))
            points = [(8, 2), (12, 4), (12, 10), (8, 14), (4, 10), (4, 4)]
            from PyQt5.QtGui import QPolygon
            from PyQt5.QtCore import QPoint
            polygon = QPolygon([QPoint(x, y) for x, y in points])
            painter.drawPolygon(polygon)
            painter.end()
            self.setIcon(QIcon(pixmap))
    
    def create_stopped_icon(self):
        """Create red icon for stopped state (skull with red overlay)"""
        icon_path = get_skull_icon_path()
        if icon_path:
            # Load skull icon and add red tint
            pixmap = QPixmap(icon_path)
            # Create a red overlay using painter
            painter = QPainter(pixmap)
            painter.setCompositionMode(QPainter.CompositionMode_Multiply)
            painter.fillRect(pixmap.rect(), QColor(180, 0, 0))
            painter.end()
            self.setIcon(QIcon(pixmap))
        else:
            # Fallback to red shield
            pixmap = QPixmap(16, 16)
            pixmap.fill(QColor(0, 0, 0, 0))
            painter = QPainter(pixmap)
            painter.setRenderHint(QPainter.Antialiasing)
            painter.setBrush(QColor(180, 0, 0))  # Red
            painter.setPen(QColor(0, 0, 0))
            points = [(8, 2), (12, 4), (12, 10), (8, 14), (4, 10), (4, 4)]
            from PyQt5.QtGui import QPolygon
            from PyQt5.QtCore import QPoint
            polygon = QPolygon([QPoint(x, y) for x, y in points])
            painter.drawPolygon(polygon)
            painter.end()
            self.setIcon(QIcon(pixmap))
    
    def update_menu_states(self):
        """Update menu item states based on service status"""
        try:
            service_status = win32serviceutil.QueryServiceStatus('ProcessManagerService')
            is_running = service_status[1] == win32service.SERVICE_RUNNING
            
            self.start_action.setEnabled(not is_running)
            self.stop_action.setEnabled(is_running)
            self.restart_action.setEnabled(is_running)
            
        except Exception:
            # Service not installed or error
            self.start_action.setEnabled(False)
            self.stop_action.setEnabled(False)
            self.restart_action.setEnabled(False)
    
    def on_tray_activated(self, reason):
        """Handle tray icon activation"""
        if reason == QSystemTrayIcon.DoubleClick:
            self.show_status()
    
    def start_service(self):
        """Start the Process Manager service"""
        try:
            win32serviceutil.StartService('ProcessManagerService')
            self.showMessage("Service Control", "Process Manager service started", 
                           QSystemTrayIcon.Information, 3000)
        except Exception as e:
            QMessageBox.critical(None, "Error", f"Failed to start service:\n{str(e)}")
    
    def stop_service(self):
        """Stop the Process Manager service"""
        try:
            win32serviceutil.StopService('ProcessManagerService')
            self.showMessage("Service Control", "Process Manager service stopped", 
                           QSystemTrayIcon.Information, 3000)
        except Exception as e:
            QMessageBox.critical(None, "Error", f"Failed to stop service:\n{str(e)}")
    
    def restart_service(self):
        """Restart the Process Manager service"""
        try:
            win32serviceutil.RestartService('ProcessManagerService')
            self.showMessage("Service Control", "Process Manager service restarted", 
                           QSystemTrayIcon.Information, 3000)
        except Exception as e:
            QMessageBox.critical(None, "Error", f"Failed to restart service:\n{str(e)}")
    
    def show_status(self):
        """Show detailed status dialog"""
        if not self.status_dialog:
            self.status_dialog = ServiceStatusDialog()
        
        # Update with current status
        if self.status_worker:
            status = self.status_worker.get_service_status()
            self.status_dialog.update_status(status)
        
        self.status_dialog.show()
        self.status_dialog.raise_()
        self.status_dialog.activateWindow()
    
    def view_logs(self):
        """Open log directory"""
        log_dir = Path(r"F:\MalwareAnalysis\Logs\Service")
        if log_dir.exists():
            os.startfile(str(log_dir))
        else:
            QMessageBox.information(None, "Logs", "No log directory found")
    
    def open_process_daemon(self):
        """Open the Process-Daemon console interface"""
        try:
            # Use the batch file for reliable launching
            batch_file = Path(__file__).parent / "start_daemon_console.bat"
            daemon_script = Path(__file__).parent / "process_daemon_console.py"
            
            if daemon_script.exists():
                if batch_file.exists():
                    # Use the batch file for most reliable execution
                    print(f"[TRAY] Opening daemon using batch file: {batch_file}")
                    os.system(f'start "Process Manager Daemon Console" "{batch_file}"')
                else:
                    # Fallback to direct Python execution
                    import sys
                    python_exe = sys.executable
                    script_dir = daemon_script.parent
                    cmd = f'cd /d "{script_dir}" && "{python_exe}" "{daemon_script.name}"'
                    full_cmd = f'start "Process Manager Daemon Console" cmd /k "title Process Manager Daemon Console && mode con: cols=100 lines=40 && {cmd}"'
                    print(f"[TRAY] Opening daemon with command: {full_cmd}")
                    os.system(full_cmd)
            else:
                QMessageBox.warning(None, "Process-Daemon", 
                                  f"Process daemon console not found at:\n{daemon_script}")
        except Exception as e:
            QMessageBox.critical(None, "Error", f"Failed to open Process-Daemon:\n{str(e)}")
    
    def show_settings(self):
        """Show settings dialog"""
        QMessageBox.information(None, "Settings", "Settings dialog not yet implemented")
    
    def show_daemon_status(self):
        """Show daemon service status"""
        try:
            status_file = Path(__file__).parent / "daemon_service_status.json"
            if status_file.exists():
                with open(status_file, 'r') as f:
                    status = json.load(f)
                
                msg = f"""Daemon Service Status:
                
Running: {'Yes' if status.get('daemon_running') else 'No'}
Threats Detected: {status.get('threats_detected', 0)}
Threats Eliminated: {status.get('threats_eliminated', 0)}
CPU Usage: {status.get('cpu_percent', 0):.1f}%
Memory Usage: {status.get('memory_percent', 0):.1f}%
Last Update: {status.get('timestamp', 'Unknown')}"""
                
                QMessageBox.information(None, "Daemon Status", msg)
            else:
                QMessageBox.warning(None, "Daemon Status", "Daemon service status not available")
        except Exception as e:
            QMessageBox.critical(None, "Error", f"Failed to get daemon status:\n{str(e)}")
    
    def start_daemon_service(self):
        """Start the daemon service"""
        try:
            win32serviceutil.StartService('ProcessDaemonService')
            self.showMessage("Daemon Service", "Process Daemon service started", 
                           QSystemTrayIcon.Information, 3000)
        except Exception as e:
            QMessageBox.critical(None, "Error", f"Failed to start daemon service:\n{str(e)}")
    
    def stop_daemon_service(self):
        """Stop the daemon service"""
        try:
            win32serviceutil.StopService('ProcessDaemonService')
            self.showMessage("Daemon Service", "Process Daemon service stopped", 
                           QSystemTrayIcon.Information, 3000)
        except Exception as e:
            QMessageBox.critical(None, "Error", f"Failed to stop daemon service:\n{str(e)}")
    
    def check_daemon_notifications(self):
        """Check for new daemon notifications and show them"""
        try:
            # Check threat notifications
            notification_file = Path(__file__).parent / "daemon_notifications.json"
            if notification_file.exists():
                with open(notification_file, 'r') as f:
                    notifications = json.load(f)
                
                # Find unread notifications
                unread_notifications = [n for n in notifications if not n.get('read', False)]
                
                for notification in unread_notifications:
                    # Show tray notification
                    title = notification.get('title', 'Daemon Alert')
                    message = notification.get('message', 'Unknown event')
                    threat_type = notification.get('threat_type', 'INFO')
                    
                    # Choose icon based on threat type
                    if threat_type in ['CRITICAL', 'HIGH']:
                        icon = QSystemTrayIcon.Critical
                    elif threat_type in ['MEDIUM', 'WARNING']:
                        icon = QSystemTrayIcon.Warning
                    else:
                        icon = QSystemTrayIcon.Information
                    
                    # Show notification
                    self.showMessage(title, message, icon, 5000)  # 5 second display
                    
                    # Mark as read
                    notification['read'] = True
                
                # Save updated notifications if any were marked as read
                if unread_notifications:
                    with open(notification_file, 'w') as f:
                        json.dump(notifications, f, indent=2)
            
            # Check file deletion notifications
            file_notification_file = Path(__file__).parent / "file_deletion_notifications.json"
            if file_notification_file.exists():
                with open(file_notification_file, 'r') as f:
                    file_notifications = json.load(f)
                
                # Find unread file notifications
                unread_file_notifications = [n for n in file_notifications if not n.get('read', False)]
                
                for notification in unread_file_notifications:
                    # Show tray notification
                    title = notification.get('title', 'File Alert')
                    message = notification.get('message', 'Unknown event')
                    action = notification.get('action', 'INFO')
                    
                    # Choose icon based on action
                    if action == 'QUARANTINED':
                        icon = QSystemTrayIcon.Information
                    elif action == 'CONFIRM_DELETE':
                        icon = QSystemTrayIcon.Warning
                    else:
                        icon = QSystemTrayIcon.Information
                    
                    # Show notification (longer for file actions - 7 seconds)
                    self.showMessage(title, message, icon, 7000)
                    
                    # Mark as read
                    notification['read'] = True
                
                # Save updated file notifications if any were marked as read
                if unread_file_notifications:
                    with open(file_notification_file, 'w') as f:
                        json.dump(file_notifications, f, indent=2)
                    
        except Exception as e:
            # Silently ignore notification errors to avoid spam
            pass
    
    def exit_application(self):
        """Exit the tray application"""
        if self.status_worker:
            self.status_worker.stop()
            self.status_worker.wait()
        
        self.app.quit()

def main():
    """Main application entry point"""
    app = QApplication(sys.argv)
    
    # Check if system tray is available
    if not QSystemTrayIcon.isSystemTrayAvailable():
        QMessageBox.critical(None, "System Tray", 
                           "System tray is not available on this system.")
        return 1
    
    # Prevent multiple instances
    app.setQuitOnLastWindowClosed(False)
    
    # Create tray application
    tray = ProcessManagerTray(app)
    
    # Show startup message
    tray.showMessage("Process Manager", "System tray application started", 
                    QSystemTrayIcon.Information, 3000)
    
    return app.exec_()

if __name__ == '__main__':
    sys.exit(main())
