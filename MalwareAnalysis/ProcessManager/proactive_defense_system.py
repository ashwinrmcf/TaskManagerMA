#!/usr/bin/env python3
"""
Proactive Defense System - Prevents threats before they execute
Ultimate protection that stops malware before it can even start
"""

import os
import sys
import time
import psutil
import threading
import subprocess
import ctypes
import hashlib
import winreg
from pathlib import Path
from ctypes import wintypes, windll
from PyQt5.QtCore import QThread, pyqtSignal

class ProactiveDefenseSystem(QThread):
    """Proactive defense system that prevents threats before execution"""
    
    threat_prevented = pyqtSignal(str, str, str)  # threat_type, file_path, prevention_method
    
    def __init__(self):
        super().__init__()
        self.running = True
        self.malware_signatures = set()
        self.behavioral_patterns = {}
        self.quarantine_dir = Path("F:/MalwareAnalysis/QUARANTINE_AUTO")
        self.quarantine_dir.mkdir(exist_ok=True)
        
    def run(self):
        """Main proactive defense loop"""
        print("[PROACTIVE-DEFENSE] üõ°Ô∏è PROACTIVE DEFENSE SYSTEM ACTIVE")
        
        # Initialize proactive defense
        self.initialize_proactive_defense()
        
        while self.running:
            try:
                self.scan_file_system_proactively()
                self.monitor_process_creation()
                self.analyze_behavioral_patterns()
                self.prevent_execution_attempts()
                time.sleep(0.02)  # 20ms scan interval - MAXIMUM SPEED
                
            except Exception as e:
                print(f"[PROACTIVE-DEFENSE] Error: {e}")
                time.sleep(0.1)
    
    def initialize_proactive_defense(self):
        """Initialize proactive defense mechanisms"""
        print("[PROACTIVE-DEFENSE] Initializing proactive defense...")
        
        # Load malware signatures
        self.load_malware_signatures()
        
        # Set up file system monitoring
        self.setup_filesystem_monitoring()
        
        # Configure execution prevention
        self.configure_execution_prevention()
        
        # Initialize behavioral analysis
        self.initialize_behavioral_analysis()
        
        print("[PROACTIVE-DEFENSE] ‚úÖ Proactive defense initialized")
    
    def load_malware_signatures(self):
        """Load comprehensive malware signatures"""
        try:
            # Known malware file signatures (simplified - real implementation would use YARA)
            self.malware_signatures.update([
                # Ransomware signatures
                b'\x4d\x5a\x90\x00\x03\x00\x00\x00\x04\x00\x00\x00\xff\xff',  # PE header
                b'encrypt', b'crypto', b'ransom', b'locker',
                b'wannacry', b'petya', b'ryuk', b'maze',
                
                # Trojan signatures
                b'backdoor', b'trojan', b'keylog', b'stealer',
                
                # Generic malicious patterns
                b'CreateRemoteThread', b'VirtualAllocEx', b'WriteProcessMemory',
                b'SetWindowsHookEx', b'GetAsyncKeyState'
            ])
            
            print(f"[PROACTIVE-DEFENSE] Loaded {len(self.malware_signatures)} malware signatures")
            
        except Exception as e:
            print(f"[PROACTIVE-DEFENSE] Error loading signatures: {e}")
    
    def setup_filesystem_monitoring(self):
        """Set up real-time file system monitoring"""
        try:
            # Monitor high-risk directories
            self.monitored_directories = [
                Path.home() / "Downloads",
                Path.home() / "Desktop", 
                Path.home() / "Documents",
                Path("C:/Users/Public"),
                Path("C:/Temp"),
                Path("C:/Windows/Temp"),
                Path(os.environ.get('TEMP', 'C:/Temp'))
            ]
            
            print(f"[PROACTIVE-DEFENSE] Monitoring {len(self.monitored_directories)} directories")
            
        except Exception as e:
            print(f"[PROACTIVE-DEFENSE] Error setting up monitoring: {e}")
    
    def configure_execution_prevention(self):
        """Configure execution prevention mechanisms"""
        try:
            # Set up Software Restriction Policies via registry
            self.setup_software_restriction()
            
            # Configure Windows Defender Application Control
            self.setup_application_control()
            
            # Set up execution blocking
            self.setup_execution_blocking()
            
        except Exception as e:
            print(f"[PROACTIVE-DEFENSE] Error configuring prevention: {e}")
    
    def setup_software_restriction(self):
        """Set up software restriction policies"""
        try:
            # Create registry entries for software restriction
            restriction_key = r"SOFTWARE\Policies\Microsoft\Windows\Safer\CodeIdentifiers"
            
            try:
                with winreg.CreateKey(winreg.HKEY_LOCAL_MACHINE, restriction_key) as key:
                    # Set default level to disallowed for unknown files
                    winreg.SetValueEx(key, "DefaultLevel", 0, winreg.REG_DWORD, 0x00000000)
                    winreg.SetValueEx(key, "ExecutableTypes", 0, winreg.REG_SZ, 
                        "ADE;ADP;BAS;BAT;CHM;CMD;COM;CPL;CRT;EXE;HLP;HTA;INF;INS;ISP;LNK;MDB;MDE;MSC;MSI;MSP;MST;OCX;PCD;PIF;REG;SCR;SHS;URL;VB;WSC")
            except Exception as e:
                pass  # May fail without admin privileges
                
        except Exception as e:
            pass
    
    def setup_application_control(self):
        """Set up application control policies"""
        try:
            # Use PowerShell to configure Windows Defender Application Control
            powershell_commands = [
                # Enable application control
                "Set-MpPreference -EnableControlledFolderAccess Enabled",
                # Add protected folders
                f"Add-MpPreference -ControlledFolderAccessProtectedFolders '{Path.home()}'",
                # Block suspicious file types
                "Set-MpPreference -AttackSurfaceReductionRules_Ids 75668C1F-73B5-4CF0-BB93-3ECF5CB7CC84 -AttackSurfaceReductionRules_Actions Enabled"
            ]
            
            for cmd in powershell_commands:
                try:
                    subprocess.run(['powershell', '-Command', cmd], 
                                 capture_output=True, timeout=5)
                except:
                    pass
                    
        except Exception as e:
            pass
    
    def setup_execution_blocking(self):
        """Set up direct execution blocking"""
        try:
            # Create execution blocker using NTFS alternate data streams
            self.blocked_executables = set()
            
            # Monitor for new executable files
            self.scan_for_new_executables()
            
        except Exception as e:
            pass
    
    def initialize_behavioral_analysis(self):
        """Initialize behavioral analysis engine"""
        try:
            self.behavioral_patterns = {
                'file_creation_rate': {},
                'network_connections': {},
                'registry_modifications': {},
                'process_spawning': {}
            }
            
            print("[PROACTIVE-DEFENSE] Behavioral analysis engine initialized")
            
        except Exception as e:
            print(f"[PROACTIVE-DEFENSE] Error initializing behavioral analysis: {e}")
    
    def scan_file_system_proactively(self):
        """Proactively scan file system for threats"""
        try:
            for directory in self.monitored_directories:
                if directory.exists():
                    self.scan_directory_for_threats(directory)
                    
        except Exception as e:
            pass
    
    def scan_directory_for_threats(self, directory):
        """Scan directory for malicious files"""
        try:
            # Get recently modified files (last 60 seconds)
            current_time = time.time()
            
            for file_path in directory.rglob('*'):
                if file_path.is_file():
                    try:
                        # Check if file was recently created/modified
                        mtime = file_path.stat().st_mtime
                        if current_time - mtime < 60:  # Last 60 seconds
                            
                            # Analyze file for threats
                            threat_level = self.analyze_file_threat_level(file_path)
                            
                            if threat_level > 0.7:  # High threat probability
                                self.prevent_file_execution(file_path, "SIGNATURE_MATCH")
                            elif threat_level > 0.4:  # Medium threat
                                self.quarantine_suspicious_file(file_path, "BEHAVIORAL_ANALYSIS")
                                
                    except (OSError, PermissionError):
                        continue
                        
        except Exception as e:
            pass
    
    def analyze_file_threat_level(self, file_path):
        """Analyze file and return threat level (0.0 to 1.0)"""
        try:
            threat_score = 0.0
            
            # Check file extension
            threat_score += self.check_file_extension(file_path)
            
            # Check file content signatures
            threat_score += self.check_file_signatures(file_path)
            
            # Check file location
            threat_score += self.check_file_location(file_path)
            
            # Check file metadata
            threat_score += self.check_file_metadata(file_path)
            
            return min(threat_score, 1.0)
            
        except Exception as e:
            return 0.0
    
    def check_file_extension(self, file_path):
        """Check file extension for threat indicators"""
        try:
            extension = file_path.suffix.lower()
            
            # High-risk extensions
            high_risk = {'.exe', '.scr', '.bat', '.cmd', '.com', '.pif', '.vbs', '.js'}
            medium_risk = {'.zip', '.rar', '.7z', '.doc', '.docx', '.pdf'}
            
            if extension in high_risk:
                return 0.4
            elif extension in medium_risk:
                return 0.2
                
            return 0.0
            
        except Exception as e:
            return 0.0
    
    def check_file_signatures(self, file_path):
        """Check file content for malware signatures"""
        try:
            if file_path.stat().st_size > 50 * 1024 * 1024:  # Skip files > 50MB
                return 0.0
                
            with open(file_path, 'rb') as f:
                # Read first 64KB for signature analysis
                content = f.read(65536)
                
                signature_matches = 0
                for signature in self.malware_signatures:
                    if signature in content:
                        signature_matches += 1
                
                # Return score based on signature matches
                if signature_matches >= 3:
                    return 0.8
                elif signature_matches >= 1:
                    return 0.4
                    
            return 0.0
            
        except Exception as e:
            return 0.0
    
    def check_file_location(self, file_path):
        """Check file location for threat indicators"""
        try:
            path_str = str(file_path).lower()
            
            # High-risk locations
            if any(location in path_str for location in [
                'temp', 'tmp', 'downloads', 'desktop', 'public'
            ]):
                return 0.3
                
            # Very high-risk locations
            if any(location in path_str for location in [
                'appdata\\roaming', 'programdata', 'startup'
            ]):
                return 0.5
                
            return 0.0
            
        except Exception as e:
            return 0.0
    
    def check_file_metadata(self, file_path):
        """Check file metadata for threat indicators"""
        try:
            # Check file size (very small or very large files can be suspicious)
            size = file_path.stat().st_size
            
            if size < 1024:  # Very small files
                return 0.2
            elif size > 100 * 1024 * 1024:  # Very large files
                return 0.1
                
            # Check if file has no extension but is executable
            if not file_path.suffix and self.is_executable_file(file_path):
                return 0.4
                
            return 0.0
            
        except Exception as e:
            return 0.0
    
    def is_executable_file(self, file_path):
        """Check if file is executable"""
        try:
            with open(file_path, 'rb') as f:
                header = f.read(2)
                return header == b'MZ'  # PE executable header
                
        except Exception as e:
            return False
    
    def prevent_file_execution(self, file_path, prevention_method):
        """Prevent file from executing"""
        try:
            print(f"[PROACTIVE-DEFENSE] üö® PREVENTING EXECUTION: {file_path}")
            
            # Method 1: Move to quarantine
            quarantine_path = self.quarantine_dir / f"{file_path.name}_{int(time.time())}"
            file_path.rename(quarantine_path)
            
            # Method 2: Set file attributes to prevent execution
            try:
                subprocess.run(['attrib', '+R', '+H', str(quarantine_path)], 
                             capture_output=True, timeout=2)
            except:
                pass
            
            # Method 3: Remove execute permissions
            try:
                subprocess.run(['icacls', str(quarantine_path), '/deny', 'Everyone:X'], 
                             capture_output=True, timeout=2)
            except:
                pass
            
            self.threat_prevented.emit("MALWARE_EXECUTION", str(file_path), prevention_method)
            print(f"[PROACTIVE-DEFENSE] ‚úÖ THREAT PREVENTED: {file_path.name}")
            
        except Exception as e:
            print(f"[PROACTIVE-DEFENSE] Error preventing execution: {e}")
    
    def quarantine_suspicious_file(self, file_path, reason):
        """Quarantine suspicious file for analysis"""
        try:
            quarantine_path = self.quarantine_dir / f"SUSPICIOUS_{file_path.name}_{int(time.time())}"
            shutil.copy2(file_path, quarantine_path)
            
            # Log the quarantine action
            with open(self.quarantine_dir / "quarantine_log.txt", 'a') as f:
                f.write(f"{time.ctime()}: {file_path} -> {quarantine_path} (Reason: {reason})\n")
            
            print(f"[PROACTIVE-DEFENSE] üì¶ QUARANTINED: {file_path.name}")
            
        except Exception as e:
            pass
    
    def monitor_process_creation(self):
        """Monitor and prevent malicious process creation"""
        try:
            # Get current processes
            current_processes = set(proc.pid for proc in psutil.process_iter())
            
            # Check for new processes
            if hasattr(self, 'previous_processes'):
                new_processes = current_processes - self.previous_processes
                
                for pid in new_processes:
                    try:
                        proc = psutil.Process(pid)
                        if self.is_malicious_process(proc):
                            self.prevent_process_execution(proc)
                    except (psutil.NoSuchProcess, psutil.AccessDenied):
                        continue
            
            self.previous_processes = current_processes
            
        except Exception as e:
            pass
    
    def is_malicious_process(self, process):
        """Check if process is malicious"""
        try:
            # Check process name
            name = process.name().lower()
            if any(pattern in name for pattern in [
                'encrypt', 'crypto', 'ransom', 'locker', 'trojan', 'backdoor'
            ]):
                return True
            
            # Check process location
            try:
                exe_path = process.exe().lower()
                if any(location in exe_path for location in [
                    'temp', 'tmp', 'appdata\\roaming', 'downloads'
                ]):
                    return True
            except (psutil.AccessDenied, psutil.NoSuchProcess):
                pass
            
            # Check command line arguments
            try:
                cmdline = ' '.join(process.cmdline()).lower()
                if any(pattern in cmdline for pattern in [
                    'encrypt', 'delete', 'format', 'cipher', 'vssadmin delete'
                ]):
                    return True
            except (psutil.AccessDenied, psutil.NoSuchProcess):
                pass
            
            return False
            
        except Exception as e:
            return False
    
    def prevent_process_execution(self, process):
        """Prevent malicious process from executing"""
        try:
            pid = process.pid
            name = process.name()
            
            print(f"[PROACTIVE-DEFENSE] üö® PREVENTING PROCESS: {name} (PID: {pid})")
            
            # Immediate termination
            process.kill()
            
            # Block future executions of this file
            try:
                exe_path = Path(process.exe())
                self.prevent_file_execution(exe_path, "MALICIOUS_PROCESS")
            except:
                pass
            
            self.threat_prevented.emit("MALICIOUS_PROCESS", name, "PROCESS_TERMINATION")
            print(f"[PROACTIVE-DEFENSE] ‚úÖ PROCESS PREVENTED: {name}")
            
        except Exception as e:
            print(f"[PROACTIVE-DEFENSE] Error preventing process: {e}")
    
    def analyze_behavioral_patterns(self):
        """Analyze system behavior for threat patterns"""
        try:
            # Analyze file creation patterns
            self.analyze_file_creation_patterns()
            
            # Analyze network behavior
            self.analyze_network_patterns()
            
            # Analyze registry modifications
            self.analyze_registry_patterns()
            
        except Exception as e:
            pass
    
    def analyze_file_creation_patterns(self):
        """Analyze file creation patterns for ransomware behavior"""
        try:
            current_time = time.time()
            
            # Count recent file creations per process
            for proc in psutil.process_iter(['pid', 'name', 'open_files']):
                try:
                    pid = proc.info['pid']
                    name = proc.info['name']
                    
                    if proc.info['open_files']:
                        recent_files = 0
                        for file_info in proc.info['open_files']:
                            try:
                                mtime = os.path.getmtime(file_info.path)
                                if current_time - mtime < 10:  # Last 10 seconds
                                    recent_files += 1
                            except:
                                continue
                        
                        # If process created many files recently, it's suspicious
                        if recent_files > 20:
                            self.threat_prevented.emit("RANSOMWARE_BEHAVIOR", 
                                f"Mass file creation by {name}", "BEHAVIORAL_ANALYSIS")
                            
                            # Terminate the process
                            try:
                                proc_obj = psutil.Process(pid)
                                proc_obj.kill()
                                print(f"[PROACTIVE-DEFENSE] ‚úÖ STOPPED RANSOMWARE BEHAVIOR: {name}")
                            except:
                                pass
                                
                except (psutil.NoSuchProcess, psutil.AccessDenied):
                    continue
                    
        except Exception as e:
            pass
    
    def analyze_network_patterns(self):
        """Analyze network patterns for C&C communication"""
        try:
            # Monitor for suspicious network connections
            for conn in psutil.net_connections(kind='inet'):
                if conn.status == 'ESTABLISHED' and conn.raddr:
                    # Check for connections to suspicious ports
                    if conn.raddr.port in {4444, 6666, 8080, 9999, 1337, 31337}:
                        try:
                            proc = psutil.Process(conn.pid) if conn.pid else None
                            if proc:
                                self.threat_prevented.emit("C2_COMMUNICATION",
                                    f"{proc.name()} -> {conn.raddr.ip}:{conn.raddr.port}",
                                    "NETWORK_BLOCKING")
                                
                                # Block the connection by terminating process
                                proc.kill()
                                
                        except:
                            pass
                            
        except Exception as e:
            pass
    
    def analyze_registry_patterns(self):
        """Analyze registry modification patterns"""
        # This would be implemented with registry monitoring
        # For now, we rely on the registry protector in fortress system
        pass
    
    def prevent_execution_attempts(self):
        """Prevent execution attempts through various vectors"""
        try:
            # Monitor for script execution attempts
            self.prevent_script_execution()
            
            # Monitor for service installation attempts
            self.prevent_malicious_services()
            
            # Monitor for startup persistence attempts
            self.prevent_startup_persistence()
            
        except Exception as e:
            pass
    
    def prevent_script_execution(self):
        """Prevent malicious script execution"""
        try:
            script_processes = ['powershell.exe', 'cmd.exe', 'wscript.exe', 'cscript.exe']
            
            for proc in psutil.process_iter(['pid', 'name', 'cmdline']):
                try:
                    name = proc.info['name'].lower()
                    
                    if name in script_processes:
                        cmdline = ' '.join(proc.info.get('cmdline', [])).lower()
                        
                        # Check for malicious script patterns
                        if any(pattern in cmdline for pattern in [
                            'downloadstring', 'invoke-expression', 'iex', 'bypass',
                            'hidden', 'encrypt', 'delete', 'vssadmin'
                        ]):
                            self.threat_prevented.emit("MALICIOUS_SCRIPT", cmdline[:100], "SCRIPT_BLOCKING")
                            
                            # Terminate the script
                            script_proc = psutil.Process(proc.info['pid'])
                            script_proc.kill()
                            print(f"[PROACTIVE-DEFENSE] ‚úÖ BLOCKED MALICIOUS SCRIPT: {name}")
                            
                except (psutil.NoSuchProcess, psutil.AccessDenied):
                    continue
                    
        except Exception as e:
            pass
    
    def prevent_malicious_services(self):
        """Prevent installation of malicious services"""
        try:
            # Monitor sc.exe for service creation
            for proc in psutil.process_iter(['pid', 'name', 'cmdline']):
                try:
                    if proc.info['name'].lower() == 'sc.exe':
                        cmdline = ' '.join(proc.info.get('cmdline', [])).lower()
                        
                        if 'create' in cmdline:
                            # Check if service being created is suspicious
                            if any(pattern in cmdline for pattern in [
                                'temp', 'tmp', 'appdata', 'programdata'
                            ]):
                                self.threat_prevented.emit("MALICIOUS_SERVICE", cmdline[:100], "SERVICE_BLOCKING")
                                
                                # Terminate sc.exe
                                sc_proc = psutil.Process(proc.info['pid'])
                                sc_proc.kill()
                                print("[PROACTIVE-DEFENSE] ‚úÖ BLOCKED MALICIOUS SERVICE INSTALLATION")
                                
                except (psutil.NoSuchProcess, psutil.AccessDenied):
                    continue
                    
        except Exception as e:
            pass
    
    def prevent_startup_persistence(self):
        """Prevent malicious startup persistence"""
        # This is handled by the registry protector in fortress system
        pass
    
    def scan_for_new_executables(self):
        """Scan for new executable files"""
        try:
            for directory in self.monitored_directories:
                if directory.exists():
                    for file_path in directory.rglob('*.exe'):
                        if file_path not in self.blocked_executables:
                            # Analyze new executable
                            threat_level = self.analyze_file_threat_level(file_path)
                            
                            if threat_level > 0.6:
                                self.prevent_file_execution(file_path, "NEW_EXECUTABLE_SCAN")
                                self.blocked_executables.add(file_path)
                                
        except Exception as e:
            pass
    
    def stop_proactive_defense(self):
        """Stop proactive defense system"""
        self.running = False

# Global proactive defense instance
proactive_defense_system = None

def start_proactive_defense():
    """Start proactive defense system"""
    global proactive_defense_system
    proactive_defense_system = ProactiveDefenseSystem()
    proactive_defense_system.start()
    return proactive_defense_system

def stop_proactive_defense():
    """Stop proactive defense system"""
    global proactive_defense_system
    if proactive_defense_system:
        proactive_defense_system.stop_proactive_defense()
        proactive_defense_system.quit()
        proactive_defense_system.wait(2000)
        proactive_defense_system = None
