#!/usr/bin/env python3
"""
Self-Protection System - Prevents malware from disabling the protection system
Makes the protection system safer than itself
"""

import os
import sys
import time
import psutil
import threading
import subprocess
import ctypes
import shutil
from pathlib import Path
from ctypes import wintypes, windll
from PyQt5.QtCore import QThread, pyqtSignal

class SelfProtectionSystem(QThread):
    """Self-protection system to prevent malware from disabling protection"""
    
    protection_attack_detected = pyqtSignal(str, str)  # attack_type, details
    
    def __init__(self):
        super().__init__()
        self.running = True
        self.protection_processes = set()
        self.protection_files = set()
        self.decoy_processes = []
        self.self_pid = os.getpid()
        
    def run(self):
        """Main self-protection loop"""
        print("[SELF-PROTECTION] üõ°Ô∏è SELF-PROTECTION SYSTEM ACTIVE")
        
        # Initialize self-protection
        self.initialize_self_protection()
        
        while self.running:
            try:
                self.protect_own_processes()
                self.monitor_protection_files()
                self.detect_termination_attempts()
                self.maintain_decoy_processes()
                self.verify_system_integrity()
                time.sleep(0.05)  # 50ms scan interval
                
            except Exception as e:
                print(f"[SELF-PROTECTION] Error: {e}")
                time.sleep(0.1)
    
    def initialize_self_protection(self):
        """Initialize comprehensive self-protection"""
        print("[SELF-PROTECTION] Initializing self-protection mechanisms...")
        
        # Register protection processes
        self.register_protection_processes()
        
        # Create file backups
        self.create_protection_backups()
        
        # Deploy decoy processes
        self.deploy_decoy_processes()
        
        # Set process protection
        self.set_process_protection()
        
        print("[SELF-PROTECTION] ‚úÖ Self-protection initialized")
    
    def register_protection_processes(self):
        """Register all protection-related processes"""
        try:
            current_process = psutil.Process()
            self.protection_processes.add(current_process.pid)
            
            # Find related protection processes
            for proc in psutil.process_iter(['pid', 'name', 'cmdline']):
                try:
                    cmdline = ' '.join(proc.info.get('cmdline', []))
                    name = proc.info['name'].lower()
                    
                    # Identify protection processes
                    if any(keyword in cmdline.lower() for keyword in [
                        'fortress_protection', 'immediate_threat', 'memory_protection',
                        'system_hardening', 'process_manager_gui'
                    ]):
                        self.protection_processes.add(proc.info['pid'])
                        
                    if any(keyword in name for keyword in [
                        'python', 'pythonw'
                    ]) and 'malwareanalysis' in cmdline.lower():
                        self.protection_processes.add(proc.info['pid'])
                        
                except (psutil.NoSuchProcess, psutil.AccessDenied):
                    continue
            
            print(f"[SELF-PROTECTION] Registered {len(self.protection_processes)} protection processes")
            
        except Exception as e:
            print(f"[SELF-PROTECTION] Error registering processes: {e}")
    
    def create_protection_backups(self):
        """Create backups of protection system files"""
        try:
            backup_dir = Path("F:/MalwareAnalysis/PROTECTION_BACKUP")
            backup_dir.mkdir(exist_ok=True)
            
            protection_files = [
                "fortress_protection_system.py",
                "immediate_threat_terminator.py", 
                "memory_protection_layer.py",
                "system_hardening_engine.py",
                "self_protection_system.py",
                "process_manager_gui.py"
            ]
            
            base_dir = Path("F:/MalwareAnalysis/ProcessManager")
            
            for file_name in protection_files:
                source_path = base_dir / file_name
                if source_path.exists():
                    backup_path = backup_dir / file_name
                    shutil.copy2(source_path, backup_path)
                    self.protection_files.add(str(source_path))
                    print(f"[SELF-PROTECTION] Backed up: {file_name}")
            
        except Exception as e:
            print(f"[SELF-PROTECTION] Error creating backups: {e}")
    
    def deploy_decoy_processes(self):
        """Deploy decoy processes to confuse malware"""
        try:
            decoy_scripts = [
                "fake_antivirus.py",
                "dummy_protection.py", 
                "decoy_monitor.py"
            ]
            
            for script_name in decoy_scripts:
                try:
                    # Create simple decoy script
                    decoy_content = f'''
import time
import sys
print("[DECOY-{script_name.upper()}] Fake protection running...")
while True:
    time.sleep(1)
'''
                    decoy_path = Path(f"F:/MalwareAnalysis/ProcessManager/{script_name}")
                    with open(decoy_path, 'w') as f:
                        f.write(decoy_content)
                    
                    # Start decoy process
                    proc = subprocess.Popen([sys.executable, str(decoy_path)], 
                                          creationflags=subprocess.CREATE_NO_WINDOW)
                    self.decoy_processes.append(proc)
                    
                except Exception as e:
                    pass
            
            print(f"[SELF-PROTECTION] Deployed {len(self.decoy_processes)} decoy processes")
            
        except Exception as e:
            print(f"[SELF-PROTECTION] Error deploying decoys: {e}")
    
    def set_process_protection(self):
        """Set advanced process protection"""
        try:
            # Set critical process flag (requires admin privileges)
            kernel32 = ctypes.windll.kernel32
            ntdll = ctypes.windll.ntdll
            
            # Try to set process as critical (will fail without admin, but that's ok)
            try:
                current_process = kernel32.GetCurrentProcess()
                # This would require admin privileges
                # ntdll.RtlSetProcessIsCritical(1, 0, 0)
            except:
                pass
            
            # Set process priority to high
            try:
                current_process = psutil.Process()
                current_process.nice(psutil.HIGH_PRIORITY_CLASS)
            except:
                pass
                
        except Exception as e:
            pass
    
    def protect_own_processes(self):
        """Protect own processes from termination"""
        try:
            # Check if protection processes are still running
            current_pids = set(proc.pid for proc in psutil.process_iter())
            
            for pid in list(self.protection_processes):
                if pid not in current_pids:
                    self.protection_attack_detected.emit("PROCESS_TERMINATION", f"Protection process {pid} terminated")
                    self.restart_protection_process(pid)
                    self.protection_processes.discard(pid)
            
            # Monitor for termination attempts
            self.monitor_termination_attempts()
            
        except Exception as e:
            pass
    
    def monitor_termination_attempts(self):
        """Monitor for attempts to terminate protection processes"""
        try:
            # Check for taskkill attempts on protection processes
            for proc in psutil.process_iter(['pid', 'name', 'cmdline']):
                try:
                    cmdline = ' '.join(proc.info.get('cmdline', []))
                    name = proc.info['name'].lower()
                    
                    # Detect taskkill attempts
                    if name == 'taskkill.exe':
                        for pid in self.protection_processes:
                            if str(pid) in cmdline:
                                self.protection_attack_detected.emit("TERMINATION_ATTEMPT", 
                                    f"Taskkill attempt on protection process {pid}")
                                # Kill the attacking process
                                self.terminate_attacker(proc.info['pid'])
                    
                    # Detect PowerShell stop-process attempts
                    if 'powershell' in name and 'stop-process' in cmdline.lower():
                        for pid in self.protection_processes:
                            if str(pid) in cmdline:
                                self.protection_attack_detected.emit("TERMINATION_ATTEMPT",
                                    f"PowerShell termination attempt on {pid}")
                                self.terminate_attacker(proc.info['pid'])
                                
                except (psutil.NoSuchProcess, psutil.AccessDenied):
                    continue
                    
        except Exception as e:
            pass
    
    def terminate_attacker(self, attacker_pid):
        """Terminate process attempting to kill protection"""
        try:
            attacker = psutil.Process(attacker_pid)
            attacker.kill()
            print(f"[SELF-PROTECTION] ‚úÖ Terminated attacker process: {attacker_pid}")
            
        except Exception as e:
            print(f"[SELF-PROTECTION] Failed to terminate attacker {attacker_pid}: {e}")
    
    def restart_protection_process(self, terminated_pid):
        """Restart terminated protection process"""
        try:
            # This is a simplified restart - in reality would need more sophisticated logic
            print(f"[SELF-PROTECTION] üîÑ Attempting to restart protection process {terminated_pid}")
            
            # Try to restart the main GUI if it was terminated
            if terminated_pid == self.self_pid:
                subprocess.Popen([
                    sys.executable, 
                    "F:/MalwareAnalysis/ProcessManager/process_manager_gui.py"
                ], creationflags=subprocess.CREATE_NO_WINDOW)
                
        except Exception as e:
            print(f"[SELF-PROTECTION] Failed to restart process: {e}")
    
    def monitor_protection_files(self):
        """Monitor protection system files for modification/deletion"""
        try:
            for file_path in list(self.protection_files):
                if not os.path.exists(file_path):
                    self.protection_attack_detected.emit("FILE_DELETION", f"Protection file deleted: {file_path}")
                    self.restore_protection_file(file_path)
                else:
                    # Check for modification
                    if self.file_was_modified(file_path):
                        self.protection_attack_detected.emit("FILE_MODIFICATION", f"Protection file modified: {file_path}")
                        self.restore_protection_file(file_path)
                        
        except Exception as e:
            pass
    
    def file_was_modified(self, file_path):
        """Check if protection file was maliciously modified"""
        try:
            # Simple check - compare file size with backup
            backup_path = Path("F:/MalwareAnalysis/PROTECTION_BACKUP") / Path(file_path).name
            
            if backup_path.exists():
                original_size = os.path.getsize(file_path)
                backup_size = os.path.getsize(backup_path)
                
                # If file is significantly smaller, it might be corrupted
                if original_size < backup_size * 0.5:
                    return True
                    
        except Exception as e:
            pass
            
        return False
    
    def restore_protection_file(self, file_path):
        """Restore protection file from backup"""
        try:
            backup_path = Path("F:/MalwareAnalysis/PROTECTION_BACKUP") / Path(file_path).name
            
            if backup_path.exists():
                shutil.copy2(backup_path, file_path)
                print(f"[SELF-PROTECTION] ‚úÖ Restored protection file: {file_path}")
            else:
                print(f"[SELF-PROTECTION] ‚ùå No backup found for: {file_path}")
                
        except Exception as e:
            print(f"[SELF-PROTECTION] Failed to restore {file_path}: {e}")
    
    def detect_termination_attempts(self):
        """Detect various termination attempts"""
        try:
            # Monitor for process injection attempts
            self.detect_process_injection()
            
            # Monitor for DLL injection
            self.detect_dll_injection()
            
            # Monitor for memory manipulation
            self.detect_memory_manipulation()
            
        except Exception as e:
            pass
    
    def detect_process_injection(self):
        """Detect process injection attempts"""
        try:
            for pid in self.protection_processes:
                try:
                    proc = psutil.Process(pid)
                    
                    # Check for unusual memory usage patterns
                    memory_info = proc.memory_info()
                    
                    # If memory usage suddenly spikes, might indicate injection
                    if hasattr(self, f'baseline_memory_{pid}'):
                        baseline = getattr(self, f'baseline_memory_{pid}')
                        if memory_info.rss > baseline * 2:  # 2x memory increase
                            self.protection_attack_detected.emit("PROCESS_INJECTION", 
                                f"Possible injection in protection process {pid}")
                    else:
                        setattr(self, f'baseline_memory_{pid}', memory_info.rss)
                        
                except (psutil.NoSuchProcess, psutil.AccessDenied):
                    continue
                    
        except Exception as e:
            pass
    
    def detect_dll_injection(self):
        """Detect DLL injection attempts"""
        try:
            for pid in self.protection_processes:
                try:
                    proc = psutil.Process(pid)
                    
                    # Check loaded modules (simplified)
                    try:
                        modules = proc.memory_maps()
                        suspicious_modules = []
                        
                        for module in modules:
                            path = module.path.lower()
                            # Check for suspicious DLL locations
                            if any(location in path for location in ['temp', 'tmp', 'appdata']):
                                suspicious_modules.append(path)
                        
                        if suspicious_modules:
                            self.protection_attack_detected.emit("DLL_INJECTION",
                                f"Suspicious DLLs in process {pid}: {suspicious_modules}")
                                
                    except (psutil.AccessDenied, AttributeError):
                        pass
                        
                except (psutil.NoSuchProcess, psutil.AccessDenied):
                    continue
                    
        except Exception as e:
            pass
    
    def detect_memory_manipulation(self):
        """Detect memory manipulation attempts"""
        try:
            # Check for processes trying to access protection process memory
            for proc in psutil.process_iter(['pid', 'name']):
                try:
                    # This is a simplified check
                    proc_name = proc.info['name'].lower()
                    
                    # Suspicious process names that might try memory manipulation
                    if any(keyword in proc_name for keyword in [
                        'inject', 'hook', 'patch', 'debug', 'cheat'
                    ]):
                        self.protection_attack_detected.emit("MEMORY_MANIPULATION",
                            f"Suspicious process detected: {proc_name}")
                        self.terminate_attacker(proc.info['pid'])
                        
                except (psutil.NoSuchProcess, psutil.AccessDenied):
                    continue
                    
        except Exception as e:
            pass
    
    def maintain_decoy_processes(self):
        """Maintain decoy processes"""
        try:
            # Check if decoy processes are still running
            running_decoys = []
            
            for proc in self.decoy_processes:
                if proc.poll() is None:  # Still running
                    running_decoys.append(proc)
                else:
                    # Decoy was terminated, restart it
                    self.protection_attack_detected.emit("DECOY_TERMINATION", "Decoy process terminated")
            
            self.decoy_processes = running_decoys
            
            # If we lost decoys, redeploy
            if len(self.decoy_processes) < 3:
                self.deploy_decoy_processes()
                
        except Exception as e:
            pass
    
    def verify_system_integrity(self):
        """Verify protection system integrity"""
        try:
            # Check if all protection modules are still importable
            protection_modules = [
                'fortress_protection_system',
                'immediate_threat_terminator',
                'memory_protection_layer',
                'system_hardening_engine'
            ]
            
            for module_name in protection_modules:
                try:
                    __import__(module_name)
                except ImportError:
                    self.protection_attack_detected.emit("MODULE_CORRUPTION",
                        f"Protection module corrupted: {module_name}")
                    # Try to restore from backup
                    self.restore_protection_file(f"F:/MalwareAnalysis/ProcessManager/{module_name}.py")
                    
        except Exception as e:
            pass
    
    def stop_self_protection(self):
        """Stop self-protection system"""
        print("[SELF-PROTECTION] Stopping self-protection system...")
        
        # Terminate decoy processes
        for proc in self.decoy_processes:
            try:
                proc.terminate()
                proc.wait(timeout=2)
            except:
                pass
        
        self.running = False

# Global self-protection instance
self_protection_system = None

def start_self_protection():
    """Start self-protection system"""
    global self_protection_system
    self_protection_system = SelfProtectionSystem()
    self_protection_system.start()
    return self_protection_system

def stop_self_protection():
    """Stop self-protection system"""
    global self_protection_system
    if self_protection_system:
        self_protection_system.stop_self_protection()
        self_protection_system.quit()
        self_protection_system.wait(2000)
        self_protection_system = None
