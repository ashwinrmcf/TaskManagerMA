#!/usr/bin/env python3
"""
Immediate Threat Terminator - Kills malware processes INSTANTLY upon detection
Prevents ransomware from encrypting files by terminating processes within milliseconds
"""

import os
import sys
import time
import psutil
import threading
import subprocess
from pathlib import Path
from PyQt5.QtCore import QThread, pyqtSignal, QTimer

class ImmediateThreatTerminator(QThread):
    """Terminates malware processes immediately upon detection - no delays"""
    
    threat_terminated = pyqtSignal(str, int)  # process_name, pid
    
    def __init__(self):
        super().__init__()
        self.running = True
        self.essential_processes = set()
        self.malware_patterns = set()
        self.load_threat_signatures()
        self.terminated_pids = set()
        
    def load_threat_signatures(self):
        """Load essential processes and malware patterns"""
        try:
            essential_file = Path(__file__).parent / "essential_processes.txt"
            if essential_file.exists():
                with open(essential_file, 'r') as f:
                    for line in f:
                        line = line.strip().lower()
                        if line and not line.startswith('#'):
                            if line.startswith('malware:'):
                                self.malware_patterns.add(line.replace('malware:', ''))
                            else:
                                self.essential_processes.add(line)
            
            # Add known ransomware patterns
            self.malware_patterns.update([
                'ransomware', 'encrypt', 'crypto', 'locker', 'satan', 'nasan',
                'wannacry', 'petya', 'ryuk', 'maze', 'conti', 'revil'
            ])
            
            print(f"[TERMINATOR] Loaded {len(self.essential_processes)} essential processes")
            print(f"[TERMINATOR] Loaded {len(self.malware_patterns)} malware patterns")
            
        except Exception as e:
            print(f"[TERMINATOR] Error loading signatures: {e}")
    
    def run(self):
        """Main termination loop - scans every 10ms for MAXIMUM protection"""
        print("[THREAT-TERMINATOR] üö® FORTRESS MODE - MAXIMUM THREAT TERMINATOR ACTIVE")
        print("[THREAT-TERMINATOR] Scanning every 10ms - NO ESCAPE POSSIBLE")
        
        while self.running:
            try:
                self.scan_and_terminate_threats()
                time.sleep(0.01)  # 10ms scan interval - MAXIMUM RESPONSIVENESS
                
            except Exception as e:
                print(f"[THREAT-TERMINATOR] Error in main loop: {e}")
                time.sleep(0.05)
    
    def scan_and_terminate_threats(self):
        """Scan for threats and terminate immediately"""
        current_processes = []
        
        try:
            # Get all running processes
            for proc in psutil.process_iter(['pid', 'name', 'exe', 'cmdline']):
                try:
                    proc_info = proc.info
                    if proc_info['pid'] in self.terminated_pids:
                        continue  # Skip already terminated processes
                        
                    current_processes.append(proc_info)
                    
                except (psutil.NoSuchProcess, psutil.AccessDenied):
                    continue
            
            # Check each process for threats
            for proc_info in current_processes:
                if self.is_threat(proc_info):
                    self.terminate_immediately(proc_info)
                    
        except Exception as e:
            print(f"[TERMINATOR] Error scanning processes: {e}")
    
    def is_threat(self, proc_info):
        """Determine if process is a threat requiring immediate termination"""
        try:
            pid = proc_info['pid']
            name = proc_info['name'].lower() if proc_info['name'] else ''
            exe = proc_info['exe'].lower() if proc_info['exe'] else ''
            cmdline = ' '.join(proc_info['cmdline']).lower() if proc_info['cmdline'] else ''
            
            # Skip essential processes
            if name in self.essential_processes:
                return False
            
            # Check for malware patterns in process name
            for pattern in self.malware_patterns:
                if pattern in name or pattern in exe or pattern in cmdline:
                    return True
            
            # Check for suspicious file locations
            suspicious_locations = [
                'temp', 'tmp', 'appdata\\local\\temp', 'downloads',
                'programdata', 'users\\public', '$recycle.bin'
            ]
            
            for location in suspicious_locations:
                if location in exe:
                    # Additional checks for files in suspicious locations
                    if self.has_malware_characteristics(proc_info):
                        return True
            
            # Check for processes with no executable path (potential injection)
            if not exe and name and pid > 4:  # Skip system processes
                return True
                
            return False
            
        except Exception as e:
            print(f"[TERMINATOR] Error checking threat: {e}")
            return False
    
    def has_malware_characteristics(self, proc_info):
        """Check for additional malware characteristics"""
        try:
            pid = proc_info['pid']
            proc = psutil.Process(pid)
            
            # Check CPU usage (ransomware often uses high CPU for encryption)
            cpu_percent = proc.cpu_percent(interval=0.1)
            if cpu_percent > 50:
                return True
            
            # Check memory usage patterns
            memory_info = proc.memory_info()
            if memory_info.rss > 100 * 1024 * 1024:  # >100MB for suspicious location
                return True
            
            # Check for file operations (ransomware accesses many files)
            try:
                open_files = proc.open_files()
                if len(open_files) > 50:  # Many open files
                    return True
            except (psutil.AccessDenied, psutil.NoSuchProcess):
                pass
            
            return False
            
        except Exception as e:
            return False
    
    def terminate_process_with_extreme_force(self, proc_info):
        """Terminate process using multiple methods for guaranteed kill - FORTRESS MODE"""
        pid = proc_info['pid']
        name = proc_info['name']
        
        print(f"[FORTRESS-TERMINATOR] üö® ELIMINATING THREAT: {name} (PID: {pid})")
        
        success = False
        
        # Method 1: Direct psutil kill
        try:
            proc = psutil.Process(pid)
            proc.kill()
            success = True
            print(f"[FORTRESS-TERMINATOR] ‚úÖ Method 1 (psutil.kill) SUCCESS: {name}")
        except Exception as e:
            print(f"[FORTRESS-TERMINATOR] ‚ùå Method 1 failed: {e}")
        
        # Method 2: Windows API TerminateProcess (immediate)
        if not success:
            try:
                import ctypes
                handle = ctypes.windll.kernel32.OpenProcess(0x1F0FFF, False, pid)  # PROCESS_ALL_ACCESS
                if handle:
                    ctypes.windll.kernel32.TerminateProcess(handle, 1)
                    ctypes.windll.kernel32.CloseHandle(handle)
                    success = True
                    print(f"[FORTRESS-TERMINATOR] ‚úÖ Method 2 (WinAPI) SUCCESS: {name}")
            except Exception as e:
                print(f"[FORTRESS-TERMINATOR] ‚ùå Method 2 failed: {e}")
        
        # Method 3: NtTerminateProcess (kernel-level)
        if not success:
            try:
                import ctypes
                ntdll = ctypes.windll.ntdll
                handle = ctypes.windll.kernel32.OpenProcess(0x1F0FFF, False, pid)
                if handle:
                    ntdll.NtTerminateProcess(handle, 1)
                    ctypes.windll.kernel32.CloseHandle(handle)
                    success = True
                    print(f"[FORTRESS-TERMINATOR] ‚úÖ Method 3 (NtTerminate) SUCCESS: {name}")
            except Exception as e:
                print(f"[FORTRESS-TERMINATOR] ‚ùå Method 3 failed: {e}")
        
        # Method 4: System taskkill command with force
        if not success:
            try:
                import subprocess
                result = subprocess.run(['taskkill', '/F', '/PID', str(pid)], 
                                      capture_output=True, timeout=2)
                if result.returncode == 0:
                    success = True
                    print(f"[FORTRESS-TERMINATOR] ‚úÖ Method 4 (taskkill) SUCCESS: {name}")
            except Exception as e:
                print(f"[FORTRESS-TERMINATOR] ‚ùå Method 4 failed: {e}")
        
        # Method 5: WMIC process deletion (system-level)
        if not success:
            try:
                import subprocess
                result = subprocess.run([
                    'wmic', 'process', 'where', f'ProcessId={pid}', 'delete'
                ], capture_output=True, timeout=3)
                if result.returncode == 0:
                    success = True
                    print(f"[FORTRESS-TERMINATOR] ‚úÖ Method 5 (WMIC) SUCCESS: {name}")
            except Exception as e:
                print(f"[FORTRESS-TERMINATOR] ‚ùå Method 5 failed: {e}")
        
        # Method 6: PowerShell Stop-Process (administrative)
        if not success:
            try:
                import subprocess
                result = subprocess.run([
                    'powershell', '-Command', f'Stop-Process -Id {pid} -Force'
                ], capture_output=True, timeout=3)
                if result.returncode == 0:
                    success = True
                    print(f"[FORTRESS-TERMINATOR] ‚úÖ Method 6 (PowerShell) SUCCESS: {name}")
            except Exception as e:
                print(f"[FORTRESS-TERMINATOR] ‚ùå Method 6 failed: {e}")
        
        if success:
            self.terminated_count += 1
            self.threat_terminated.emit(name, pid)
            print(f"[FORTRESS-TERMINATOR] ‚úÖ THREAT ELIMINATED: {name} (Total: {self.terminated_count})")
        else:
            print(f"[FORTRESS-TERMINATOR] ‚ùå CRITICAL: FAILED TO ELIMINATE {name} (PID: {pid})")
            print(f"[FORTRESS-TERMINATOR] üö® ESCALATING TO SYSTEM ADMINISTRATOR")
        
        return success
    
    def stop_terminator(self):
        """Stop the terminator"""
        print("[TERMINATOR] üõë Stopping immediate threat terminator...")
        self.running = False

def start_immediate_protection():
    """Start immediate threat protection"""
    terminator = ImmediateThreatTerminator()
    terminator.start()
    return terminator

if __name__ == "__main__":
    # Test the terminator
    terminator = start_immediate_protection()
    
    try:
        while True:
            time.sleep(1)
    except KeyboardInterrupt:
        terminator.stop_terminator()
        terminator.quit()
        terminator.wait()
