#!/usr/bin/env python3
"""
Memory Protection Layer - Prevents memory injection and code modification attacks
"""

import os
import sys
import ctypes
import psutil
import threading
import time
from ctypes import wintypes, windll
from PyQt5.QtCore import QThread, pyqtSignal

class MemoryProtectionMonitor(QThread):
    """Monitor for memory injection and code modification attacks"""
    
    memory_attack_detected = pyqtSignal(int, str, str)  # pid, process_name, attack_type
    
    def __init__(self):
        super().__init__()
        self.running = True
        self.kernel32 = ctypes.windll.kernel32
        self.ntdll = ctypes.windll.ntdll
        self.protected_processes = set()
        
    def run(self):
        """Monitor memory protection continuously"""
        print("[MEMORY-PROTECTION] Starting memory injection monitoring...")
        
        while self.running:
            try:
                self.scan_memory_injections()
                self.monitor_code_modifications()
                time.sleep(0.02)  # 20ms scan interval
                
            except Exception as e:
                print(f"[MEMORY-PROTECTION] Error: {e}")
                time.sleep(0.1)
    
    def scan_memory_injections(self):
        """Scan for memory injection attacks"""
        for proc in psutil.process_iter(['pid', 'name', 'memory_info']):
            try:
                pid = proc.info['pid']
                name = proc.info['name']
                
                # Skip system processes
                if pid < 4 or name.lower() in ['system', 'idle', 'csrss.exe']:
                    continue
                
                # Check for suspicious memory patterns
                if self.detect_memory_injection(pid, name):
                    self.memory_attack_detected.emit(pid, name, "MEMORY_INJECTION")
                
                # Check for process hollowing
                if self.detect_process_hollowing(pid, name):
                    self.memory_attack_detected.emit(pid, name, "PROCESS_HOLLOWING")
                
            except (psutil.NoSuchProcess, psutil.AccessDenied):
                continue
    
    def detect_memory_injection(self, pid, name):
        """Detect memory injection techniques"""
        try:
            # Open process with query information access
            handle = self.kernel32.OpenProcess(0x0400, False, pid)  # PROCESS_QUERY_INFORMATION
            if not handle:
                return False
            
            # Check for suspicious memory regions
            suspicious_regions = 0
            
            # Use VirtualQueryEx to scan memory regions
            address = 0
            while address < 0x7FFFFFFF:  # User space limit
                mbi = ctypes.create_string_buffer(48)  # MEMORY_BASIC_INFORMATION size
                
                result = self.kernel32.VirtualQueryEx(
                    handle, ctypes.c_void_p(address), mbi, 48
                )
                
                if result == 0:
                    break
                
                # Parse MEMORY_BASIC_INFORMATION
                base_address = ctypes.c_void_p.from_buffer(mbi, 0).value
                region_size = ctypes.c_size_t.from_buffer(mbi, 16).value
                state = ctypes.c_ulong.from_buffer(mbi, 20).value
                protect = ctypes.c_ulong.from_buffer(mbi, 24).value
                
                # Check for executable regions that are suspicious
                if (state == 0x1000 and  # MEM_COMMIT
                    protect & 0x40):     # PAGE_EXECUTE_READWRITE
                    suspicious_regions += 1
                
                address = base_address + region_size
                
                # Too many suspicious regions indicates injection
                if suspicious_regions > 10:
                    self.kernel32.CloseHandle(handle)
                    return True
            
            self.kernel32.CloseHandle(handle)
            return False
            
        except Exception as e:
            return False
    
    def detect_process_hollowing(self, pid, name):
        """Detect process hollowing attacks"""
        try:
            proc = psutil.Process(pid)
            
            # Get process executable path
            try:
                exe_path = proc.exe()
            except (psutil.AccessDenied, psutil.NoSuchProcess):
                # Process with no executable path is suspicious
                return True
            
            # Check if process name matches executable
            expected_name = os.path.basename(exe_path).lower()
            actual_name = name.lower()
            
            if expected_name != actual_name:
                return True
            
            # Check for mismatched memory usage patterns
            memory_info = proc.memory_info()
            
            # Hollowed processes often have unusual memory patterns
            if memory_info.rss > 100 * 1024 * 1024:  # > 100MB
                # Check if memory usage is disproportionate to file size
                try:
                    file_size = os.path.getsize(exe_path)
                    if memory_info.rss > file_size * 50:  # 50x file size
                        return True
                except:
                    pass
            
            return False
            
        except Exception as e:
            return False
    
    def monitor_code_modifications(self):
        """Monitor for runtime code modifications"""
        for proc in psutil.process_iter(['pid', 'name']):
            try:
                pid = proc.info['pid']
                name = proc.info['name']
                
                # Skip system processes
                if pid < 4:
                    continue
                
                # Check for code patching
                if self.detect_code_patching(pid, name):
                    self.memory_attack_detected.emit(pid, name, "CODE_PATCHING")
                
            except (psutil.NoSuchProcess, psutil.AccessDenied):
                continue
    
    def detect_code_patching(self, pid, name):
        """Detect runtime code patching"""
        try:
            # Open process for reading
            handle = self.kernel32.OpenProcess(0x0010, False, pid)  # PROCESS_VM_READ
            if not handle:
                return False
            
            # Read first few bytes of main module
            buffer = ctypes.create_string_buffer(16)
            bytes_read = ctypes.c_size_t()
            
            # Try to read from typical entry point
            result = self.kernel32.ReadProcessMemory(
                handle, ctypes.c_void_p(0x400000), buffer, 16, ctypes.byref(bytes_read)
            )
            
            self.kernel32.CloseHandle(handle)
            
            if result and bytes_read.value > 0:
                # Check for common patching signatures
                data = buffer.raw[:bytes_read.value]
                
                # Look for jump instructions at entry point (common in patching)
                if len(data) >= 5:
                    if data[0] == 0xE9:  # JMP instruction
                        return True
                    if data[0:2] == b'\xFF\x25':  # JMP [address]
                        return True
            
            return False
            
        except Exception as e:
            return False
    
    def stop_monitoring(self):
        """Stop memory protection monitoring"""
        self.running = False

class ProcessIntegrityChecker(QThread):
    """Check process integrity and detect tampering"""
    
    integrity_violation = pyqtSignal(int, str, str)  # pid, process_name, violation_type
    
    def __init__(self):
        super().__init__()
        self.running = True
        self.process_baselines = {}
        
    def run(self):
        """Monitor process integrity"""
        print("[INTEGRITY-CHECKER] Starting process integrity monitoring...")
        
        while self.running:
            try:
                self.check_process_integrity()
                time.sleep(0.5)  # 500ms scan interval
                
            except Exception as e:
                print(f"[INTEGRITY-CHECKER] Error: {e}")
                time.sleep(1)
    
    def check_process_integrity(self):
        """Check integrity of running processes"""
        for proc in psutil.process_iter(['pid', 'name', 'exe', 'cmdline']):
            try:
                pid = proc.info['pid']
                name = proc.info['name']
                
                # Skip system processes
                if pid < 4:
                    continue
                
                # Establish baseline for new processes
                if pid not in self.process_baselines:
                    self.establish_baseline(proc.info)
                    continue
                
                # Check for integrity violations
                if self.detect_integrity_violation(proc.info):
                    self.integrity_violation.emit(pid, name, "PROCESS_TAMPERING")
                
            except (psutil.NoSuchProcess, psutil.AccessDenied):
                continue
    
    def establish_baseline(self, proc_info):
        """Establish baseline for process"""
        try:
            pid = proc_info['pid']
            
            baseline = {
                'name': proc_info['name'],
                'exe': proc_info.get('exe', ''),
                'cmdline': proc_info.get('cmdline', []),
                'creation_time': time.time()
            }
            
            self.process_baselines[pid] = baseline
            
        except Exception as e:
            pass
    
    def detect_integrity_violation(self, proc_info):
        """Detect process integrity violations"""
        try:
            pid = proc_info['pid']
            baseline = self.process_baselines.get(pid, {})
            
            if not baseline:
                return False
            
            # Check if executable path changed (process replacement)
            if baseline.get('exe') != proc_info.get('exe', ''):
                return True
            
            # Check if command line changed (argument injection)
            if baseline.get('cmdline') != proc_info.get('cmdline', []):
                return True
            
            # Check if process name changed (name spoofing)
            if baseline.get('name') != proc_info['name']:
                return True
            
            return False
            
        except Exception as e:
            return False
    
    def stop_monitoring(self):
        """Stop integrity monitoring"""
        self.running = False

class MemoryProtectionSystem:
    """Comprehensive memory protection system"""
    
    def __init__(self):
        self.memory_monitor = MemoryProtectionMonitor()
        self.integrity_checker = ProcessIntegrityChecker()
        self.attacks_detected = 0
        
    def start_memory_protection(self):
        """Start memory protection system"""
        print("ðŸ›¡ï¸ MEMORY PROTECTION SYSTEM STARTING...")
        
        # Start memory injection monitoring
        self.memory_monitor.memory_attack_detected.connect(self.handle_memory_attack)
        self.memory_monitor.start()
        
        # Start process integrity checking
        self.integrity_checker.integrity_violation.connect(self.handle_integrity_violation)
        self.integrity_checker.start()
        
        print("ðŸ›¡ï¸ MEMORY PROTECTION ACTIVE - INJECTION ATTACKS WILL BE BLOCKED")
    
    def handle_memory_attack(self, pid, process_name, attack_type):
        """Handle detected memory attack"""
        print(f"ðŸš¨ MEMORY ATTACK DETECTED: {attack_type} in {process_name} (PID: {pid})")
        
        # Immediately terminate the attacking process
        self.terminate_attacking_process(pid, process_name, attack_type)
        
        self.attacks_detected += 1
    
    def handle_integrity_violation(self, pid, process_name, violation_type):
        """Handle process integrity violation"""
        print(f"ðŸš¨ INTEGRITY VIOLATION: {violation_type} in {process_name} (PID: {pid})")
        
        # Terminate compromised process
        self.terminate_attacking_process(pid, process_name, violation_type)
        
        self.attacks_detected += 1
    
    def terminate_attacking_process(self, pid, process_name, attack_type):
        """Terminate process performing memory attacks"""
        print(f"ðŸš¨ TERMINATING MEMORY ATTACKER: {process_name} (PID: {pid}) - {attack_type}")
        
        try:
            # Use multiple termination methods
            proc = psutil.Process(pid)
            proc.kill()
            print(f"âœ… MEMORY ATTACKER TERMINATED: {process_name}")
            
        except Exception as e:
            # Fallback to system termination
            try:
                import subprocess
                subprocess.run(['taskkill', '/F', '/PID', str(pid)], 
                             capture_output=True, timeout=2)
                print(f"âœ… MEMORY ATTACKER FORCE TERMINATED: {process_name}")
            except:
                print(f"âŒ FAILED TO TERMINATE MEMORY ATTACKER: {process_name}")
    
    def get_protection_stats(self):
        """Get memory protection statistics"""
        return {
            'attacks_detected': self.attacks_detected,
            'memory_monitor_active': self.memory_monitor.isRunning(),
            'integrity_checker_active': self.integrity_checker.isRunning()
        }
    
    def stop_memory_protection(self):
        """Stop memory protection system"""
        print("ðŸ›¡ï¸ STOPPING MEMORY PROTECTION SYSTEM...")
        
        if self.memory_monitor:
            self.memory_monitor.stop_monitoring()
            self.memory_monitor.quit()
            self.memory_monitor.wait(2000)
        
        if self.integrity_checker:
            self.integrity_checker.stop_monitoring()
            self.integrity_checker.quit()
            self.integrity_checker.wait(2000)
        
        print(f"ðŸ›¡ï¸ MEMORY PROTECTION STOPPED - {self.attacks_detected} attacks blocked")

# Global memory protection instance
memory_protection_system = None

def start_memory_protection():
    """Start memory protection system"""
    global memory_protection_system
    memory_protection_system = MemoryProtectionSystem()
    memory_protection_system.start_memory_protection()
    return memory_protection_system

def stop_memory_protection():
    """Stop memory protection system"""
    global memory_protection_system
    if memory_protection_system:
        memory_protection_system.stop_memory_protection()
        memory_protection_system = None
